{"remainingRequest":"/home/quarcs/workspace/QUARCS/QUARCS_stellarium-web-engine/apps/web-frontend/node_modules/vue-loader/lib/index.js??vue-loader-options!/home/quarcs/workspace/QUARCS/QUARCS_stellarium-web-engine/apps/web-frontend/src/components/Chart-Histogram.vue?vue&type=style&index=0&id=2b8747e6&scoped=true&lang=css&","dependencies":[{"path":"/home/quarcs/workspace/QUARCS/QUARCS_stellarium-web-engine/apps/web-frontend/src/components/Chart-Histogram.vue","mtime":1750818427335},{"path":"/home/quarcs/workspace/QUARCS/QUARCS_stellarium-web-engine/apps/web-frontend/node_modules/css-loader/dist/cjs.js","mtime":1707125446000},{"path":"/home/quarcs/workspace/QUARCS/QUARCS_stellarium-web-engine/apps/web-frontend/node_modules/vue-loader/lib/loaders/stylePostLoader.js","mtime":1707125450000},{"path":"/home/quarcs/workspace/QUARCS/QUARCS_stellarium-web-engine/apps/web-frontend/node_modules/postcss-loader/src/index.js","mtime":1707125450000},{"path":"/home/quarcs/workspace/QUARCS/QUARCS_stellarium-web-engine/apps/web-frontend/node_modules/cache-loader/dist/cjs.js","mtime":1707125360000},{"path":"/home/quarcs/workspace/QUARCS/QUARCS_stellarium-web-engine/apps/web-frontend/node_modules/vue-loader/lib/index.js","mtime":1707125450000}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:CgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKLmJhcmNoYXJ0LXBhbmVsIHsKICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDAsIDAsIDAsIDAuMyk7CiAgYmFja2Ryb3AtZmlsdGVyOiBibHVyKDVweCk7CiAgYm9yZGVyLXJhZGl1czogNXB4OwogIGJveC1zaXppbmc6IGJvcmRlci1ib3g7CiAgLyogYm9yZGVyOiAxcHggc29saWQgcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjgpOyAqLwp9Cg=="},{"version":3,"sources":["Chart-Histogram.vue"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA0OA;AACA;AACA;AACA;AACA;AACA;AACA","file":"Chart-Histogram.vue","sourceRoot":"src/components","sourcesContent":["<template>\n  <div>\n    <div ref=\"barchart\" :style=\"{ width: containerMaxWidth + 'px', height: 80 + 'px' }\" class=\"barchart-panel\"></div>\n  </div>\n</template>\n\n\n<script>\nimport * as echarts from 'echarts';\n\nexport default {\n  name: 'BarChart',\n  data() {\n    return {\n      containerMaxWidth: 190,\n      barData: [],  // 示例数据\n      xAxis_min: 0,\n      xAxis_max: 65535,\n\n      histogram_min: 0,\n      histogram_max: 65535,\n    };\n  },\n  mounted() {\n\n  },\n  created() {\n    // this.$bus.$on('InitChart', this.setMaxWidth);\n    this.$bus.$on('showHistogram', this.addDataToChart);\n    this.$bus.$on('updateHistogramWidth', this.initChart);\n  },\n  methods: {\n    initChart(Width) {\n      this.containerMaxWidth = Width - 10;\n      const chartDom = this.$refs.barchart;\n      chartDom.style.width = this.containerMaxWidth + 'px';\n      this.myChart = echarts.init(chartDom);\n      this.renderChart(this.xAxis_min, this.xAxis_max);\n    },\n\n    renderChart(x_min, x_max) {\n      // 如果没有数据，则退出\n      if (this.barData.length === 0) return;\n      \n      const yAxisMax = Math.max(...this.barData.flatMap(channel => \n        channel.map(item => item[1])\n      ));  // 获取所有通道中的y轴最大值\n      \n      const option = {\n        grid: {\n          left: '-1%',\n          right: '1%',\n          bottom: '0%',\n          top: '0%',\n          containLabel: true\n        },\n        xAxis: {\n          type: 'value',\n          min: x_min,\n          max: x_max,\n          axisLine: {\n            lineStyle: {\n              color: 'white'\n            }\n          },\n          axisLabel: null,\n          splitLine: {\n            show: false\n          }\n        },\n        yAxis: {\n          type: 'value',\n          max: yAxisMax,\n          axisLine: {\n            lineStyle: {\n              color: 'white'\n            }\n          },\n          axisLabel: null,\n          splitLine: {\n            show: false\n          }\n        },\n        series: []\n      };\n\n      // 根据实际通道数量创建系列\n      const colors = ['rgba(0,120,212,0.7)', 'rgba(51,218,121,0.7)', 'rgba(255,0,0,0.7)'];\n      \n      // 灰度图和彩色图使用不同的颜色方案\n      if (this.barData.length === 1) {\n        // 灰度图只有一个通道，使用白色\n        option.series.push({\n          data: this.barData[0],\n          type: 'line',\n          itemStyle: {\n            color: 'rgba(255,255,255,0.7)'\n          },\n          symbolSize: 0\n        });\n      } else {\n        // 彩色图有多个通道，使用标准RGB颜色\n        for (let channel = 0; channel < this.barData.length; channel++) {\n          option.series.push({\n            data: this.barData[channel],\n            type: 'line',\n            itemStyle: {\n              color: colors[channel % colors.length]\n            },\n            symbolSize: 0\n          });\n        }\n      }\n\n      // 添加最小和最大值的垂直线\n      option.series.push({\n        data: [[this.histogram_min, 0], [this.histogram_min, yAxisMax]],\n        type: 'line',\n        lineStyle: {\n          color: 'blue',\n          type: 'dashed',\n          width: 1\n        },\n        symbolSize: 0\n      });\n\n      option.series.push({\n        data: [[this.histogram_max, 0], [this.histogram_max, yAxisMax]],\n        type: 'line',\n        lineStyle: {\n          color: 'red',\n          type: 'dashed',\n          width: 1\n        },\n        symbolSize: 0\n      });\n\n      this.myChart.setOption(option);\n    },\n\n    addDataToChart(histogramData) {\n      console.log(\"开始绘制直方图histogramData:\", histogramData);\n      this.clearBarData();\n\n      // 初始化最小和最大值的索引\n      let firstNonZeroIndex = -1;\n      let lastNonZeroIndex = -1;\n\n      // 判断数据类型并处理\n      if (!histogramData) return;\n\n      if (histogramData.gray) {\n        // 单通道数据\n        const grayData = histogramData.gray;\n        const graySeriesData = [];\n        \n        for (let i = 0; i < grayData.length; i++) {\n          if (grayData[i]) { // 检查值是否存在\n            const value = [i, grayData[i]];\n            graySeriesData.push(value);\n            \n            // 更新最小和最大值的索引\n            if (grayData[i] !== 0) {\n              if (firstNonZeroIndex === -1) {\n                firstNonZeroIndex = i;\n              }\n              if (i > lastNonZeroIndex) {\n                lastNonZeroIndex = i;\n              }\n            }\n          }\n        }\n        \n        // 单通道只添加一组数据\n        this.barData.push(graySeriesData);\n      } else {\n        // 三通道数据\n        const channels = ['red', 'green', 'blue'];\n        \n        for (let i = 0; i < channels.length; i++) {\n          const channelName = channels[i];\n          const channelData = histogramData[channelName];\n          if (!channelData) continue;\n          \n          const channelSeriesData = [];\n          \n          for (let j = 0; j < channelData.length; j++) {\n            if (channelData[j]) {\n              const value = [j, channelData[j]];\n              channelSeriesData.push(value);\n              \n              // 更新最小和最大值的索引\n              if (channelData[j] !== 0) {\n                if (firstNonZeroIndex === -1) {\n                  firstNonZeroIndex = j;\n                }\n                if (j > lastNonZeroIndex) {\n                  lastNonZeroIndex = j;\n                }\n              }\n            }\n          }\n          \n          this.barData.push(channelSeriesData);\n        }\n      }\n\n      // 发送最小和最大值的索引到其他组件\n      this.histogram_min = firstNonZeroIndex;\n      this.histogram_max = lastNonZeroIndex;\n\n      console.log(\"barData 长度:\", this.barData.length);\n      console.log(\"histogram_min:\", this.histogram_min, \"histogram_max:\", this.histogram_max);\n      \n      if (this.barData.length > 0) {\n        this.$bus.$emit('AutoHistogramNum', this.histogram_min, this.histogram_max);\n        this.$bus.$emit('SendConsoleLogMsg', 'First Non-Zero Index:' + firstNonZeroIndex, 'info');\n        this.$bus.$emit('SendConsoleLogMsg', 'Last Non-Zero Index:' + lastNonZeroIndex, 'info');\n        this.renderChart(this.xAxis_min, this.xAxis_max);\n      } else {\n        console.log(\"没有有效的直方图数据\");\n      }\n    },\n\n    clearBarData() {\n      this.barData = [];  // 清空数据\n      this.renderChart(this.xAxis_min, this.xAxis_max);  // 重新渲染图表\n    }\n  }\n}\n</script>\n\n\n<style scoped>\n.barchart-panel {\n  background-color: rgba(0, 0, 0, 0.3);\n  backdrop-filter: blur(5px);\n  border-radius: 5px;\n  box-sizing: border-box;\n  /* border: 1px solid rgba(255, 255, 255, 0.8); */\n}\n</style>\n"]}]}