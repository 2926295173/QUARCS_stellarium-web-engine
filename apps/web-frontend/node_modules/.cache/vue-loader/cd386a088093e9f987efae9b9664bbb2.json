{"remainingRequest":"/home/quarcs/workspace/QUARCS/QUARCS_stellarium-web-engine/apps/web-frontend/node_modules/vue-loader/lib/index.js??vue-loader-options!/home/quarcs/workspace/QUARCS/QUARCS_stellarium-web-engine/apps/web-frontend/src/components/AutomaticPolarAlignmentCalibration.vue?vue&type=script&lang=js&","dependencies":[{"path":"/home/quarcs/workspace/QUARCS/QUARCS_stellarium-web-engine/apps/web-frontend/src/components/AutomaticPolarAlignmentCalibration.vue","mtime":1761021421393},{"path":"/home/quarcs/workspace/QUARCS/QUARCS_stellarium-web-engine/apps/web-frontend/node_modules/cache-loader/dist/cjs.js","mtime":1707125360000},{"path":"/home/quarcs/workspace/QUARCS/QUARCS_stellarium-web-engine/apps/web-frontend/node_modules/thread-loader/dist/cjs.js","mtime":1707125360000},{"path":"/home/quarcs/workspace/QUARCS/QUARCS_stellarium-web-engine/apps/web-frontend/node_modules/babel-loader/lib/index.js","mtime":1707125360000},{"path":"/home/quarcs/workspace/QUARCS/QUARCS_stellarium-web-engine/apps/web-frontend/node_modules/cache-loader/dist/cjs.js","mtime":1707125360000},{"path":"/home/quarcs/workspace/QUARCS/QUARCS_stellarium-web-engine/apps/web-frontend/node_modules/vue-loader/lib/index.js","mtime":1707125450000}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:Ly8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KCi8vIOW4uOmHj+WumuS5iQpjb25zdCBDT0xPUlMgPSB7CiAgUFJJTUFSWTogJyM2NGI1ZjYnLAogIFNVQ0NFU1M6ICcjNGNhZjUwJywKICBXQVJOSU5HOiAnI2ZmOTgwMCcsCiAgRVJST1I6ICcjZjQ0MzM2JywKICBJTkZPOiAnIzIxOTZmMycsCiAgV0hJVEU6ICcjZmZmZmZmJywKICBCQUNLR1JPVU5EOiAncmdiYSgzNSwgMzUsIDQ1LCAwLjk1KScsCiAgU1VSRkFDRTogJ3JnYmEoNjAsIDYwLCA3MCwgMC45KScKfQoKY29uc3QgQ0FMSUJSQVRJT05fUEhBU0VTID0gewogIElOSVRJQUw6ICdpbml0aWFsJywKICBDT0xMRUNUSU5HOiAnY29sbGVjdGluZycsCiAgQURKVVNUSU5HOiAnYWRqdXN0aW5nJywKICBWRVJJRllJTkc6ICd2ZXJpZnlpbmcnCn0KCmNvbnN0IFBST0dSRVNTX1RIUkVTSE9MRFMgPSB7CiAgSU5JVElBTElaQVRJT046IDE1LAogIEZJUlNUX0NBTElCUkFUSU9OOiAyNSwKICBTRUNPTkRfQ0FMSUJSQVRJT046IDUwLAogIFRISVJEX0NBTElCUkFUSU9OOiA3NSwKICBDQUxJQlJBVElPTl9MT09QOiA5NSwKICBDT01QTEVUSU9OOiAxMDAKfQoKY29uc3QgRElNRU5TSU9OUyA9IHsKICBNSU5JTUlaRUQ6IHsgd2lkdGg6IDI1MCwgaGVpZ2h0OiA4MCB9LAogIENPTExBUFNFRDogeyB3aWR0aDogMzAwLCBoZWlnaHQ6IDEyMCB9LAogIEVYUEFOREVEOiB7IHdpZHRoOiAzNTAsIGhlaWdodDogNDAwIH0KfQoKY29uc3QgTE9HX0xJTUlUID0gMTAwCmNvbnN0IERJU1BMQVlfTE9HX0xJTUlUID0gMTAKCmV4cG9ydCBkZWZhdWx0IHsKICBuYW1lOiAnQXV0b21hdGljUG9sYXJBbGlnbm1lbnRDYWxpYnJhdGlvbicsCgogIHByb3BzOiB7CiAgICB2aXNpYmxlOiB7CiAgICAgIHR5cGU6IEJvb2xlYW4sCiAgICAgIGRlZmF1bHQ6IGZhbHNlCiAgICB9LAogICAgYXV0b1N0YXJ0OiB7CiAgICAgIHR5cGU6IEJvb2xlYW4sCiAgICAgIGRlZmF1bHQ6IGZhbHNlCiAgICB9LAogICAgLy8g5paw5aKe77ya5Lyg5YWl6LCD5pW05pWw5o2u55qE5Y2V5L2N77yIJ2RlZycgfCAnYXJjbWluJyB8ICdhcmNzZWMn77yJCiAgICBhZGp1c3RtZW50VW5pdDogeyB0eXBlOiBTdHJpbmcsIGRlZmF1bHQ6ICdhcmNtaW4nIH0sCgogICAgLy8g5paw5aKe77ya55So5oi356uZ5L2N6KeG6KeS77yIJ25vcnRoJyB8ICdzb3V0aCfvvInvvIznlKjkuo7lt6blj7PmmKDlsIQKICAgIGZhY2luZ1BvbGU6IHsgdHlwZTogU3RyaW5nLCBkZWZhdWx0OiAnbm9ydGgnIH0sCgogICAgLy8g5paw5aKe77ya5Yqo5L2c5q275Yy677yI5Lul6KeS5YiG5a6a5LmJ77yMVUnliKTlrprmmK/lkKbpnIDopoHliqjkvZzvvIkKICAgIGRlYWRiYW5kQXJjbWluOiB7IHR5cGU6IE51bWJlciwgZGVmYXVsdDogMC41IH0KICB9LAoKICBkYXRhKCkgewogICAgcmV0dXJuIHsKICAgICAgLy8g6L+e5o6l54q25oCBCiAgICAgIGlzQ29ubmVjdGVkOiBmYWxzZSwKCiAgICAgIC8vIOS9jee9ruS/oeaBrwogICAgICBjdXJyZW50UG9zaXRpb246IHsKICAgICAgICByYTogJzAwaCAwMG0gMDBzJywKICAgICAgICBkZWM6ICcrMDDCsCAwMFwnIDAwIicKICAgICAgfSwKICAgICAgdGFyZ2V0UG9zaXRpb246IHsKICAgICAgICByYTogJzAwaCAwMG0gMDBzJywKICAgICAgICBkZWM6ICcrMDDCsCAwMFwnIDAwIicKICAgICAgfSwKICAgICAgcHJldmlvdXNQb3NpdGlvbjogewogICAgICAgIHJhOiAnMDBoIDAwbSAwMHMnLAogICAgICAgIGRlYzogJyswMMKwIDAwXCcgMDAiJwogICAgICB9LAoKICAgICAgLy8g5qCh5YeG5pWw5o2uCiAgICAgIGlzQ2FsaWJyYXRpb25Db21wbGV0ZTogZmFsc2UsCiAgICAgIGlzUG9sYXJBbGlnbmVkOiBmYWxzZSwKCiAgICAgIC8vIOiwg+aVtOS/oeaBrwogICAgICBhZGp1c3RtZW50OiB7CiAgICAgICAgYXppbXV0aDogMC4wLAogICAgICAgIGFsdGl0dWRlOiAwLjAKICAgICAgfSwKCiAgICAgIC8vIOaXpeW/l+ezu+e7nyAtIOS9v+eUqOW+queOr+aVsOe7hOS8mOWMluWGheWtmAogICAgICBsb2dzOiBbXSwKICAgICAgbG9nSW5kZXg6IDAsCiAgICAgIGxvZ0NhcGFjaXR5OiBMT0dfTElNSVQsCgogICAgICAvLyDmoKHlh4bov5DooYznirbmgIEKICAgICAgaXNDYWxpYnJhdGlvblJ1bm5pbmc6IGZhbHNlLAoKICAgICAgLy8g6KeG5Zy65pWw5o2uCiAgICAgIGZpZWxkRGF0YTogbnVsbCwKCiAgICAgIC8vIOW9k+WJjei/m+W6pgogICAgICBjdXJyZW50UHJvZ3Jlc3M6IDAsCgogICAgICAvLyA9PT0g5paw5aKe77ya55WM6Z2i5o6n5Yi254q25oCBID09PQogICAgICAvLyDmi5bliqjnirbmgIEKICAgICAgaXNEcmFnZ2luZzogZmFsc2UsCiAgICAgIGRyYWdPZmZzZXQ6IHsgeDogMCwgeTogMCB9LAoKICAgICAgLy8g5o6n5Lu25L2N572uCiAgICAgIHBvc2l0aW9uOiB7IHg6IDUwLCB5OiA1MCB9LAoKICAgICAgLy8g55WM6Z2i54q25oCBCiAgICAgIGlzTWluaW1pemVkOiBmYWxzZSwKICAgICAgaXNDb2xsYXBzZWQ6IGZhbHNlLAoKICAgICAgLy8gPT09IOaWsOWinu+8muaAp+iDveS8mOWMliA9PT0KICAgICAgLy8g57yT5a2Y5bC65a+46K6h566X57uT5p6cCiAgICAgIGNhY2hlZERpbWVuc2lvbnM6IHsKICAgICAgICB3aWR0aDogMzUwLAogICAgICAgIGhlaWdodDogNDAwCiAgICAgIH0sCiAgICAgIC8vIOaLluWKqOeKtuaAgeagh+iusAogICAgICBpc0RyYWdnaW5nU3RhdGU6IGZhbHNlLAoKICAgICAgLy8g5YaF5a2Y5riF55CG5a6a5pe25ZmoCiAgICAgIG1lbW9yeUNsZWFudXBUaW1lcjogbnVsbCwKCiAgICAgIC8vIOiuoeeul+e8k+WtmAogICAgICBjYWNoZWRBemltdXRoQXJjbWluOiBudWxsLAogICAgICBjYWNoZWRBbHRpdHVkZUFyY21pbjogbnVsbCwKICAgICAgbGFzdEF6aW11dGhWYWx1ZTogbnVsbCwKICAgICAgbGFzdEFsdGl0dWRlVmFsdWU6IG51bGwsCgogICAgICAvLyDmi5bliqjmgKfog73kvJjljJYKICAgICAgbGFzdERyYWdUaW1lOiAwLAoKICAgICAgLy8g5p6B6L205YGP56e76YePCiAgICAgIHBvbGFyQXhpc09mZnNldDogewogICAgICAgIGF6aW11dGg6IDAsCiAgICAgICAgYWx0aXR1ZGU6IDAKICAgICAgfSwKCiAgICAgIC8vIOagoeWHhuW+queOr+iuoeaVsAogICAgICBjYWxpYnJhdGlvbkxvb3BDb3VudDogMCwKICAgICAgbGFzdENhbGlicmF0aW9uUHJvZ3Jlc3M6IDAsCgogICAgICAvLyDmoKHlh4bpmLbmrrXnirbmgIEKICAgICAgY2FsaWJyYXRpb25QaGFzZTogJ2luaXRpYWwnLCAvLyAnaW5pdGlhbCcsICdjb2xsZWN0aW5nJywgJ2FkanVzdGluZycsICd2ZXJpZnlpbmcnCiAgICAgIGNhbGlicmF0aW9uUG9pbnRzOiBbXSwgLy8g5a2Y5YKo5LiJ5Liq5qCh5YeG54K555qE5Z2Q5qCHCiAgICAgIG1heENhbGlicmF0aW9uUG9pbnRzOiAzLCAvLyDmnIDlpKfmoKHlh4bngrnmlbDph48KICAgICAgdGFyZ2V0UG9pbnQ6IG51bGwsIC8vIOWtmOWCqOebruagh+eCueWdkOaghwoKICAgICAgLy8g56e76Zmk5YGH5p6B6L2055u45YWz5pWw5o2uCiAgICAgIC8vIGZha2VQb2xhckF4aXM6IHsKICAgICAgLy8gICByYTogbnVsbCwKICAgICAgLy8gICBkZWM6IG51bGwsCiAgICAgIC8vICAgY2FsY3VsYXRlZDogZmFsc2UKICAgICAgLy8gfSwKCiAgICAgIC8vID09PSDovajov7nnlLvluIPnirbmgIEgPT09CiAgICAgIHNob3dUcmFqZWN0b3J5T3ZlcmxheTogZmFsc2UsCiAgICAgIG92ZXJsYXlNb2RlOiAnZnVsbHNjcmVlbicsIC8vICdmdWxsc2NyZWVuJyB8ICd3aW5kb3dlZCcKICAgICAgdHJhamVjdG9yeVNjYWxlOiAxLCAvLyDlt7LlvIPnlKjvvIjkuI3lho3kvb/nlKjmiYvliqjnvKnmlL7vvIkKICAgICAgYXV0b0ZpdFB4UGVyRGVnOiA0MCwgLy8g6Ieq5Yqo6YCC6YWN6K6h566X5Ye655qEIHB4L2RlZ++8iOWfuuS6juW9k+WJjeeUu+W4g+WwuuWvuOS4juaVsOaNruiMg+WbtO+8iQogICAgICB0cmFqZWN0b3J5UG9pbnRzOiBbXSwgLy8gW3t4LCB5fV0gaW4gb3ZlcmxheSBjYW52YXMgc3BhY2UgYWZ0ZXIgdHJhbnNmb3JtCiAgICAgIHJhd1RyYWplY3RvcnlQb2ludHM6IFtdLCAvLyDkv53lrZjljp/lp4vnmoQge3JhLCBkZWN9IOW6j+WIlwogICAgICBsYXN0UmF3UG9zaXRpb246IG51bGwsIC8vIHtyYSwgZGVjfSBudW1lcmljCiAgICAgIHRhcmdldFJhd1Bvc2l0aW9uOiBudWxsLCAvLyB7cmEsIGRlY30gbnVtZXJpYywgZml4ZWQgYXMgb3ZlcmxheSBjZW50ZXIgcmVmZXJlbmNlCiAgICAgIHdpbmRvd2VkUmVjdDogeyB4OiA0MCwgeTogODAsIHdpZHRoOiA0MjAsIGhlaWdodDogMzAwIH0sCiAgICAgIC8vIOmAu+i+keeUu+W4g+WwuuWvuO+8mueUqOS6jueql+WPo+aooeW8j+WwhuKAnOWFqOWxj+eUu+W4g+KAneaMieavlOS+i+e8qeaUvui/m+eql+WPowogICAgICBiYXNlQ2FudmFzTG9naWNhbFNpemU6IHsgd2lkdGg6IDEyODAsIGhlaWdodDogNzIwIH0sCiAgICAgIHdpbmRvd0RyYWc6IHsgYWN0aXZlOiBmYWxzZSwgb2Zmc2V0WDogMCwgb2Zmc2V0WTogMCB9LAogICAgICAvLyA9PT0g6KeG5Zu+5Y+Y5o2i77yI5LuF57yp5bCP5q+U5L6L77yb5Lul55uu5qCH5LiO6aaW54K55aGr5ruh55S75biD77yJID09PQogICAgICBjdXJyZW50UHhQZXJEZWc6IG51bGwsIC8vIOW9k+WJjeWDj+e0oC/luqbvvIzlj6rkvJrnvKnlsI8KICAgICAgdmlld01pbldvcmxkWDogbnVsbCwgLy8g5LiW55WM5Z2Q5qCH77yaWCDkuLogZFJBKHVud3JhcHBlZCnvvIxZIOS4uiBkRGVjCiAgICAgIHZpZXdNYXhXb3JsZFg6IG51bGwsCiAgICAgIHZpZXdNaW5Xb3JsZFk6IG51bGwsCiAgICAgIHZpZXdNYXhXb3JsZFk6IG51bGwsCiAgICAgIHJhVW53cmFwQW5jaG9yOiBudWxsLCAvLyBkUkEg5bGV5byA6ZSa54K577yI6aaW54K555u45a+555uu5qCH77yJCiAgICAgIHZpZXdQYWRSYXRpb1g6IDAuMTIsCiAgICAgIHZpZXdQYWRSYXRpb1k6IDAuMTAsCiAgICAgIHZpZXdPZmZzZXRYUHg6IDAsCiAgICAgIHZpZXdPZmZzZXRZUHg6IDAsCiAgICAgIC8vIOi9qOi/ueeCueWQiOW5tuWuueW3ru+8iOinkuWIhu+8iQogICAgICB0cmFqZWN0b3J5TWVyZ2VUb2xBcmNtaW46IDIuMCwgIC8vIOi9qOi/ueeCueWQiOW5tuWuueW3ru+8iOinkuWIhu+8iQogICAgICBjYWxpYnJhdGlvbkNpcmNsZUFyY21pbjogMS4wLCAgLy8g5qCh5YeG5ZyG5Y2K5b6E77yI6KeS5YiG77yJLS0g57qm562J5LqO5qCh5YeG57K+5bqmCgogICAgICBoYXNBY2NlcHRVcGRhdGVNZXNzYWdlOiBmYWxzZSwgLy8g5piv5ZCm5bey57uP5o6l5Y+X5pu05paw5raI5oGvLOmYsuatoueUseS6jue7hOS7tuWKoOi9vemhuuW6j+WvvOiHtOe7hOS7tuabtOaWsOS4ouWksQogICAgfQogIH0sCgogIGNvbXB1dGVkOiB7CiAgICAvLyDmmL7npLrnmoTml6Xlv5cgLSDkvb/nlKjnvJPlrZjkvJjljJYKICAgIGRpc3BsYXlMb2dzKCkgewogICAgICAvLyDov5Tlm57mnIDov5HnmoQxMOadoeaXpeW/l++8jOaMieaXtumXtOWAkuW6j++8iOeUqOS6juaYvuekuuacgOaWsOS4gOadoe+8iQogICAgICBjb25zdCBsb2dzID0gdGhpcy5sb2dzCiAgICAgIGlmIChsb2dzLmxlbmd0aCA8PSBESVNQTEFZX0xPR19MSU1JVCkgewogICAgICAgIHJldHVybiBsb2dzLnNsaWNlKCkucmV2ZXJzZSgpCiAgICAgIH0KICAgICAgcmV0dXJuIGxvZ3Muc2xpY2UoLURJU1BMQVlfTE9HX0xJTUlUKS5yZXZlcnNlKCkKICAgIH0sCgogICAgLy8g5qCh5YeG6L+b5bqm55m+5YiG5q+UCiAgICBwcm9ncmVzc1BlcmNlbnRhZ2UoKSB7CiAgICAgIC8vIOS9v+eUqOS7juWQjuerr+S8oOWFpeeahOi/m+W6pgogICAgICByZXR1cm4gdGhpcy5jdXJyZW50UHJvZ3Jlc3MKICAgIH0sCgogICAgLy8g5piv5ZCm5Y+v5Lul6Ieq5Yqo5qCh5YeGCiAgICBjYW5BdXRvQ2FsaWJyYXRlKCkgewogICAgICByZXR1cm4gdGhpcy5pc0Nvbm5lY3RlZAogICAgfSwKCiAgICAvLyDmmK/lkKbpnIDopoHmlrnkvY3op5LosIPmlbQgLSDkvb/nlKjnvJPlrZjpgb/lhY3ph43lpI3orqHnrpcKICAgIG5lZWRzQXppbXV0aEFkanVzdG1lbnQoKSB7CiAgICAgIGNvbnN0IHYgPSB0aGlzLmFkanVzdG1lbnQ/LmF6aW11dGgKICAgICAgaWYgKCFOdW1iZXIuaXNGaW5pdGUodikpIHJldHVybiBmYWxzZQogICAgICAvLyDkvb/nlKjnvJPlrZjnmoTlgLzvvIzpgb/lhY3ph43lpI3orqHnrpcKICAgICAgcmV0dXJuIHRoaXMuY2FjaGVkQXppbXV0aEFyY21pbiAhPT0gbnVsbCA/IAogICAgICAgIE1hdGguYWJzKHRoaXMuY2FjaGVkQXppbXV0aEFyY21pbikgPiB0aGlzLmRlYWRiYW5kQXJjbWluIDogCiAgICAgICAgTWF0aC5hYnModGhpcy51bml0VG9BcmNtaW4odiwgdGhpcy5hZGp1c3RtZW50VW5pdCkpID4gdGhpcy5kZWFkYmFuZEFyY21pbgogICAgfSwKCiAgICAvLyDmmK/lkKbpnIDopoHpq5jluqbop5LosIPmlbQgLSDkvb/nlKjnvJPlrZjpgb/lhY3ph43lpI3orqHnrpcKICAgIG5lZWRzQWx0aXR1ZGVBZGp1c3RtZW50KCkgewogICAgICBjb25zdCB2ID0gdGhpcy5hZGp1c3RtZW50Py5hbHRpdHVkZQogICAgICBpZiAoIU51bWJlci5pc0Zpbml0ZSh2KSkgcmV0dXJuIGZhbHNlCiAgICAgIC8vIOS9v+eUqOe8k+WtmOeahOWAvO+8jOmBv+WFjemHjeWkjeiuoeeulwogICAgICByZXR1cm4gdGhpcy5jYWNoZWRBbHRpdHVkZUFyY21pbiAhPT0gbnVsbCA/IAogICAgICAgIE1hdGguYWJzKHRoaXMuY2FjaGVkQWx0aXR1ZGVBcmNtaW4pID4gdGhpcy5kZWFkYmFuZEFyY21pbiA6IAogICAgICAgIE1hdGguYWJzKHRoaXMudW5pdFRvQXJjbWluKHYsIHRoaXMuYWRqdXN0bWVudFVuaXQpKSA+IHRoaXMuZGVhZGJhbmRBcmNtaW4KICAgIH0KICB9LAoKICB3YXRjaDogewogICAgdmlzaWJsZShuZXdWYWwpIHsKICAgICAgaWYgKG5ld1ZhbCAmJiB0aGlzLmF1dG9TdGFydCkgewogICAgICAgIHRoaXMuc3RhcnRBdXRvQ2FsaWJyYXRpb24oKQogICAgICB9CiAgICB9LAogICAgCiAgICAvLyDnm5HlkKzlvZPliY3lnZDmoIflj5jljJbvvIzoh6rliqjmm7TmlrDmnJ3lkJHmnoHngrkKICAgICckc3RvcmUuc3RhdGUuY3VycmVudExvY2F0aW9uLmxhdCc6IHsKICAgICAgaGFuZGxlcihuZXdMYXQsIG9sZExhdCkgewogICAgICAgIGlmIChuZXdMYXQgIT09IG9sZExhdCAmJiBuZXdMYXQgIT09IHVuZGVmaW5lZCkgewogICAgICAgICAgY29uc3QgZmFjaW5nUG9sZSA9IHRoaXMuY2FsY3VsYXRlRmFjaW5nUG9sZSgpCiAgICAgICAgICB0aGlzLmFkZExvZyh0aGlzLiR0KCdMb2NhdGlvbiBDaGFuZ2VkJywgW2ZhY2luZ1BvbGUsIG5ld0xhdF0pLCAnaW5mbycpCiAgICAgICAgICAKICAgICAgICAgIC8vIOWmguaenOato+WcqOiwg+aVtOmYtuaute+8jOmHjeaWsOiuoeeul+iwg+aVtOW7uuiurgogICAgICAgICAgaWYgKHRoaXMuY2FsaWJyYXRpb25QaGFzZSA9PT0gJ2FkanVzdGluZycpIHsKICAgICAgICAgICAgdGhpcy5hZGRMb2codGhpcy4kdCgnUmVjYWxjdWxhdGluZyBBZGp1c3RtZW50IERpcmVjdGlvbnMnKSwgJ2luZm8nKQogICAgICAgICAgfQogICAgICAgIH0KICAgICAgfSwKICAgICAgaW1tZWRpYXRlOiBmYWxzZQogICAgfSwKCiAgICAvLyDnm5HlkKzosIPmlbTlgLzlj5jljJbvvIzmm7TmlrDnvJPlrZggLSDkvb/nlKjpmLLmipbpgb/lhY3popHnuYHmm7TmlrAKICAgICdhZGp1c3RtZW50LmF6aW11dGgnOiB7CiAgICAgIGhhbmRsZXI6IGZ1bmN0aW9uKG5ld1ZhbCkgewogICAgICAgIGlmIChOdW1iZXIuaXNGaW5pdGUobmV3VmFsKSkgewogICAgICAgICAgLy8g5riF6Zmk5LmL5YmN55qE5a6a5pe25ZmoCiAgICAgICAgICBpZiAodGhpcy5fYXppbXV0aFVwZGF0ZVRpbWVyKSB7CiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLl9hemltdXRoVXBkYXRlVGltZXIpCiAgICAgICAgICB9CiAgICAgICAgICAvLyDkvb/nlKjpmLLmipbvvIzlu7bov58xMDBtc+abtOaWsAogICAgICAgICAgdGhpcy5fYXppbXV0aFVwZGF0ZVRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7CiAgICAgICAgICAgIHRoaXMuY2FjaGVkQXppbXV0aEFyY21pbiA9IHRoaXMudW5pdFRvQXJjbWluKG5ld1ZhbCwgdGhpcy5hZGp1c3RtZW50VW5pdCkKICAgICAgICAgICAgdGhpcy5sYXN0QXppbXV0aFZhbHVlID0gbmV3VmFsCiAgICAgICAgICB9LCAxMDApCiAgICAgICAgfQogICAgICB9LAogICAgICBpbW1lZGlhdGU6IHRydWUKICAgIH0sCgogICAgJ2FkanVzdG1lbnQuYWx0aXR1ZGUnOiB7CiAgICAgIGhhbmRsZXI6IGZ1bmN0aW9uKG5ld1ZhbCkgewogICAgICAgIGlmIChOdW1iZXIuaXNGaW5pdGUobmV3VmFsKSkgewogICAgICAgICAgLy8g5riF6Zmk5LmL5YmN55qE5a6a5pe25ZmoCiAgICAgICAgICBpZiAodGhpcy5fYWx0aXR1ZGVVcGRhdGVUaW1lcikgewogICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5fYWx0aXR1ZGVVcGRhdGVUaW1lcikKICAgICAgICAgIH0KICAgICAgICAgIC8vIOS9v+eUqOmYsuaKlu+8jOW7tui/nzEwMG1z5pu05pawCiAgICAgICAgICB0aGlzLl9hbHRpdHVkZVVwZGF0ZVRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7CiAgICAgICAgICAgIHRoaXMuY2FjaGVkQWx0aXR1ZGVBcmNtaW4gPSB0aGlzLnVuaXRUb0FyY21pbihuZXdWYWwsIHRoaXMuYWRqdXN0bWVudFVuaXQpCiAgICAgICAgICAgIHRoaXMubGFzdEFsdGl0dWRlVmFsdWUgPSBuZXdWYWwKICAgICAgICAgIH0sIDEwMCkKICAgICAgICB9CiAgICAgIH0sCiAgICAgIGltbWVkaWF0ZTogdHJ1ZQogICAgfQogIH0sCgogICAgbW91bnRlZCgpIHsKICAgICAgLy8g5a6e546w57uE5Lu25Yid5aeL5YyW6YC76L6RCiAgICAgIHRoaXMuaW5pdGlhbGl6ZSgpCgogICAgICAvLyDliJ3lp4vljJbnvJPlrZjnmoTlsLrlr7jkv6Hmga8KICAgICAgdGhpcy51cGRhdGVDYWNoZWREaW1lbnNpb25zKCkKCiAgICAgIC8vIOebkeWQrOS/oeWPt+aAu+e6v+S6i+S7tgogICAgICB0aGlzLiRidXMuJG9uKCdzaG93UG9sYXJBbGlnbm1lbnQnLCB0aGlzLnNob3dJbnRlcmZhY2UpCiAgICAgIHRoaXMuJGJ1cy4kb24oJ2hpZGVQb2xhckFsaWdubWVudCcsIHRoaXMuaGlkZUludGVyZmFjZSkKCiAgICAgIC8vIOebkeWQrOi1pOmBk+S7qui/nuaOpeeKtuaAgQogICAgICB0aGlzLiRidXMuJG9uKCdNb3VudENvbm5lY3RlZCcsIHRoaXMudXBkYXRlTW91bnRDb25uZWN0aW9uKQoKICAgICAgLy8g5o6l5pS254q25oCB5pu05pawCiAgICAgIHRoaXMuJGJ1cy4kb24oJ1BvbGFyQWxpZ25tZW50U3RhdGUnLCB0aGlzLnVwZGF0ZVBvbGFyQWxpZ25tZW50U3RhdGUpCgogICAgICAvLyDnm5HlkKzop4blnLrmlbDmja7mm7TmlrAKICAgICAgdGhpcy4kYnVzLiRvbignRmllbGREYXRhVXBkYXRlJywgdGhpcy51cGRhdGVGaWVsZERhdGEpCgogICAgICAvLyDnm5HlkKzljaHniYfkv6Hmga/mm7TmlrAKICAgICAgdGhpcy4kYnVzLiRvbigndXBkYXRlQ2FyZEluZm8nLCB0aGlzLnVwZGF0ZUNhcmRJbmZvKQoKICAgICAgLy8g55uR5ZCs6Ieq5Yqo5qCh5YeG54q25oCBCiAgICAgIHRoaXMuJGJ1cy4kb24oJ1BvbGFyQWxpZ25tZW50SXNSdW5uaW5nJywgdGhpcy51cGRhdGVQb2xhckFsaWdubWVudElzUnVubmluZykKCiAgICAgIC8vIOe7hOS7tuWKoOi9veWujOaIkOWQju+8jOiLpeWwmuacquaUtuWIsOabtOaWsOa2iOaBr++8jOWImeS4u+WKqOivt+axguaegei9tOWvuem9kOeKtuaAgQogICAgICBpZiAoIXRoaXMuaGFzQWNjZXB0VXBkYXRlTWVzc2FnZSkgewogICAgICAgIHRoaXMuJGJ1cy4kZW1pdCgnQXBwU2VuZE1lc3NhZ2UnLCAnVnVlX0NvbW1hbmQnLCAnZ2V0UG9sYXJBbGlnbm1lbnRTdGF0ZScpCiAgICAgIH0KCiAgICAgIC8vIOWQr+WKqOWumuacn+WGheWtmOa4heeQhu+8iOavjzXliIbpkp/muIXnkIbkuIDmrKHvvIkKICAgICAgdGhpcy5zdGFydE1lbW9yeUNsZWFudXAoKQogICAgfSwKCiAgICBiZWZvcmVEZXN0cm95KCkgewogICAgICAvLyDnp7vpmaTkv6Hlj7fmgLvnur/nm5HlkKwKICAgICAgdGhpcy4kYnVzLiRvZmYoJ3Nob3dQb2xhckFsaWdubWVudCcsIHRoaXMuc2hvd0ludGVyZmFjZSkKICAgICAgdGhpcy4kYnVzLiRvZmYoJ2hpZGVQb2xhckFsaWdubWVudCcsIHRoaXMuaGlkZUludGVyZmFjZSkKICAgICAgdGhpcy4kYnVzLiRvZmYoJ01vdW50Q29ubmVjdGVkJywgdGhpcy51cGRhdGVNb3VudENvbm5lY3Rpb24pCiAgICAgIHRoaXMuJGJ1cy4kb2ZmKCdQb2xhckFsaWdubWVudFN0YXRlJywgdGhpcy51cGRhdGVQb2xhckFsaWdubWVudFN0YXRlKQogICAgICB0aGlzLiRidXMuJG9mZignRmllbGREYXRhVXBkYXRlJywgdGhpcy51cGRhdGVGaWVsZERhdGEpCiAgICAgIHRoaXMuJGJ1cy4kb2ZmKCd1cGRhdGVDYXJkSW5mbycsIHRoaXMudXBkYXRlQ2FyZEluZm8pCiAgICAgIHRoaXMuJGJ1cy4kb2ZmKCdQb2xhckFsaWdubWVudElzUnVubmluZycsIHRoaXMudXBkYXRlUG9sYXJBbGlnbm1lbnRJc1J1bm5pbmcpCgogICAgICAvLyDmuIXnkIbmi5bliqjkuovku7bnm5HlkKwKICAgICAgdGhpcy5jbGVhbnVwRHJhZ0xpc3RlbmVycygpCgogICAgICAvLyDmuIXnkIbnvJPlrZjmlbDmja4KICAgICAgdGhpcy5jbGVhckNhY2hlZERhdGEoKQoKICAgICAgLy8g5YGc5q2i5YaF5a2Y5riF55CG5a6a5pe25ZmoCiAgICAgIHRoaXMuc3RvcE1lbW9yeUNsZWFudXAoKQoKICAgICAgLy8g5riF55CG6Ziy5oqW5a6a5pe25ZmoCiAgICAgIHRoaXMuY2xlYXJEZWJvdW5jZVRpbWVycygpCgogICAgICAvLyDlrp7njrDnu4Tku7bplIDmr4HpgLvovpEKICAgICAgdGhpcy5jbGVhbnVwKCkKICAgIH0sCgogICAgbWV0aG9kczogewogICAgICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09CiAgICAgIC8vIOS/oeWPt+aAu+e6v+S6i+S7tuWkhOeQhgogICAgICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09CiAgICAgIHNob3dJbnRlcmZhY2UoKSB7CiAgICAgICAgdGhpcy4kZW1pdCgndXBkYXRlOnZpc2libGUnLCB0cnVlKQogICAgICB9LAoKICAgICAgaGlkZUludGVyZmFjZSgpIHsKICAgICAgICB0aGlzLiRlbWl0KCd1cGRhdGU6dmlzaWJsZScsIGZhbHNlKQogICAgICB9LAoKICAgICAgdXBkYXRlTW91bnRDb25uZWN0aW9uKHN0YXR1cykgewogICAgICAgIHRoaXMuaXNDb25uZWN0ZWQgPSBzdGF0dXMgPT09IDEKICAgICAgICBjb25zdCBzdGF0dXNUZXh0ID0gdGhpcy5pc0Nvbm5lY3RlZCA/IHRoaXMuJHQoJ0Nvbm5lY3RlZCcpIDogdGhpcy4kdCgnRGlzY29ubmVjdGVkJykKICAgICAgICB0aGlzLmFkZExvZyh0aGlzLiR0KCdNb3VudCBDb25uZWN0aW9uIFN0YXR1cycsIFtzdGF0dXNUZXh0XSksIHRoaXMuaXNDb25uZWN0ZWQgPyAnc3VjY2VzcycgOiAnd2FybmluZycpCiAgICAgIH0sCgogICAgICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09CiAgICAgIC8vIOWIneWni+WMluWSjOa4heeQhgogICAgICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09CiAgICAgIGluaXRpYWxpemUoKSB7CiAgICAgICAgdGhpcy5hZGRMb2codGhpcy4kdCgnUG9sYXIgQWxpZ25tZW50IENvbXBvbmVudCBJbml0aWFsaXplZCcpLCAnaW5mbycpCiAgICAgICAgCiAgICAgICAgLy8g6K6w5b2V5b2T5YmN5pyd5ZCR5p6B54K5CiAgICAgICAgY29uc3QgZmFjaW5nUG9sZSA9IHRoaXMuY2FsY3VsYXRlRmFjaW5nUG9sZSgpCiAgICAgICAgY29uc3QgbGF0ID0gdGhpcy4kc3RvcmU/LnN0YXRlPy5jdXJyZW50TG9jYXRpb24/LmxhdCB8fCAndW5rbm93bicKICAgICAgICB0aGlzLmFkZExvZyh0aGlzLiR0KCdGYWNpbmcgUG9sZScsIFtmYWNpbmdQb2xlLCBsYXRdKSwgJ2luZm8nKQogICAgICB9LAoKICAgICAgY2xlYW51cCgpIHsKICAgICAgICB0aGlzLmFkZExvZyh0aGlzLiR0KCdQb2xhciBBbGlnbm1lbnQgQ29tcG9uZW50IENsZWFuZWQnKSwgJ2luZm8nKQogICAgICB9LAoKICAgICAgLy8g5YaF5a2Y5L2/55So55uR5o6n77yI5LuF5Zyo5byA5Y+R546v5aKD77yJCiAgICAgIGdldE1lbW9yeVVzYWdlKCkgewogICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50JyAmJiBwZXJmb3JtYW5jZS5tZW1vcnkpIHsKICAgICAgICAgIHJldHVybiB7CiAgICAgICAgICAgIHVzZWRKU0hlYXBTaXplOiBNYXRoLnJvdW5kKHBlcmZvcm1hbmNlLm1lbW9yeS51c2VkSlNIZWFwU2l6ZSAvIDEwMjQgLyAxMDI0KSArICdNQicsCiAgICAgICAgICAgIHRvdGFsSlNIZWFwU2l6ZTogTWF0aC5yb3VuZChwZXJmb3JtYW5jZS5tZW1vcnkudG90YWxKU0hlYXBTaXplIC8gMTAyNCAvIDEwMjQpICsgJ01CJywKICAgICAgICAgICAganNIZWFwU2l6ZUxpbWl0OiBNYXRoLnJvdW5kKHBlcmZvcm1hbmNlLm1lbW9yeS5qc0hlYXBTaXplTGltaXQgLyAxMDI0IC8gMTAyNCkgKyAnTUInLAogICAgICAgICAgICBsb2dzQ291bnQ6IHRoaXMubG9ncy5sZW5ndGgsCiAgICAgICAgICAgIGNhbGlicmF0aW9uUG9pbnRzQ291bnQ6IHRoaXMuY2FsaWJyYXRpb25Qb2ludHMubGVuZ3RoCiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIHJldHVybiBudWxsCiAgICAgIH0sCgogICAgICAvLyDlkK/liqjlrprmnJ/lhoXlrZjmuIXnkIYKICAgICAgc3RhcnRNZW1vcnlDbGVhbnVwKCkgewogICAgICAgIHRoaXMubWVtb3J5Q2xlYW51cFRpbWVyID0gc2V0SW50ZXJ2YWwoKCkgPT4gewogICAgICAgICAgdGhpcy5wZXJmb3JtTWVtb3J5Q2xlYW51cCgpCiAgICAgICAgfSwgNSAqIDYwICogMTAwMCkgLy8g5q+PNeWIhumSn+a4heeQhuS4gOasoQogICAgICB9LAoKICAgICAgLy8g5YGc5q2i5YaF5a2Y5riF55CG5a6a5pe25ZmoCiAgICAgIHN0b3BNZW1vcnlDbGVhbnVwKCkgewogICAgICAgIGlmICh0aGlzLm1lbW9yeUNsZWFudXBUaW1lcikgewogICAgICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLm1lbW9yeUNsZWFudXBUaW1lcikKICAgICAgICAgIHRoaXMubWVtb3J5Q2xlYW51cFRpbWVyID0gbnVsbAogICAgICAgIH0KICAgICAgfSwKCiAgICAgIC8vIOaJp+ihjOWGheWtmOa4heeQhgogICAgICBwZXJmb3JtTWVtb3J5Q2xlYW51cCgpIHsKICAgICAgICAvLyDmuIXnkIbov4fmnJ/nmoTml6Xlv5fvvIjkv53nlZnmnIDov5E1MOadoe+8iQogICAgICAgIGlmICh0aGlzLmxvZ3MubGVuZ3RoID4gNTApIHsKICAgICAgICAgIHRoaXMubG9ncyA9IHRoaXMubG9ncy5zbGljZSgtNTApCiAgICAgICAgICB0aGlzLmxvZ0luZGV4ID0gTWF0aC5taW4odGhpcy5sb2dJbmRleCwgNTApCiAgICAgICAgfQoKICAgICAgICAvLyDmuIXnkIbov4fmnJ/nmoTmoKHlh4bngrnvvIjlpoLmnpzotoXov4fmnIDlpKfmlbDph4/vvIkKICAgICAgICBpZiAodGhpcy5jYWxpYnJhdGlvblBvaW50cy5sZW5ndGggPiB0aGlzLm1heENhbGlicmF0aW9uUG9pbnRzKSB7CiAgICAgICAgICB0aGlzLmNhbGlicmF0aW9uUG9pbnRzID0gdGhpcy5jYWxpYnJhdGlvblBvaW50cy5zbGljZSgtdGhpcy5tYXhDYWxpYnJhdGlvblBvaW50cykKICAgICAgICB9CgogICAgICAgIC8vIOW8uuWItuWeg+WcvuWbnuaUtu+8iOWmguaenOWPr+eUqO+8iQogICAgICAgIGlmICh3aW5kb3cuZ2MgJiYgdHlwZW9mIHdpbmRvdy5nYyA9PT0gJ2Z1bmN0aW9uJykgewogICAgICAgICAgd2luZG93LmdjKCkKICAgICAgICB9CgogICAgICAgIC8vIOWcqOW8gOWPkeeOr+Wig+i+k+WHuuWGheWtmOS9v+eUqOaDheWGtQogICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50JykgewogICAgICAgICAgY29uc3QgbWVtb3J5SW5mbyA9IHRoaXMuZ2V0TWVtb3J5VXNhZ2UoKQogICAgICAgICAgaWYgKG1lbW9yeUluZm8pIHsKICAgICAgICAgICAgY29uc29sZS5sb2coJ01lbW9yeSBjbGVhbnVwIHBlcmZvcm1lZDonLCBtZW1vcnlJbmZvKQogICAgICAgICAgfQogICAgICAgIH0KICAgICAgfSwKCiAgICAgIC8vIOa4heeQhuaLluWKqOS6i+S7tuebkeWQrOWZqAogICAgICBjbGVhbnVwRHJhZ0xpc3RlbmVycygpIHsKICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzLm9uRHJhZykKICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgdGhpcy5zdG9wRHJhZykKICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCB0aGlzLm9uRHJhZykKICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIHRoaXMuc3RvcERyYWcpCiAgICAgIH0sCgogICAgICAvLyDmuIXnkIbpmLLmipblrprml7blmagKICAgICAgY2xlYXJEZWJvdW5jZVRpbWVycygpIHsKICAgICAgICBpZiAodGhpcy5fYXppbXV0aFVwZGF0ZVRpbWVyKSB7CiAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5fYXppbXV0aFVwZGF0ZVRpbWVyKQogICAgICAgICAgdGhpcy5fYXppbXV0aFVwZGF0ZVRpbWVyID0gbnVsbAogICAgICAgIH0KICAgICAgICBpZiAodGhpcy5fYWx0aXR1ZGVVcGRhdGVUaW1lcikgewogICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX2FsdGl0dWRlVXBkYXRlVGltZXIpCiAgICAgICAgICB0aGlzLl9hbHRpdHVkZVVwZGF0ZVRpbWVyID0gbnVsbAogICAgICAgIH0KICAgICAgfSwKCiAgICAgIC8vIOa4heeQhue8k+WtmOaVsOaNrgogICAgICBjbGVhckNhY2hlZERhdGEoKSB7CiAgICAgICAgLy8g5riF55CG6K6h566X57yT5a2YCiAgICAgICAgdGhpcy5jYWNoZWRBemltdXRoQXJjbWluID0gbnVsbAogICAgICAgIHRoaXMuY2FjaGVkQWx0aXR1ZGVBcmNtaW4gPSBudWxsCiAgICAgICAgdGhpcy5sYXN0QXppbXV0aFZhbHVlID0gbnVsbAogICAgICAgIHRoaXMubGFzdEFsdGl0dWRlVmFsdWUgPSBudWxsCiAgICAgICAgdGhpcy5sYXN0RHJhZ1RpbWUgPSAwCiAgICAgICAgCiAgICAgICAgLy8g5riF55CG5pel5b+X5pWw5o2uCiAgICAgICAgdGhpcy5sb2dzID0gW10KICAgICAgICB0aGlzLmxvZ0luZGV4ID0gMAogICAgICAgIAogICAgICAgIC8vIOa4heeQhuagoeWHhuaVsOaNrgogICAgICAgIHRoaXMuY2FsaWJyYXRpb25Qb2ludHMgPSBbXQogICAgICAgIHRoaXMudGFyZ2V0UG9pbnQgPSBudWxsCiAgICAgICAgdGhpcy5maWVsZERhdGEgPSBudWxsCiAgICAgICAgCiAgICAgICAgLy8g5riF55CG5L2N572u5pWw5o2uCiAgICAgICAgdGhpcy5jdXJyZW50UG9zaXRpb24gPSB7IHJhOiAnMDBoIDAwbSAwMHMnLCBkZWM6ICcrMDDCsCAwMFwnIDAwIicgfQogICAgICAgIHRoaXMudGFyZ2V0UG9zaXRpb24gPSB7IHJhOiAnMDBoIDAwbSAwMHMnLCBkZWM6ICcrMDDCsCAwMFwnIDAwIicgfQogICAgICAgIHRoaXMucHJldmlvdXNQb3NpdGlvbiA9IHsgcmE6ICcwMGggMDBtIDAwcycsIGRlYzogJyswMMKwIDAwXCcgMDAiJyB9CiAgICAgICAgCiAgICAgICAgLy8g5riF55CG6LCD5pW05pWw5o2uCiAgICAgICAgdGhpcy5hZGp1c3RtZW50ID0geyBhemltdXRoOiAwLjAsIGFsdGl0dWRlOiAwLjAgfQogICAgICAgIHRoaXMucG9sYXJBeGlzT2Zmc2V0ID0geyBhemltdXRoOiAwLCBhbHRpdHVkZTogMCB9CiAgICAgICAgCiAgICAgICAgLy8g6YeN572u54q25oCBCiAgICAgICAgdGhpcy5pc0NhbGlicmF0aW9uQ29tcGxldGUgPSBmYWxzZQogICAgICAgIHRoaXMuaXNQb2xhckFsaWduZWQgPSBmYWxzZQogICAgICAgIHRoaXMuY2FsaWJyYXRpb25Mb29wQ291bnQgPSAwCiAgICAgICAgdGhpcy5sYXN0Q2FsaWJyYXRpb25Qcm9ncmVzcyA9IDAKICAgICAgICB0aGlzLmNhbGlicmF0aW9uUGhhc2UgPSAnaW5pdGlhbCcKICAgICAgfSwKCiAgICAgIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0KICAgICAgLy8g5ouW5Yqo5o6n5Yi25pa55rOVCiAgICAgIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0KICAgICAgc3RhcnREcmFnKGV2ZW50KSB7CiAgICAgICAgaWYgKGV2ZW50LnRhcmdldC5jbG9zZXN0KCcuaGVhZGVyLWNvbnRyb2xzLCAubWluaW1pemVkLWNvbnRyb2xzLCAuaGVhZGVyLWJ0biwgLm1pbmltaXplZC1idG4nKSkgewogICAgICAgICAgcmV0dXJuCiAgICAgICAgfQoKICAgICAgICB0aGlzLmlzRHJhZ2dpbmcgPSB0cnVlCiAgICAgICAgdGhpcy5pc0RyYWdnaW5nU3RhdGUgPSB0cnVlCgogICAgICAgIC8vIOa3u+WKoGRyYWdnaW5n57G777yM56e76Zmk6L+H5rih5Yqo55S7CiAgICAgICAgdGhpcy4kZWwuY2xhc3NMaXN0LmFkZCgnZHJhZ2dpbmcnKQoKICAgICAgICBjb25zdCByZWN0ID0gZXZlbnQuY3VycmVudFRhcmdldC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKQogICAgICAgIGNvbnN0IGNsaWVudFggPSBldmVudC5jbGllbnRYIHx8IGV2ZW50LnRvdWNoZXM/LlswXT8uY2xpZW50WCB8fCAwCiAgICAgICAgY29uc3QgY2xpZW50WSA9IGV2ZW50LmNsaWVudFkgfHwgZXZlbnQudG91Y2hlcz8uWzBdPy5jbGllbnRZIHx8IDAKCiAgICAgICAgdGhpcy5kcmFnT2Zmc2V0ID0gewogICAgICAgICAgeDogY2xpZW50WCAtIHJlY3QubGVmdCwKICAgICAgICAgIHk6IGNsaWVudFkgLSByZWN0LnRvcAogICAgICAgIH0KCiAgICAgICAgLy8g6aKE6K6h566X5bm257yT5a2Y5bC65a+477yM6YG/5YWN5ouW5Yqo5pe26YeN5aSN6K6h566XCiAgICAgICAgdGhpcy51cGRhdGVDYWNoZWREaW1lbnNpb25zKCkKCiAgICAgICAgLy8g5LyY5YyW6Kem5pG45LqL5Lu25aSE55CGCiAgICAgICAgaWYgKGV2ZW50LnR5cGUgPT09ICd0b3VjaHN0YXJ0JykgewogICAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgdGhpcy5vbkRyYWcsIHsgcGFzc2l2ZTogZmFsc2UgfSkKICAgICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgdGhpcy5zdG9wRHJhZywgeyBwYXNzaXZlOiBmYWxzZSB9KQogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzLm9uRHJhZykKICAgICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzLnN0b3BEcmFnKQogICAgICAgIH0KICAgICAgfSwKCiAgICAgIG9uRHJhZyhldmVudCkgewogICAgICAgIGlmICghdGhpcy5pc0RyYWdnaW5nKSByZXR1cm4KCiAgICAgICAgLy8g6Zi75q2i6buY6K6k6KGM5Li677yM5o+Q6auY6Kem5pG45ZON5bqU5oCnCiAgICAgICAgaWYgKGV2ZW50LnR5cGUgPT09ICd0b3VjaG1vdmUnKSB7CiAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpCiAgICAgICAgfQoKICAgICAgICAvLyDkvb/nlKjmm7Tpq5jmlYjnmoToioLmtYHmnLrliLYKICAgICAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpCiAgICAgICAgaWYgKHRoaXMubGFzdERyYWdUaW1lICYmIG5vdyAtIHRoaXMubGFzdERyYWdUaW1lIDwgMTYpIHJldHVybiAvLyA2MGZwc+mZkOWItgogICAgICAgIHRoaXMubGFzdERyYWdUaW1lID0gbm93CiAgICAgICAgCiAgICAgICAgY29uc3QgY2xpZW50WCA9IGV2ZW50LmNsaWVudFggfHwgZXZlbnQudG91Y2hlcz8uWzBdPy5jbGllbnRYIHx8IDAKICAgICAgICBjb25zdCBjbGllbnRZID0gZXZlbnQuY2xpZW50WSB8fCBldmVudC50b3VjaGVzPy5bMF0/LmNsaWVudFkgfHwgMAoKICAgICAgICBjb25zdCBuZXdYID0gY2xpZW50WCAtIHRoaXMuZHJhZ09mZnNldC54CiAgICAgICAgY29uc3QgbmV3WSA9IGNsaWVudFkgLSB0aGlzLmRyYWdPZmZzZXQueQoKICAgICAgICAvLyDkvb/nlKjnvJPlrZjnmoTlsLrlr7jvvIzpgb/lhY3ph43lpI3orqHnrpcKICAgICAgICBjb25zdCBtYXhYID0gd2luZG93LmlubmVyV2lkdGggLSB0aGlzLmNhY2hlZERpbWVuc2lvbnMud2lkdGgKICAgICAgICBjb25zdCBtYXhZID0gd2luZG93LmlubmVySGVpZ2h0IC0gdGhpcy5jYWNoZWREaW1lbnNpb25zLmhlaWdodAoKICAgICAgICB0aGlzLnBvc2l0aW9uID0gewogICAgICAgICAgeDogTWF0aC5tYXgoMCwgTWF0aC5taW4obmV3WCwgbWF4WCkpLAogICAgICAgICAgeTogTWF0aC5tYXgoMCwgTWF0aC5taW4obmV3WSwgbWF4WSkpCiAgICAgICAgfQogICAgICB9LAoKICAgICAgc3RvcERyYWcoKSB7CiAgICAgICAgdGhpcy5pc0RyYWdnaW5nID0gZmFsc2UKICAgICAgICB0aGlzLmlzRHJhZ2dpbmdTdGF0ZSA9IGZhbHNlCgogICAgICAgIC8vIOenu+mZpGRyYWdnaW5n57G777yM5oGi5aSN6L+H5rih5Yqo55S7CiAgICAgICAgdGhpcy4kZWwuY2xhc3NMaXN0LnJlbW92ZSgnZHJhZ2dpbmcnKQoKICAgICAgICAvLyDmuIXnkIbmiYDmnInkuovku7bnm5HlkKzlmagKICAgICAgICB0aGlzLmNsZWFudXBEcmFnTGlzdGVuZXJzKCkKICAgICAgfSwKCiAgICAgIC8vIOaWsOWinu+8muabtOaWsOe8k+WtmOeahOWwuuWvuOS/oeaBrwogICAgICB1cGRhdGVDYWNoZWREaW1lbnNpb25zKCkgewogICAgICAgIGlmICh0aGlzLmlzTWluaW1pemVkKSB7CiAgICAgICAgICB0aGlzLmNhY2hlZERpbWVuc2lvbnMgPSB7IC4uLkRJTUVOU0lPTlMuTUlOSU1JWkVEIH0KICAgICAgICB9IGVsc2UgaWYgKHRoaXMuaXNDb2xsYXBzZWQpIHsKICAgICAgICAgIHRoaXMuY2FjaGVkRGltZW5zaW9ucyA9IHsgLi4uRElNRU5TSU9OUy5DT0xMQVBTRUQgfQogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAvLyDlsZXlvIDnirbmgIHvvIzkvb/nlKjln7rnoYDlsLrlr7gKICAgICAgICAgIHRoaXMuY2FjaGVkRGltZW5zaW9ucyA9IHsgLi4uRElNRU5TSU9OUy5FWFBBTkRFRCB9CiAgICAgICAgfQogICAgICB9LAoKICAgICAgLy8g6I635Y+W57uE5Lu26auY5bqm77yI5LyY5YyW54mI5pys77yJCiAgICAgIGdldENvbXBvbmVudEhlaWdodCgpIHsKICAgICAgICAvLyDlpoLmnpzmraPlnKjmi5bliqjvvIzkvb/nlKjnvJPlrZjnmoTlsLrlr7gKICAgICAgICBpZiAodGhpcy5pc0RyYWdnaW5nU3RhdGUpIHsKICAgICAgICAgIHJldHVybiB0aGlzLmNhY2hlZERpbWVuc2lvbnMuaGVpZ2h0CiAgICAgICAgfQoKICAgICAgICAvLyDmraPluLjnirbmgIHkuIvnmoTorqHnrpcKICAgICAgICBpZiAodGhpcy5pc01pbmltaXplZCkgewogICAgICAgICAgcmV0dXJuIDgwIC8vIOacgOWwj+WMlueKtuaAgemrmOW6pgogICAgICAgIH0gZWxzZSBpZiAodGhpcy5pc0NvbGxhcHNlZCkgewogICAgICAgICAgcmV0dXJuIDEyMCAvLyDmlLbnvKnnirbmgIHpq5jluqYKICAgICAgICB9IGVsc2UgewogICAgICAgICAgLy8g5bGV5byA54q25oCB77yM5qC55o2u5YaF5a656Ieq6YCC5bqUCiAgICAgICAgICBjb25zdCBiYXNlSGVpZ2h0ID0gNDAwIC8vIOWfuuehgOmrmOW6pgogICAgICAgICAgY29uc3QgbG9nSGVpZ2h0ID0gdGhpcy5kaXNwbGF5TG9ncy5sZW5ndGggPiAwID8gNjAgOiA0MAogICAgICAgICAgY29uc3QgYWRqdXN0bWVudEhlaWdodCA9IHRoaXMubmVlZHNBemltdXRoQWRqdXN0bWVudCB8fCB0aGlzLm5lZWRzQWx0aXR1ZGVBZGp1c3RtZW50ID8gMTIwIDogODAKICAgICAgICAgIHJldHVybiBNYXRoLm1pbihiYXNlSGVpZ2h0ICsgbG9nSGVpZ2h0ICsgYWRqdXN0bWVudEhlaWdodCwgd2luZG93LmlubmVySGVpZ2h0ICogMC44KQogICAgICAgIH0KICAgICAgfSwKCiAgICAgIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0KICAgICAgLy8g55WM6Z2i54q25oCB5o6n5Yi25pa55rOVCiAgICAgIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0KICAgICAgdG9nZ2xlTWluaW1pemUoKSB7CiAgICAgICAgdGhpcy5pc01pbmltaXplZCA9ICF0aGlzLmlzTWluaW1pemVkCiAgICAgICAgdGhpcy5pc0NvbGxhcHNlZCA9IGZhbHNlCiAgICAgICAgLy8g5pu05paw57yT5a2Y55qE5bC65a+45L+h5oGvCiAgICAgICAgdGhpcy51cGRhdGVDYWNoZWREaW1lbnNpb25zKCkKICAgICAgICB0aGlzLmFkZExvZyh0aGlzLmlzTWluaW1pemVkID8gdGhpcy4kdCgnSW50ZXJmYWNlIE1pbmltaXplZCcpIDogdGhpcy4kdCgnSW50ZXJmYWNlIEV4cGFuZGVkJyksICdpbmZvJykKICAgICAgfSwKCiAgICAgIHRvZ2dsZUNvbGxhcHNlKCkgewogICAgICAgIHRoaXMuaXNDb2xsYXBzZWQgPSAhdGhpcy5pc0NvbGxhcHNlZAogICAgICAgIC8vIOabtOaWsOe8k+WtmOeahOWwuuWvuOS/oeaBrwogICAgICAgIHRoaXMudXBkYXRlQ2FjaGVkRGltZW5zaW9ucygpCiAgICAgICAgdGhpcy5hZGRMb2codGhpcy5pc0NvbGxhcHNlZCA/IHRoaXMuJHQoJ0ludGVyZmFjZSBDb2xsYXBzZWQnKSA6IHRoaXMuJHQoJ0ludGVyZmFjZSBFeHBhbmRlZCcpLCAnaW5mbycpCiAgICAgIH0sCgogICAgICAvLyA9PT0g6L2o6L+555S75biD55u45YWzID09PQogICAgICB0b2dnbGVUcmFqZWN0b3J5T3ZlcmxheSgpIHsKICAgICAgICB0aGlzLnNob3dUcmFqZWN0b3J5T3ZlcmxheSA9ICF0aGlzLnNob3dUcmFqZWN0b3J5T3ZlcmxheQogICAgICAgIGlmICh0aGlzLnNob3dUcmFqZWN0b3J5T3ZlcmxheSkgewogICAgICAgICAgaWYgKHRoaXMub3ZlcmxheU1vZGUgPT09ICdmdWxsc2NyZWVuJykgdGhpcy5lbmFibGVPdmVybGF5RXZlbnRDYXB0dXJlKCk7IGVsc2UgdGhpcy5kaXNhYmxlT3ZlcmxheUV2ZW50Q2FwdHVyZSgpCiAgICAgICAgICB0aGlzLiRuZXh0VGljaygoKSA9PiB7CiAgICAgICAgICAgIHRoaXMuaW5pdFRyYWplY3RvcnlDYW52YXMoKQogICAgICAgICAgICB0aGlzLnJlZHJhd1RyYWplY3RvcnkoKQogICAgICAgICAgfSkKICAgICAgICB9IGVsc2UgewogICAgICAgICAgdGhpcy5kaXNhYmxlT3ZlcmxheUV2ZW50Q2FwdHVyZSgpCiAgICAgICAgfQogICAgICB9LAogICAgICBzd2l0Y2hUb1dpbmRvd2VkKCkgewogICAgICAgIHRoaXMub3ZlcmxheU1vZGUgPSAnd2luZG93ZWQnCiAgICAgICAgdGhpcy5kaXNhYmxlT3ZlcmxheUV2ZW50Q2FwdHVyZSgpCiAgICAgICAgdGhpcy5yZXNldFZpZXdNYXBwaW5nKCkKICAgICAgICB0aGlzLiRuZXh0VGljaygoKSA9PiB7CiAgICAgICAgICB0aGlzLmluaXRUcmFqZWN0b3J5Q2FudmFzKCkKICAgICAgICAgIHRoaXMucmVkcmF3VHJhamVjdG9yeSgpCiAgICAgICAgfSkKICAgICAgfSwKICAgICAgc3dpdGNoVG9GdWxsc2NyZWVuKCkgewogICAgICAgIHRoaXMub3ZlcmxheU1vZGUgPSAnZnVsbHNjcmVlbicKICAgICAgICB0aGlzLmVuYWJsZU92ZXJsYXlFdmVudENhcHR1cmUoKQogICAgICAgIHRoaXMucmVzZXRWaWV3TWFwcGluZygpCiAgICAgICAgdGhpcy5jbGVhclRyYWplY3RvcnlDYW52YXMoKQogICAgICAgIHRoaXMuJG5leHRUaWNrKCgpID0+IHsKICAgICAgICAgIHRoaXMuaW5pdFRyYWplY3RvcnlDYW52YXMoKQogICAgICAgICAgdGhpcy5yZWRyYXdUcmFqZWN0b3J5KCkKICAgICAgICB9KQogICAgICB9LAogICAgICBvbk92ZXJsYXlXaGVlbChlKSB7CiAgICAgICAgLy8g5bey5Y+W5raI5YWo5bGP57yp5pS+6ZyA5rGC77ya5b+955Wl5rua6L2u77yM5LuF6Ziy5q2i56m/6YCPCiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpCiAgICAgIH0sCiAgICAgIHJlc2V0Vmlld01hcHBpbmcoKSB7CiAgICAgICAgdGhpcy5jdXJyZW50UHhQZXJEZWcgPSBudWxsCiAgICAgICAgdGhpcy52aWV3TWluV29ybGRYID0gbnVsbAogICAgICAgIHRoaXMudmlld01heFdvcmxkWCA9IG51bGwKICAgICAgICB0aGlzLnZpZXdNaW5Xb3JsZFkgPSBudWxsCiAgICAgICAgdGhpcy52aWV3TWF4V29ybGRZID0gbnVsbAogICAgICAgIHRoaXMucmFVbndyYXBBbmNob3IgPSBudWxsCiAgICAgICAgdGhpcy52aWV3T2Zmc2V0WFB4ID0gMAogICAgICAgIHRoaXMudmlld09mZnNldFlQeCA9IDAKICAgICAgfSwKICAgICAgLy8g5riF56m66KeG5Zu+5pig5bCE77yM5L2G5L+d55WZIFJBIOWxleW8gOmUmueCue+8jOmYsuatoua4heeQhuaXp+eCueaIluaooeW8j+WIh+aNouaXtuaWueWQkee/u+i9rAogICAgICByZXNldFZpZXdNYXBwaW5nS2VlcEFuY2hvcigpIHsKICAgICAgICBjb25zdCBhbmNob3IgPSB0aGlzLnJhVW53cmFwQW5jaG9yCiAgICAgICAgdGhpcy5jdXJyZW50UHhQZXJEZWcgPSBudWxsCiAgICAgICAgdGhpcy52aWV3TWluV29ybGRYID0gbnVsbAogICAgICAgIHRoaXMudmlld01heFdvcmxkWCA9IG51bGwKICAgICAgICB0aGlzLnZpZXdNaW5Xb3JsZFkgPSBudWxsCiAgICAgICAgdGhpcy52aWV3TWF4V29ybGRZID0gbnVsbAogICAgICAgIHRoaXMudmlld09mZnNldFhQeCA9IDAKICAgICAgICB0aGlzLnZpZXdPZmZzZXRZUHggPSAwCiAgICAgICAgdGhpcy5yYVVud3JhcEFuY2hvciA9IGFuY2hvcgogICAgICB9LAogICAgICBzdGFydFdpbmRvd0RyYWcoZXZlbnQpIHsKICAgICAgICBjb25zdCBlID0gZXZlbnQudG91Y2hlcyA/IGV2ZW50LnRvdWNoZXNbMF0gOiBldmVudAogICAgICAgIHRoaXMud2luZG93RHJhZy5hY3RpdmUgPSB0cnVlCiAgICAgICAgdGhpcy53aW5kb3dEcmFnLm9mZnNldFggPSBlLmNsaWVudFggLSB0aGlzLndpbmRvd2VkUmVjdC54CiAgICAgICAgdGhpcy53aW5kb3dEcmFnLm9mZnNldFkgPSBlLmNsaWVudFkgLSB0aGlzLndpbmRvd2VkUmVjdC55CiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXMub25XaW5kb3dEcmFnTW92ZSwgeyBwYXNzaXZlOiBmYWxzZSB9KQogICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgdGhpcy5zdG9wV2luZG93RHJhZywgeyBwYXNzaXZlOiBmYWxzZSB9KQogICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCB0aGlzLm9uV2luZG93RHJhZ01vdmUsIHsgcGFzc2l2ZTogZmFsc2UgfSkKICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCB0aGlzLnN0b3BXaW5kb3dEcmFnLCB7IHBhc3NpdmU6IGZhbHNlIH0pCiAgICAgIH0sCiAgICAgIG9uV2luZG93RHJhZ01vdmUoZXZlbnQpIHsKICAgICAgICBpZiAoIXRoaXMud2luZG93RHJhZy5hY3RpdmUpIHJldHVybgogICAgICAgIGNvbnN0IGUgPSBldmVudC50b3VjaGVzID8gZXZlbnQudG91Y2hlc1swXSA6IGV2ZW50CiAgICAgICAgY29uc3QgbnggPSBlLmNsaWVudFggLSB0aGlzLndpbmRvd0RyYWcub2Zmc2V0WAogICAgICAgIGNvbnN0IG55ID0gZS5jbGllbnRZIC0gdGhpcy53aW5kb3dEcmFnLm9mZnNldFkKICAgICAgICB0aGlzLndpbmRvd2VkUmVjdC54ID0gTWF0aC5tYXgoMCwgTWF0aC5taW4obngsIHdpbmRvdy5pbm5lcldpZHRoIC0gdGhpcy53aW5kb3dlZFJlY3Qud2lkdGgpKQogICAgICAgIHRoaXMud2luZG93ZWRSZWN0LnkgPSBNYXRoLm1heCgwLCBNYXRoLm1pbihueSwgd2luZG93LmlubmVySGVpZ2h0IC0gdGhpcy53aW5kb3dlZFJlY3QuaGVpZ2h0KSkKICAgICAgfSwKICAgICAgc3RvcFdpbmRvd0RyYWcoKSB7CiAgICAgICAgdGhpcy53aW5kb3dEcmFnLmFjdGl2ZSA9IGZhbHNlCiAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXMub25XaW5kb3dEcmFnTW92ZSkKICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXMuc3RvcFdpbmRvd0RyYWcpCiAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIHRoaXMub25XaW5kb3dEcmFnTW92ZSkKICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCB0aGlzLnN0b3BXaW5kb3dEcmFnKQogICAgICB9LAogICAgICBlbmFibGVPdmVybGF5RXZlbnRDYXB0dXJlKCkgewogICAgICAgIC8vIOaLpuaIquWFqOWxgOa7mui9ri/op6bmkbgv6byg5qCH5LqL5Lu277yM6YG/5YWN56m/6YCP5Yiw5bqV5Zu+CiAgICAgICAgY29uc3QgcHJldmVudEFsbCA9IGUgPT4geyBlLnByZXZlbnREZWZhdWx0KCk7IGUuc3RvcFByb3BhZ2F0aW9uKCk7IH0KICAgICAgICB0aGlzLl9vdmVybGF5SGFuZGxlcnMgPSB0aGlzLl9vdmVybGF5SGFuZGxlcnMgfHwge30KICAgICAgICB0aGlzLl9vdmVybGF5SGFuZGxlcnMud2hlZWwgPSBwcmV2ZW50QWxsCiAgICAgICAgdGhpcy5fb3ZlcmxheUhhbmRsZXJzLnRvdWNobW92ZSA9IHByZXZlbnRBbGwKICAgICAgICB0aGlzLl9vdmVybGF5SGFuZGxlcnMubW91c2Vkb3duID0gcHJldmVudEFsbAogICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCd3aGVlbCcsIHRoaXMuX292ZXJsYXlIYW5kbGVycy53aGVlbCwgeyBwYXNzaXZlOiBmYWxzZSwgY2FwdHVyZTogdHJ1ZSB9KQogICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCB0aGlzLl9vdmVybGF5SGFuZGxlcnMudG91Y2htb3ZlLCB7IHBhc3NpdmU6IGZhbHNlLCBjYXB0dXJlOiB0cnVlIH0pCiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMuX292ZXJsYXlIYW5kbGVycy5tb3VzZWRvd24sIHsgcGFzc2l2ZTogZmFsc2UsIGNhcHR1cmU6IHRydWUgfSkKICAgICAgfSwKICAgICAgZGlzYWJsZU92ZXJsYXlFdmVudENhcHR1cmUoKSB7CiAgICAgICAgaWYgKCF0aGlzLl9vdmVybGF5SGFuZGxlcnMpIHJldHVybgogICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCd3aGVlbCcsIHRoaXMuX292ZXJsYXlIYW5kbGVycy53aGVlbCwgeyBjYXB0dXJlOiB0cnVlIH0pCiAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIHRoaXMuX292ZXJsYXlIYW5kbGVycy50b3VjaG1vdmUsIHsgY2FwdHVyZTogdHJ1ZSB9KQogICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLl9vdmVybGF5SGFuZGxlcnMubW91c2Vkb3duLCB7IGNhcHR1cmU6IHRydWUgfSkKICAgICAgICB0aGlzLl9vdmVybGF5SGFuZGxlcnMgPSBudWxsCiAgICAgIH0sCiAgICAgIGNsZWFyQWxsVHJhamVjdG9yeSgpIHsKICAgICAgICB0aGlzLnJhd1RyYWplY3RvcnlQb2ludHMgPSBbXQogICAgICAgIHRoaXMudHJhamVjdG9yeVBvaW50cyA9IFtdCiAgICAgICAgdGhpcy5sYXN0UmF3UG9zaXRpb24gPSBudWxsCiAgICAgICAgdGhpcy5yZXNldFZpZXdNYXBwaW5nKCkKICAgICAgICB0aGlzLnJlZHJhd1RyYWplY3RvcnkoKQogICAgICB9LAogICAgICBjbGVhck9sZFRyYWplY3RvcnkoKSB7CiAgICAgICAgaWYgKHRoaXMucmF3VHJhamVjdG9yeVBvaW50cy5sZW5ndGggPD0gMikgcmV0dXJuCiAgICAgICAgdGhpcy5yYXdUcmFqZWN0b3J5UG9pbnRzID0gdGhpcy5yYXdUcmFqZWN0b3J5UG9pbnRzLnNsaWNlKC0yKQogICAgICAgIHRoaXMudHJhamVjdG9yeVBvaW50cyA9IFtdCiAgICAgICAgdGhpcy5yZXNldFZpZXdNYXBwaW5nS2VlcEFuY2hvcigpCiAgICAgICAgdGhpcy5yZWRyYXdUcmFqZWN0b3J5KCkKICAgICAgfSwKICAgICAgaW5pdFRyYWplY3RvcnlDYW52YXMoKSB7CiAgICAgICAgY29uc3QgY2FudmFzID0gdGhpcy4kcmVmcy50cmFqZWN0b3J5Q2FudmFzCiAgICAgICAgaWYgKCFjYW52YXMpIHJldHVybgogICAgICAgIGNvbnN0IGRwciA9IHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIHx8IDEKICAgICAgICBsZXQgdywgaCwgc2NhbGVYID0gMSwgc2NhbGVZID0gMQogICAgICAgIGlmICh0aGlzLm92ZXJsYXlNb2RlID09PSAnZnVsbHNjcmVlbicpIHsKICAgICAgICAgIHcgPSB3aW5kb3cuaW5uZXJXaWR0aAogICAgICAgICAgaCA9IHdpbmRvdy5pbm5lckhlaWdodAogICAgICAgICAgY2FudmFzLndpZHRoID0gTWF0aC5yb3VuZCh3ICogZHByKQogICAgICAgICAgY2FudmFzLmhlaWdodCA9IE1hdGgucm91bmQoaCAqIGRwcikKICAgICAgICAgIGNhbnZhcy5zdHlsZS53aWR0aCA9IHcgKyAncHgnCiAgICAgICAgICBjYW52YXMuc3R5bGUuaGVpZ2h0ID0gaCArICdweCcKICAgICAgICB9IGVsc2UgewogICAgICAgICAgLy8g56qX5Y+j5qih5byP77ya5L2/55So6YC76L6R55S75biD5bC65a+477yM57uY5Yi25ZCO5pW05L2T57yp5pS+5Yiw56qX5Y+j5Yy65Z+fCiAgICAgICAgICBjb25zdCBIRUFERVIgPSAzMgogICAgICAgICAgY29uc3QgdncgPSBNYXRoLm1heCg1MCwgTWF0aC5yb3VuZCh0aGlzLndpbmRvd2VkUmVjdC53aWR0aCkpCiAgICAgICAgICBjb25zdCB2aCA9IE1hdGgubWF4KDUwLCBNYXRoLnJvdW5kKHRoaXMud2luZG93ZWRSZWN0LmhlaWdodCAtIEhFQURFUikpCiAgICAgICAgICBjb25zdCBsdyA9IHRoaXMuYmFzZUNhbnZhc0xvZ2ljYWxTaXplLndpZHRoCiAgICAgICAgICBjb25zdCBsaCA9IHRoaXMuYmFzZUNhbnZhc0xvZ2ljYWxTaXplLmhlaWdodAogICAgICAgICAgLy8g6K6h566X5bCG6YC76L6R55S75biD57yp5pS+5Yiw5Y+v6KeG56qX5Y+j55qE57yp5pS+5q+UCiAgICAgICAgICBzY2FsZVggPSB2dyAvIGx3CiAgICAgICAgICBzY2FsZVkgPSB2aCAvIGxoCiAgICAgICAgICAvLyBDYW52YXMg5pi+56S65bC65a+4ID0g56qX5Y+j5bC65a+477yM5YaF6YOo5YOP57SgID0g5pi+56S65bC65a+4ICogRFBSCiAgICAgICAgICB3ID0gdncKICAgICAgICAgIGggPSB2aAogICAgICAgICAgY2FudmFzLnN0eWxlLndpZHRoID0gdncgKyAncHgnCiAgICAgICAgICBjYW52YXMuc3R5bGUuaGVpZ2h0ID0gdmggKyAncHgnCiAgICAgICAgICBjYW52YXMud2lkdGggPSBNYXRoLnJvdW5kKHZ3ICogZHByKQogICAgICAgICAgY2FudmFzLmhlaWdodCA9IE1hdGgucm91bmQodmggKiBkcHIpCiAgICAgICAgfQogICAgICAgIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpCiAgICAgICAgLy8g6K6+572u6K6+5aSH5YOP57Sg5q+U57yp5pS+CiAgICAgICAgY3R4LnNldFRyYW5zZm9ybShkcHIsIDAsIDAsIGRwciwgMCwgMCkKICAgICAgICAvLyDnqpflj6PmqKHlvI/kuIvlop7liqDmlbTkvZPnvKnmlL7vvIzlsIbpgLvovpHnlLvluIPnvKnmlL7liLDnqpflj6PlsLrlr7gKICAgICAgICBpZiAodGhpcy5vdmVybGF5TW9kZSA9PT0gJ3dpbmRvd2VkJykgewogICAgICAgICAgY3R4LnNjYWxlKHNjYWxlWCwgc2NhbGVZKQogICAgICAgIH0KICAgICAgICB0aGlzLmNsZWFyVHJhamVjdG9yeUNhbnZhcygpCiAgICAgICAgLy8g6IOM5pmv55SxIGRyYXdUYXJnZXRNYXJrZXIg57uf5LiA57uY5Yi2CiAgICAgIH0sCiAgICAgIGNsZWFyVHJhamVjdG9yeUNhbnZhcygpIHsKICAgICAgICBjb25zdCBjYW52YXMgPSB0aGlzLiRyZWZzLnRyYWplY3RvcnlDYW52YXMKICAgICAgICBpZiAoIWNhbnZhcykgcmV0dXJuCiAgICAgICAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJykKICAgICAgICBjdHguc2F2ZSgpCiAgICAgICAgY3R4LnNldFRyYW5zZm9ybSgxLCAwLCAwLCAxLCAwLCAwKQogICAgICAgIGN0eC5jbGVhclJlY3QoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KQogICAgICAgIGN0eC5yZXN0b3JlKCkKICAgICAgfSwKICAgICAgLy8gPT09IOinhuWbvuaYoOWwhOS4juW3peWFtyA9PT0KICAgICAgZ2V0Q2FudmFzR2VvbSgpIHsKICAgICAgICBjb25zdCBjYW52YXMgPSB0aGlzLiRyZWZzLnRyYWplY3RvcnlDYW52YXMKICAgICAgICBpZiAoIWNhbnZhcykgcmV0dXJuIG51bGwKICAgICAgICAvLyDlnKjnqpflj6PmqKHlvI/kuIvvvIxDYW52YXMg5YaF6YOo6YC76L6R5Li6IGJhc2VDYW52YXNMb2dpY2FsU2l6Ze+8jAogICAgICAgIC8vIOWklumDqOmAmui/hyBjdHguc2NhbGUg5pi+56S65Yiw56qX5Y+j77yM5omA5Lul5Yeg5L2V6K6h566X6L+U5Zue6YC76L6R5bC65a+4CiAgICAgICAgY29uc3QgdyA9IHRoaXMub3ZlcmxheU1vZGUgPT09ICd3aW5kb3dlZCcgPyB0aGlzLmJhc2VDYW52YXNMb2dpY2FsU2l6ZS53aWR0aCA6IGNhbnZhcy5jbGllbnRXaWR0aAogICAgICAgIGNvbnN0IGggPSB0aGlzLm92ZXJsYXlNb2RlID09PSAnd2luZG93ZWQnID8gdGhpcy5iYXNlQ2FudmFzTG9naWNhbFNpemUuaGVpZ2h0IDogY2FudmFzLmNsaWVudEhlaWdodAogICAgICAgIGNvbnN0IHBhZFggPSBNYXRoLnJvdW5kKHcgKiAodGhpcy52aWV3UGFkUmF0aW9YIHx8IDAuMTIpKQogICAgICAgIGNvbnN0IHBhZFkgPSBNYXRoLnJvdW5kKGggKiAodGhpcy52aWV3UGFkUmF0aW9ZIHx8IDAuMTApKQogICAgICAgIHJldHVybiB7IHcsIGgsIHBhZFgsIHBhZFkgfQogICAgICB9LAogICAgICB3b3JsZEZvclBvaW50KHJhRGVnLCBkZWNEZWcsIHRpbWVNc09yRGF0ZSA9IG51bGwpIHsKICAgICAgICAvLyDkvb/nlKjlnLDlubPlnZDmoIfvvIhBei9BbHTvvInnu5jliLbvvJrkuJbnlYzlnZDmoIfku6XigJznm67moIfngrnigJ3kuLrljp/ngrkKICAgICAgICBpZiAoIXRoaXMudGFyZ2V0UmF3UG9zaXRpb24pIHJldHVybiB7IHg6IDAsIHk6IDAgfQogICAgICAgIGNvbnN0IGxvYyA9IHRoaXMuJHN0b3JlPy5zdGF0ZT8uY3VycmVudExvY2F0aW9uIHx8IHt9CiAgICAgICAgY29uc3QgbGF0ID0gTnVtYmVyKGxvYy5sYXQpCiAgICAgICAgY29uc3QgbG9uID0gTnVtYmVyKGxvYy5sbmcpCiAgICAgICAgaWYgKCFOdW1iZXIuaXNGaW5pdGUobGF0KSB8fCAhTnVtYmVyLmlzRmluaXRlKGxvbikpIHJldHVybiB7IHg6IDAsIHk6IDAgfQogICAgICAgIGNvbnN0IHQgPSAodGltZU1zT3JEYXRlIGluc3RhbmNlb2YgRGF0ZSkgPyB0aW1lTXNPckRhdGUgOiBuZXcgRGF0ZSh0aW1lTXNPckRhdGUgfHwgRGF0ZS5ub3coKSkKICAgICAgICBjb25zdCBjdXIgPSB0aGlzLmVxdWF0b3JpYWxUb0hvcml6b250YWwocmFEZWcsIGRlY0RlZywgdCwgbGF0LCBsb24pCiAgICAgICAgY29uc3QgdGd0ID0gdGhpcy5lcXVhdG9yaWFsVG9Ib3Jpem9udGFsKHRoaXMudGFyZ2V0UmF3UG9zaXRpb24ucmEsIHRoaXMudGFyZ2V0UmF3UG9zaXRpb24uZGVjLCB0LCBsYXQsIGxvbikKICAgICAgICBsZXQgZHggPSB0aGlzLm5vcm1hbGl6ZUF6RGVsdGEoY3VyLmF6IC0gdGd0LmF6KSAvLyBkQXrvvIjogIPomZEgMC8zNjAg5YyF6KO577yJCiAgICAgICAgbGV0IGR5ID0gY3VyLmFsdCAtIHRndC5hbHQgICAgICAgICAgICAgICAgICAgIC8vIGRBbHQKICAgICAgICAvLyDkvb/nlKjln7rkuo7pppbngrnnmoTlsZXlvIDplJrngrnvvIzpgb/lhY3ot6ggMC8zNjAg6Lez5Y+YCiAgICAgICAgaWYgKHRoaXMucmFVbndyYXBBbmNob3IgIT0gbnVsbCkgewogICAgICAgICAgd2hpbGUgKGR4IC0gdGhpcy5yYVVud3JhcEFuY2hvciA+IDE4MCkgZHggLT0gMzYwCiAgICAgICAgICB3aGlsZSAoZHggLSB0aGlzLnJhVW53cmFwQW5jaG9yIDwgLTE4MCkgZHggKz0gMzYwCiAgICAgICAgfQogICAgICAgIHJldHVybiB7IHg6IGR4LCB5OiBkeSB9CiAgICAgIH0sCiAgICAgIG1ha2VXb3JsZFNlcShyYXdQb2ludHMpIHsKICAgICAgICBpZiAoIXRoaXMudGFyZ2V0UmF3UG9zaXRpb24gfHwgIXJhd1BvaW50cyB8fCByYXdQb2ludHMubGVuZ3RoID09PSAwKSByZXR1cm4gW10KICAgICAgICBjb25zdCBsb2MgPSB0aGlzLiRzdG9yZT8uc3RhdGU/LmN1cnJlbnRMb2NhdGlvbiB8fCB7fQogICAgICAgIGNvbnN0IGxhdCA9IE51bWJlcihsb2MubGF0KQogICAgICAgIGNvbnN0IGxvbiA9IE51bWJlcihsb2MubG5nKQogICAgICAgIGlmICghTnVtYmVyLmlzRmluaXRlKGxhdCkgfHwgIU51bWJlci5pc0Zpbml0ZShsb24pKSByZXR1cm4gW10KICAgICAgICBjb25zdCB0aW1lcyA9IHJhd1BvaW50cy5tYXAoKHAsIGlkeCkgPT4gewogICAgICAgICAgaWYgKHAudCkgcmV0dXJuIG5ldyBEYXRlKHAudCkKICAgICAgICAgIGlmIChpZHggPiAwICYmIHJhd1BvaW50c1tpZHggLSAxXS50KSByZXR1cm4gbmV3IERhdGUocmF3UG9pbnRzW2lkeCAtIDFdLnQpCiAgICAgICAgICByZXR1cm4gbmV3IERhdGUoKQogICAgICAgIH0pCiAgICAgICAgY29uc3QgdGFyZ0FsdEF6ID0gdGltZXMubWFwKHQgPT4gdGhpcy5lcXVhdG9yaWFsVG9Ib3Jpem9udGFsKHRoaXMudGFyZ2V0UmF3UG9zaXRpb24ucmEsIHRoaXMudGFyZ2V0UmF3UG9zaXRpb24uZGVjLCB0LCBsYXQsIGxvbikpCiAgICAgICAgY29uc3QgY3VyQWx0QXogPSByYXdQb2ludHMubWFwKChwLCBpKSA9PiB0aGlzLmVxdWF0b3JpYWxUb0hvcml6b250YWwocC5yYSwgcC5kZWMsIHRpbWVzW2ldLCBsYXQsIGxvbikpCiAgICAgICAgY29uc3QgZEF6Tm9ybSA9IGN1ckFsdEF6Lm1hcCgoYywgaSkgPT4gdGhpcy5ub3JtYWxpemVBekRlbHRhKGMuYXogLSB0YXJnQWx0QXpbaV0uYXopKQogICAgICAgIGxldCBhbmNob3IgPSB0aGlzLnJhVW53cmFwQW5jaG9yCiAgICAgICAgaWYgKGFuY2hvciA9PSBudWxsICYmIGRBek5vcm0ubGVuZ3RoID4gMCkgYW5jaG9yID0gZEF6Tm9ybVswXQogICAgICAgIGNvbnN0IGFsaWduZWQgPSBkQXpOb3JtLm1hcCh4ID0+IHsKICAgICAgICAgIGxldCB2ID0geAogICAgICAgICAgd2hpbGUgKHYgLSBhbmNob3IgPiAxODApIHYgLT0gMzYwCiAgICAgICAgICB3aGlsZSAodiAtIGFuY2hvciA8IC0xODApIHYgKz0gMzYwCiAgICAgICAgICByZXR1cm4gdgogICAgICAgIH0pCiAgICAgICAgY29uc3QgZEF6cyA9IHRoaXMudW53cmFwUmFEZWx0YVNlcXVlbmNlKGFsaWduZWQpCiAgICAgICAgcmV0dXJuIHJhd1BvaW50cy5tYXAoKHAsIGkpID0+ICh7IHg6IGRBenNbaV0sIHk6IGN1ckFsdEF6W2ldLmFsdCAtIHRhcmdBbHRBeltpXS5hbHQgfSkpCiAgICAgIH0sCiAgICAgIC8vIOWfuuS6juKAnOWFqOmHj+i9qOi/ueKAneeahOi/nue7reWxleW8gO+8jOi/lOWbnueUqOS6juWegue6v+eahOacgOWQjuS4pOeCueS4lueVjOWdkOagh++8iOWFgeiuuOi2heWHuuW4uOinhOiMg+WbtO+8iQogICAgICBnZXRXb3JsZEFCRm9yUGVycCgpIHsKICAgICAgICBpZiAoIXRoaXMudGFyZ2V0UmF3UG9zaXRpb24gfHwgdGhpcy5yYXdUcmFqZWN0b3J5UG9pbnRzLmxlbmd0aCA8IDIpIHJldHVybiBudWxsCiAgICAgICAgY29uc3QgbG9jID0gdGhpcy4kc3RvcmU/LnN0YXRlPy5jdXJyZW50TG9jYXRpb24gfHwge30KICAgICAgICBjb25zdCBsYXQgPSBOdW1iZXIobG9jLmxhdCkKICAgICAgICBjb25zdCBsb24gPSBOdW1iZXIobG9jLmxuZykKICAgICAgICBpZiAoIU51bWJlci5pc0Zpbml0ZShsYXQpIHx8ICFOdW1iZXIuaXNGaW5pdGUobG9uKSkgcmV0dXJuIG51bGwKICAgICAgICBjb25zdCBhbGwgPSB0aGlzLnJhd1RyYWplY3RvcnlQb2ludHMKICAgICAgICBjb25zdCB0QSA9IG5ldyBEYXRlKGFsbFthbGwubGVuZ3RoIC0gMl0udCB8fCBEYXRlLm5vdygpKQogICAgICAgIGNvbnN0IHRCID0gbmV3IERhdGUoYWxsW2FsbC5sZW5ndGggLSAxXS50IHx8IERhdGUubm93KCkpCiAgICAgICAgY29uc3QgdGd0QSA9IHRoaXMuZXF1YXRvcmlhbFRvSG9yaXpvbnRhbCh0aGlzLnRhcmdldFJhd1Bvc2l0aW9uLnJhLCB0aGlzLnRhcmdldFJhd1Bvc2l0aW9uLmRlYywgdEEsIGxhdCwgbG9uKQogICAgICAgIGNvbnN0IHRndEIgPSB0aGlzLmVxdWF0b3JpYWxUb0hvcml6b250YWwodGhpcy50YXJnZXRSYXdQb3NpdGlvbi5yYSwgdGhpcy50YXJnZXRSYXdQb3NpdGlvbi5kZWMsIHRCLCBsYXQsIGxvbikKICAgICAgICBjb25zdCBjdXJBID0gdGhpcy5lcXVhdG9yaWFsVG9Ib3Jpem9udGFsKGFsbFthbGwubGVuZ3RoIC0gMl0ucmEsIGFsbFthbGwubGVuZ3RoIC0gMl0uZGVjLCB0QSwgbGF0LCBsb24pCiAgICAgICAgY29uc3QgY3VyQiA9IHRoaXMuZXF1YXRvcmlhbFRvSG9yaXpvbnRhbChhbGxbYWxsLmxlbmd0aCAtIDFdLnJhLCBhbGxbYWxsLmxlbmd0aCAtIDFdLmRlYywgdEIsIGxhdCwgbG9uKQogICAgICAgIGxldCBkeEEgPSB0aGlzLm5vcm1hbGl6ZUF6RGVsdGEoY3VyQS5heiAtIHRndEEuYXopCiAgICAgICAgbGV0IGR4QiA9IHRoaXMubm9ybWFsaXplQXpEZWx0YShjdXJCLmF6IC0gdGd0Qi5heikKICAgICAgICBpZiAodGhpcy5yYVVud3JhcEFuY2hvciAhPSBudWxsKSB7CiAgICAgICAgICB3aGlsZSAoZHhBIC0gdGhpcy5yYVVud3JhcEFuY2hvciA+IDE4MCkgZHhBIC09IDM2MAogICAgICAgICAgd2hpbGUgKGR4QSAtIHRoaXMucmFVbndyYXBBbmNob3IgPCAtMTgwKSBkeEEgKz0gMzYwCiAgICAgICAgICB3aGlsZSAoZHhCIC0gdGhpcy5yYVVud3JhcEFuY2hvciA+IDE4MCkgZHhCIC09IDM2MAogICAgICAgICAgd2hpbGUgKGR4QiAtIHRoaXMucmFVbndyYXBBbmNob3IgPCAtMTgwKSBkeEIgKz0gMzYwCiAgICAgICAgfQogICAgICAgIGNvbnN0IEEgPSB7IHg6IGR4QSwgeTogY3VyQS5hbHQgLSB0Z3RBLmFsdCB9CiAgICAgICAgY29uc3QgQiA9IHsgeDogZHhCLCB5OiBjdXJCLmFsdCAtIHRndEIuYWx0IH0KICAgICAgICByZXR1cm4geyBBLCBCIH0KICAgICAgfSwKICAgICAgc2NyZWVuRm9yV29ybGQod3gsIHd5KSB7CiAgICAgICAgY29uc3QgZyA9IHRoaXMuZ2V0Q2FudmFzR2VvbSgpCiAgICAgICAgaWYgKCFnIHx8ICFOdW1iZXIuaXNGaW5pdGUodGhpcy5jdXJyZW50UHhQZXJEZWcpKSByZXR1cm4geyB4OiAwLCB5OiAwIH0KICAgICAgICBjb25zdCB7IHcsIGgsIHBhZFgsIHBhZFkgfSA9IGcKICAgICAgICBjb25zdCB4ID0gcGFkWCArIHRoaXMudmlld09mZnNldFhQeCArICh3eCAtICh0aGlzLnZpZXdNaW5Xb3JsZFggfHwgMCkpICogdGhpcy5jdXJyZW50UHhQZXJEZWcKICAgICAgICBjb25zdCB5ID0gaCAtIHBhZFkgLSB0aGlzLnZpZXdPZmZzZXRZUHggLSAod3kgLSAodGhpcy52aWV3TWluV29ybGRZIHx8IDApKSAqIHRoaXMuY3VycmVudFB4UGVyRGVnCiAgICAgICAgcmV0dXJuIHsgeCwgeSB9CiAgICAgIH0sCiAgICAgIGVuc3VyZVZpZXdNYXBwaW5nSW5pdGlhbGl6ZWQoc2VxV29ybGQpIHsKICAgICAgICBpZiAoIXNlcVdvcmxkIHx8IHNlcVdvcmxkLmxlbmd0aCA9PT0gMCkgcmV0dXJuCiAgICAgICAgaWYgKHRoaXMuY3VycmVudFB4UGVyRGVnICE9IG51bGwgJiYgdGhpcy52aWV3TWluV29ybGRYICE9IG51bGwpIHJldHVybgogICAgICAgIGNvbnN0IGcgPSB0aGlzLmdldENhbnZhc0dlb20oKQogICAgICAgIGlmICghZykgcmV0dXJuCiAgICAgICAgY29uc3QgeyB3LCBoLCBwYWRYLCBwYWRZIH0gPSBnCiAgICAgICAgLy8g6LW35aeL54K577ya5bqP5YiX56ys5LiA5Liq77yb55uu5qCH5Y6f54K55Li6ICgwLDApCiAgICAgICAgY29uc3QgZmlyc3QgPSBzZXFXb3JsZFswXQogICAgICAgIC8vIOWIneWni+WMluWxleW8gOmUmueCueS4uummlueCuSBY77yI55u45a+555uu5qCH77yJCiAgICAgICAgdGhpcy5yYVVud3JhcEFuY2hvciA9IGZpcnN0LngKICAgICAgICBjb25zdCBtaW5YID0gTWF0aC5taW4oMCwgZmlyc3QueCkKICAgICAgICBjb25zdCBtYXhYID0gTWF0aC5tYXgoMCwgZmlyc3QueCkKICAgICAgICBjb25zdCBtaW5ZID0gTWF0aC5taW4oMCwgZmlyc3QueSkKICAgICAgICBjb25zdCBtYXhZID0gTWF0aC5tYXgoMCwgZmlyc3QueSkKICAgICAgICBjb25zdCBzcGFuWCA9IE1hdGgubWF4KDFlLTYsIG1heFggLSBtaW5YKQogICAgICAgIGNvbnN0IHNwYW5ZID0gTWF0aC5tYXgoMWUtNiwgbWF4WSAtIG1pblkpCiAgICAgICAgY29uc3Qgc2NhbGVYID0gKHcgLSAyICogcGFkWCkgLyBzcGFuWAogICAgICAgIGNvbnN0IHNjYWxlWSA9IChoIC0gMiAqIHBhZFkpIC8gc3BhblkKICAgICAgICB0aGlzLmN1cnJlbnRQeFBlckRlZyA9IE1hdGgubWF4KDUsIE1hdGgubWluKHNjYWxlWCwgc2NhbGVZKSkKICAgICAgICB0aGlzLnZpZXdNaW5Xb3JsZFggPSBtaW5YCiAgICAgICAgdGhpcy52aWV3TWF4V29ybGRYID0gbWF4WAogICAgICAgIHRoaXMudmlld01pbldvcmxkWSA9IG1pblkKICAgICAgICB0aGlzLnZpZXdNYXhXb3JsZFkgPSBtYXhZCiAgICAgICAgLy8g5Yid5qyh6KeG5Zu+5YaF5a655bGF5Lit77ya5LuF5Zyo5Yid5aeL5YyW5pe26K6+572u5LiA5qyh5YGP56e7CiAgICAgICAgY29uc3QgY29udGVudFdweCA9IHNwYW5YICogdGhpcy5jdXJyZW50UHhQZXJEZWcKICAgICAgICBjb25zdCBjb250ZW50SHB4ID0gc3BhblkgKiB0aGlzLmN1cnJlbnRQeFBlckRlZwogICAgICAgIHRoaXMudmlld09mZnNldFhQeCA9IE1hdGgucm91bmQoKCh3IC0gMiAqIHBhZFgpIC0gY29udGVudFdweCkgLyAyKQogICAgICAgIHRoaXMudmlld09mZnNldFlQeCA9IE1hdGgucm91bmQoKChoIC0gMiAqIHBhZFkpIC0gY29udGVudEhweCkgLyAyKQogICAgICB9LAogICAgICBtYXliZUV4cGFuZFZpZXdGb3JQb2ludCh3eCwgd3kpIHsKICAgICAgICAvLyDoi6XngrnlnKjlvZPliY3lsY/luZXlhoXvvIzliJnkuI3mm7TmlrDmr5TkvovlsLrvvJvoi6XotornlYzvvIzmianlsZXovrnnlYzlubbku4XnvKnlsI/mr5TkvovlsLoKICAgICAgICBjb25zdCBnID0gdGhpcy5nZXRDYW52YXNHZW9tKCkKICAgICAgICBpZiAoIWcgfHwgdGhpcy5jdXJyZW50UHhQZXJEZWcgPT0gbnVsbCkgcmV0dXJuCiAgICAgICAgY29uc3QgeyB3LCBoLCBwYWRYLCBwYWRZIH0gPSBnCiAgICAgICAgY29uc3QgcHggPSBwYWRYICsgdGhpcy52aWV3T2Zmc2V0WFB4ICsgKHd4IC0gdGhpcy52aWV3TWluV29ybGRYKSAqIHRoaXMuY3VycmVudFB4UGVyRGVnCiAgICAgICAgY29uc3QgcHkgPSBoIC0gcGFkWSAtIHRoaXMudmlld09mZnNldFlQeCAtICh3eSAtIHRoaXMudmlld01pbldvcmxkWSkgKiB0aGlzLmN1cnJlbnRQeFBlckRlZwogICAgICAgIGNvbnN0IGluc2lkZSA9IHB4ID49IHBhZFggJiYgcHggPD0gKHcgLSBwYWRYKSAmJiBweSA+PSBwYWRZICYmIHB5IDw9IChoIC0gcGFkWSkKICAgICAgICBpZiAoaW5zaWRlKSByZXR1cm4KICAgICAgICAvLyDmianlsZXkuJbnlYzovrnnlYzliLDljIXlkKvor6XngrkKICAgICAgICBjb25zdCBuZXdNaW5YID0gTWF0aC5taW4odGhpcy52aWV3TWluV29ybGRYLCB3eCkKICAgICAgICBjb25zdCBuZXdNYXhYID0gTWF0aC5tYXgodGhpcy52aWV3TWF4V29ybGRYLCB3eCkKICAgICAgICBjb25zdCBuZXdNaW5ZID0gTWF0aC5taW4odGhpcy52aWV3TWluV29ybGRZLCB3eSkKICAgICAgICBjb25zdCBuZXdNYXhZID0gTWF0aC5tYXgodGhpcy52aWV3TWF4V29ybGRZLCB3eSkKICAgICAgICBjb25zdCBzcGFuWCA9IE1hdGgubWF4KDFlLTYsIG5ld01heFggLSBuZXdNaW5YKQogICAgICAgIGNvbnN0IHNwYW5ZID0gTWF0aC5tYXgoMWUtNiwgbmV3TWF4WSAtIG5ld01pblkpCiAgICAgICAgY29uc3Qgc2NhbGVYID0gKHcgLSAyICogcGFkWCkgLyBzcGFuWAogICAgICAgIGNvbnN0IHNjYWxlWSA9IChoIC0gMiAqIHBhZFkpIC8gc3BhblkKICAgICAgICBjb25zdCBjYW5kaWRhdGUgPSBNYXRoLm1heCg1LCBNYXRoLm1pbihzY2FsZVgsIHNjYWxlWSkpCiAgICAgICAgLy8g5LuF57yp5bCPCiAgICAgICAgdGhpcy5jdXJyZW50UHhQZXJEZWcgPSB0aGlzLmN1cnJlbnRQeFBlckRlZyA9PSBudWxsID8gY2FuZGlkYXRlIDogTWF0aC5taW4odGhpcy5jdXJyZW50UHhQZXJEZWcsIGNhbmRpZGF0ZSkKICAgICAgICB0aGlzLnZpZXdNaW5Xb3JsZFggPSBuZXdNaW5YCiAgICAgICAgdGhpcy52aWV3TWF4V29ybGRYID0gbmV3TWF4WAogICAgICAgIHRoaXMudmlld01pbldvcmxkWSA9IG5ld01pblkKICAgICAgICB0aGlzLnZpZXdNYXhXb3JsZFkgPSBuZXdNYXhZCiAgICAgICAgLy8g5Zu65a6a6ZSa54K577ya5LiN5YaN6YeN566X5YGP56e777yM5L+d5oyB55uu5qCH54K55bGP5bmV5L2N572u5oGS5a6aCiAgICAgIH0sCiAgICAgIGRyYXdUYXJnZXRNYXJrZXIoc2NhbGVPdmVycmlkZSA9IG51bGwpIHsKICAgICAgICBjb25zdCBjYW52YXMgPSB0aGlzLiRyZWZzLnRyYWplY3RvcnlDYW52YXMKICAgICAgICBpZiAoIWNhbnZhcykgcmV0dXJuCiAgICAgICAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJykKICAgICAgICBjb25zdCBnID0gdGhpcy5nZXRDYW52YXNHZW9tKCkKICAgICAgICBpZiAoIWcpIHJldHVybgogICAgICAgIGNvbnN0IHsgdywgaCB9ID0gZwogICAgICAgIGN0eC5zYXZlKCkKICAgICAgICAvLyDog4zmma8KICAgICAgICBjdHguZmlsbFN0eWxlID0gJ2JsYWNrJwogICAgICAgIGN0eC5maWxsUmVjdCgwLCAwLCB3LCBoKQogICAgICAgIC8vIOebruagh+WchueOrwogICAgICAgIGNvbnN0IGNlbnRlciA9IHRoaXMuc2NyZWVuRm9yV29ybGQoMCwgMCkKICAgICAgICBjb25zdCByaW5nRGVnID0gdGhpcy5nZXRUYXJnZXRSaW5nRGVnKCkKICAgICAgICBjb25zdCBzY2FsZSA9IChzY2FsZU92ZXJyaWRlICE9IG51bGwgPyBzY2FsZU92ZXJyaWRlIDogdGhpcy5jdXJyZW50UHhQZXJEZWcpIHx8IDQwCiAgICAgICAgLy8g5Y2K5b6E6ZmQ5Yi277ya5LiN6LaF5Ye65Y+v6KeB5Yy65Z+fCiAgICAgICAgY29uc3QgclB4ID0gTWF0aC5tYXgoNiwgTWF0aC5taW4oTWF0aC5taW4odywgaCkgKiAwLjQ1LCByaW5nRGVnICogc2NhbGUpKQogICAgICAgIGN0eC5zdHJva2VTdHlsZSA9ICcjNENBRjUwJwogICAgICAgIGN0eC5saW5lV2lkdGggPSAyCiAgICAgICAgY3R4LmJlZ2luUGF0aCgpCiAgICAgICAgY3R4LmFyYyhjZW50ZXIueCwgY2VudGVyLnksIHJQeCwgMCwgTWF0aC5QSSAqIDIpCiAgICAgICAgY3R4LnN0cm9rZSgpCiAgICAgICAgY3R4LmZpbGxTdHlsZSA9ICcjNENBRjUwJwogICAgICAgIGN0eC5iZWdpblBhdGgoKQogICAgICAgIGN0eC5hcmMoY2VudGVyLngsIGNlbnRlci55LCAzLCAwLCBNYXRoLlBJICogMikKICAgICAgICBjdHguZmlsbCgpCiAgICAgICAgY3R4LnJlc3RvcmUoKQogICAgICB9LAogICAgICBkcmF3VGFyZ2V0QXRDZW50ZXIocmluZ0RlZ092ZXJyaWRlID0gbnVsbCkgewogICAgICAgIGNvbnN0IGNhbnZhcyA9IHRoaXMuJHJlZnMudHJhamVjdG9yeUNhbnZhcwogICAgICAgIGlmICghY2FudmFzKSByZXR1cm4KICAgICAgICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKQogICAgICAgIGNvbnN0IGN4ID0gTWF0aC5yb3VuZCgodGhpcy5vdmVybGF5TW9kZSA9PT0gJ3dpbmRvd2VkJyA/IHRoaXMuYmFzZUNhbnZhc0xvZ2ljYWxTaXplLndpZHRoIDogY2FudmFzLmNsaWVudFdpZHRoKSAvIDIpCiAgICAgICAgY29uc3QgY3kgPSBNYXRoLnJvdW5kKCh0aGlzLm92ZXJsYXlNb2RlID09PSAnd2luZG93ZWQnID8gdGhpcy5iYXNlQ2FudmFzTG9naWNhbFNpemUuaGVpZ2h0IDogY2FudmFzLmNsaWVudEhlaWdodCkgLyAyKQogICAgICAgIGN0eC5zYXZlKCkKICAgICAgICAvLyDpu5HoibLog4zmma8KICAgICAgICBjdHguZmlsbFN0eWxlID0gJ2JsYWNrJwogICAgICAgIGNvbnN0IGJ3ID0gdGhpcy5vdmVybGF5TW9kZSA9PT0gJ3dpbmRvd2VkJyA/IHRoaXMuYmFzZUNhbnZhc0xvZ2ljYWxTaXplLndpZHRoIDogY2FudmFzLmNsaWVudFdpZHRoCiAgICAgICAgY29uc3QgYmggPSB0aGlzLm92ZXJsYXlNb2RlID09PSAnd2luZG93ZWQnID8gdGhpcy5iYXNlQ2FudmFzTG9naWNhbFNpemUuaGVpZ2h0IDogY2FudmFzLmNsaWVudEhlaWdodAogICAgICAgIGN0eC5maWxsUmVjdCgwLCAwLCBidywgYmgpCiAgICAgICAgLy8g55uu5qCH54K5546v77yI56m65b+D77yJKyDkuK3lv4PlsI/ngrkKICAgICAgICBjb25zdCBiYXNlID0gdGhpcy5hdXRvRml0UHhQZXJEZWcgfHwgNDAKICAgICAgICBjb25zdCBzY2FsZVB4UGVyRGVnID0gYmFzZQogICAgICAgIGNvbnN0IHJpbmdEZWcgPSByaW5nRGVnT3ZlcnJpZGUgIT09IG51bGwgPyByaW5nRGVnT3ZlcnJpZGUgOiB0aGlzLmdldFRhcmdldFJpbmdEZWcoKQogICAgICAgIGNvbnN0IGhhbGZXID0gYncgLyAyCiAgICAgICAgY29uc3QgaGFsZkggPSBiaCAvIDIKICAgICAgICBjb25zdCBwYWQgPSAyNAogICAgICAgIGNvbnN0IHJNYXggPSBNYXRoLm1heCg2LCBNYXRoLm1pbihoYWxmVyAtIHBhZCwgaGFsZkggLSBwYWQpKQogICAgICAgIGNvbnN0IHJQeCA9IE1hdGgubWF4KDYsIE1hdGgubWluKHJNYXgsIHJpbmdEZWcgKiBzY2FsZVB4UGVyRGVnKSkKICAgICAgICAvLyDnqbrlv4PlnIYKICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSAnIzRDQUY1MCcKICAgICAgICBjdHgubGluZVdpZHRoID0gMgogICAgICAgIGN0eC5iZWdpblBhdGgoKQogICAgICAgIGN0eC5hcmMoY3gsIGN5LCByUHgsIDAsIE1hdGguUEkgKiAyKQogICAgICAgIGN0eC5zdHJva2UoKQogICAgICAgIC8vIOS4reW/g+Wwj+eCuQogICAgICAgIGN0eC5maWxsU3R5bGUgPSAnIzRDQUY1MCcKICAgICAgICBjdHguYmVnaW5QYXRoKCkKICAgICAgICBjdHguYXJjKGN4LCBjeSwgMywgMCwgTWF0aC5QSSAqIDIpCiAgICAgICAgY3R4LmZpbGwoKQogICAgICAgIGN0eC5yZXN0b3JlKCkKICAgICAgfSwKICAgICAgZ2V0VGFyZ2V0UmluZ0RlZygpIHsKICAgICAgICAvLyDnjq/lpKflsI/kuI3otoXov4fop4blnLrljYrlvoTvvIjlj5YgUkEvREVDIOi3qOW6pueahOi+g+Wwj+S4gOWNiu+8jOeVmSA5MCUg6L656Led77yJCiAgICAgICAgaWYgKCF0aGlzLmZpZWxkRGF0YSkgcmV0dXJuIDAuMwogICAgICAgIGNvbnN0IHJhcyA9IFt0aGlzLmZpZWxkRGF0YS5yYTAsIHRoaXMuZmllbGREYXRhLnJhMSwgdGhpcy5maWVsZERhdGEucmEyLCB0aGlzLmZpZWxkRGF0YS5yYTNdCiAgICAgICAgY29uc3QgZGVjcyA9IFt0aGlzLmZpZWxkRGF0YS5kZWMwLCB0aGlzLmZpZWxkRGF0YS5kZWMxLCB0aGlzLmZpZWxkRGF0YS5kZWMyLCB0aGlzLmZpZWxkRGF0YS5kZWMzXQogICAgICAgIGNvbnN0IHJhU3BhbiA9IE1hdGgubWF4KC4uLnJhcykgLSBNYXRoLm1pbiguLi5yYXMpCiAgICAgICAgY29uc3QgZGVjU3BhbiA9IE1hdGgubWF4KC4uLmRlY3MpIC0gTWF0aC5taW4oLi4uZGVjcykKICAgICAgICBjb25zdCBoYWxmTWluID0gTWF0aC5tYXgoMC4wMSwgTWF0aC5taW4ocmFTcGFuLCBkZWNTcGFuKSAvIDIpCiAgICAgICAgcmV0dXJuIGhhbGZNaW4gKiAwLjkKICAgICAgfSwKICAgICAgcmFEZWNUb0NhbnZhc0RlbHRhKHJhRGVnLCBkZWNEZWcpIHsKICAgICAgICAvLyDlsIbnm7jlr7nnm67moIfngrnnmoQgKM6UUkEsIM6UREVDKSDovazmjaLkuLrnlLvluIPlg4/ntKDlgY/np7vjgIIKICAgICAgICAvLyDkvb/nlKjoh6rpgILlupTlg4/ntKAv5bqm5q+U5L6L77yM5bm25Zyo5YWo5bGP5qih5byP5LiL5YaN5LmY5Lul55So5oi357yp5pS+5Zug5a2Q44CCCiAgICAgICAgY29uc3QgYmFzZSA9IHRoaXMuYXV0b0ZpdFB4UGVyRGVnIHx8IDQwCiAgICAgICAgY29uc3Qgc2NhbGVQeFBlckRlZyA9IGJhc2UKICAgICAgICAvLyDlm7rlrprnuqblrprvvJpSQSDlop7lpKflkJHlj7MKICAgICAgICBjb25zdCBkeCA9ICh0aGlzLm5vcm1hbGl6ZVJhRGVsdGEocmFEZWcpKSAqIHNjYWxlUHhQZXJEZWcKICAgICAgICBjb25zdCBkeSA9ICgtZGVjRGVnKSAqIHNjYWxlUHhQZXJEZWcKICAgICAgICByZXR1cm4geyBkeCwgZHkgfQogICAgICB9LAogICAgICBub3JtYWxpemVSYURlbHRhKGRlbHRhRGVnKSB7CiAgICAgICAgLy8g5bCGIFJBIOW3ruWAvOW9kuS4gOWIsCBbLTE4MCwgMTgwKQogICAgICAgIGxldCB4ID0gZGVsdGFEZWcKICAgICAgICB4ID0gKCh4ICsgNTQwKSAlIDM2MCkgLSAxODAKICAgICAgICByZXR1cm4geAogICAgICB9LAogICAgICBub3JtYWxpemVBekRlbHRhKGRlbHRhRGVnKSB7CiAgICAgICAgLy8g5bCGIEF6IOW3ruWAvOW9kuS4gOWIsCBbLTE4MCwgMTgwKQogICAgICAgIGxldCB4ID0gZGVsdGFEZWcKICAgICAgICB4ID0gKCh4ICsgNTQwKSAlIDM2MCkgLSAxODAKICAgICAgICByZXR1cm4geAogICAgICB9LAoKICAgICAgLy8gPT09IOi9qOi/ueeCueWQiOW5ti/ov73liqDvvIjmjIkgQWx0L0F6IOWuueW3ru+8iSA9PT0KICAgICAgYXBwZW5kUmF3VHJhamVjdG9yeVBvaW50KHJhRGVnLCBkZWNEZWcsIHRpbWVNcyA9IERhdGUubm93KCkpIHsKICAgICAgICBpZiAoIU51bWJlci5pc0Zpbml0ZShyYURlZykgfHwgIU51bWJlci5pc0Zpbml0ZShkZWNEZWcpKSByZXR1cm4KICAgICAgICBjb25zdCBsb2MgPSB0aGlzLiRzdG9yZT8uc3RhdGU/LmN1cnJlbnRMb2NhdGlvbiB8fCB7fQogICAgICAgIGNvbnN0IGxhdCA9IE51bWJlcihsb2MubGF0KQogICAgICAgIGNvbnN0IGxvbiA9IE51bWJlcihsb2MubG5nKQogICAgICAgIGlmICghTnVtYmVyLmlzRmluaXRlKGxhdCkgfHwgIU51bWJlci5pc0Zpbml0ZShsb24pKSB7CiAgICAgICAgICAvLyDml6Dms5XovazmjaIgQWx0L0F677yM5YiZ55u05o6l6L+95YqgCiAgICAgICAgICB0aGlzLnJhd1RyYWplY3RvcnlQb2ludHMucHVzaCh7IHJhOiByYURlZywgZGVjOiBkZWNEZWcsIHQ6IHRpbWVNcyB9KQogICAgICAgICAgcmV0dXJuCiAgICAgICAgfQogICAgICAgIGNvbnN0IHQgPSBuZXcgRGF0ZSh0aW1lTXMpCiAgICAgICAgLy8g6K6h566X5b2T5YmN54K55LiO5LiK5LiA54K55ZyoIEFsdC9BeiDkuIrnmoTot53nprsKICAgICAgICBjb25zdCBjdXJBbHRBeiA9IHRoaXMuZXF1YXRvcmlhbFRvSG9yaXpvbnRhbChyYURlZywgZGVjRGVnLCB0LCBsYXQsIGxvbikKICAgICAgICBjb25zdCB0b2xEZWcgPSAoTnVtYmVyKHRoaXMudHJhamVjdG9yeU1lcmdlVG9sQXJjbWluKSB8fCAwKSAvIDYwCiAgICAgICAgY29uc3QgbGFzdCA9IHRoaXMucmF3VHJhamVjdG9yeVBvaW50c1t0aGlzLnJhd1RyYWplY3RvcnlQb2ludHMubGVuZ3RoIC0gMV0KICAgICAgICBpZiAoIWxhc3QpIHsKICAgICAgICAgIHRoaXMucmF3VHJhamVjdG9yeVBvaW50cy5wdXNoKHsgcmE6IHJhRGVnLCBkZWM6IGRlY0RlZywgdDogdGltZU1zIH0pCiAgICAgICAgICByZXR1cm4KICAgICAgICB9CiAgICAgICAgY29uc3QgbGFzdEFsdEF6ID0gdGhpcy5lcXVhdG9yaWFsVG9Ib3Jpem9udGFsKGxhc3QucmEsIGxhc3QuZGVjLCBuZXcgRGF0ZShsYXN0LnQgfHwgdGltZU1zKSwgbGF0LCBsb24pCiAgICAgICAgY29uc3QgZEF6ID0gdGhpcy5ub3JtYWxpemVBekRlbHRhKGN1ckFsdEF6LmF6IC0gbGFzdEFsdEF6LmF6KQogICAgICAgIGNvbnN0IGRBbHQgPSBjdXJBbHRBei5hbHQgLSBsYXN0QWx0QXouYWx0CiAgICAgICAgY29uc3Qgc2VwID0gTWF0aC5oeXBvdChkQXosIGRBbHQpCiAgICAgICAgaWYgKHNlcCA8PSB0b2xEZWcpIHsKICAgICAgICAgIC8vIOWQiOW5tu+8muabtOaWsOacgOWQjuS4gOeCueS4uuW9k+WJjeWAvO+8iOS/neaMgeaXtumXtOacgOaWsO+8iQogICAgICAgICAgbGFzdC5yYSA9IHJhRGVnCiAgICAgICAgICBsYXN0LmRlYyA9IGRlY0RlZwogICAgICAgICAgbGFzdC50ID0gdGltZU1zCiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIHRoaXMucmF3VHJhamVjdG9yeVBvaW50cy5wdXNoKHsgcmE6IHJhRGVnLCBkZWM6IGRlY0RlZywgdDogdGltZU1zIH0pCiAgICAgICAgfQogICAgICB9LAogICAgICB1bndyYXBSYURlbHRhU2VxdWVuY2UoZFJhRGVnTGlzdCkgewogICAgICAgIC8vIOS9v+ebuOmCuyBkUkEg5bqP5YiX5Zyo5pWw5YC85LiK6L+e57ut77yM6YG/5YWN6LeoIDAvMzYwIOWPkeeUn+mVv+i/nue6vwogICAgICAgIGlmICghZFJhRGVnTGlzdCB8fCBkUmFEZWdMaXN0Lmxlbmd0aCA9PT0gMCkgcmV0dXJuIFtdCiAgICAgICAgY29uc3Qgb3V0ID0gW2RSYURlZ0xpc3RbMF1dCiAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBkUmFEZWdMaXN0Lmxlbmd0aDsgaSsrKSB7CiAgICAgICAgICBsZXQgY3VyciA9IGRSYURlZ0xpc3RbaV0KICAgICAgICAgIGxldCBwcmV2ID0gb3V0W2kgLSAxXQogICAgICAgICAgbGV0IGRpZmYgPSBjdXJyIC0gcHJldgogICAgICAgICAgd2hpbGUgKGRpZmYgPiAxODApIHsgY3VyciAtPSAzNjA7IGRpZmYgPSBjdXJyIC0gcHJldiB9CiAgICAgICAgICB3aGlsZSAoZGlmZiA8IC0xODApIHsgY3VyciArPSAzNjA7IGRpZmYgPSBjdXJyIC0gcHJldiB9CiAgICAgICAgICBvdXQucHVzaChjdXJyKQogICAgICAgIH0KICAgICAgICByZXR1cm4gb3V0CiAgICAgIH0sCiAgICAgIGFwcGVuZFRyYWplY3RvcnlQb2ludChyYXdSYURlZywgcmF3RGVjRGVnKSB7CiAgICAgICAgLy8g5bey5L+d55WZ5Lul5YW85a656LCD55So77yM5L2G5b2T5YmN6YeN57uY5L2/55SoIHJlZHJhd1RyYWplY3Rvcnkg6KaG55uW5YWo6YeP57uY5Yi2CiAgICAgICAgaWYgKCF0aGlzLnRhcmdldFJhd1Bvc2l0aW9uKSByZXR1cm4KICAgICAgICBjb25zdCBjYW52YXMgPSB0aGlzLiRyZWZzLnRyYWplY3RvcnlDYW52YXMKICAgICAgICBpZiAoIWNhbnZhcykgcmV0dXJuCiAgICAgICAgY29uc3QgY3ggPSBNYXRoLnJvdW5kKCh0aGlzLm92ZXJsYXlNb2RlID09PSAnd2luZG93ZWQnID8gdGhpcy5iYXNlQ2FudmFzTG9naWNhbFNpemUud2lkdGggOiBjYW52YXMuY2xpZW50V2lkdGgpIC8gMikKICAgICAgICBjb25zdCBjeSA9IE1hdGgucm91bmQoKHRoaXMub3ZlcmxheU1vZGUgPT09ICd3aW5kb3dlZCcgPyB0aGlzLmJhc2VDYW52YXNMb2dpY2FsU2l6ZS5oZWlnaHQgOiBjYW52YXMuY2xpZW50SGVpZ2h0KSAvIDIpCiAgICAgICAgY29uc3QgZFJhID0gcmF3UmFEZWcgLSB0aGlzLnRhcmdldFJhd1Bvc2l0aW9uLnJhCiAgICAgICAgY29uc3QgZERlYyA9IHJhd0RlY0RlZyAtIHRoaXMudGFyZ2V0UmF3UG9zaXRpb24uZGVjCiAgICAgICAgY29uc3QgeyBkeCwgZHkgfSA9IHRoaXMucmFEZWNUb0NhbnZhc0RlbHRhKGRSYSwgZERlYykKICAgICAgICBjb25zdCBwb2ludCA9IHsgeDogY3ggKyBkeCwgeTogY3kgKyBkeSB9CiAgICAgICAgdGhpcy50cmFqZWN0b3J5UG9pbnRzLnB1c2gocG9pbnQpCiAgICAgICAgdGhpcy5kcmF3UG9pbnQocG9pbnQueCwgcG9pbnQueSwgJyNGRkQ1NEYnKQogICAgICB9LAogICAgICBkcmF3UG9pbnQoeCwgeSwgY29sb3IpIHsKICAgICAgICBjb25zdCBjYW52YXMgPSB0aGlzLiRyZWZzLnRyYWplY3RvcnlDYW52YXMKICAgICAgICBpZiAoIWNhbnZhcykgcmV0dXJuCiAgICAgICAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJykKICAgICAgICBjdHguc2F2ZSgpCiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGNvbG9yIHx8ICcjMDBCRkZGJwogICAgICAgIGN0eC5iZWdpblBhdGgoKQogICAgICAgIGN0eC5hcmMoeCwgeSwgMywgMCwgTWF0aC5QSSAqIDIpCiAgICAgICAgY3R4LmZpbGwoKQogICAgICAgIGN0eC5yZXN0b3JlKCkKICAgICAgfSwKICAgICAgZHJhd0Fycm93KHgxLCB5MSwgeDIsIHkyLCBjb2xvcikgewogICAgICAgIGNvbnN0IGNhbnZhcyA9IHRoaXMuJHJlZnMudHJhamVjdG9yeUNhbnZhcwogICAgICAgIGlmICghY2FudmFzKSByZXR1cm4KICAgICAgICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKQogICAgICAgIGN0eC5zYXZlKCkKICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBjb2xvciB8fCAnI0ZGRDU0RicKICAgICAgICBjdHguZmlsbFN0eWxlID0gY29sb3IgfHwgJyNGRkQ1NEYnCiAgICAgICAgY3R4LmxpbmVXaWR0aCA9IDIKICAgICAgICBjdHguYmVnaW5QYXRoKCkKICAgICAgICBjdHgubW92ZVRvKHgxLCB5MSkKICAgICAgICBjdHgubGluZVRvKHgyLCB5MikKICAgICAgICBjdHguc3Ryb2tlKCkKICAgICAgICAvLyDnrq3lpLQKICAgICAgICBjb25zdCBhbmdsZSA9IE1hdGguYXRhbjIoeTIgLSB5MSwgeDIgLSB4MSkKICAgICAgICBjb25zdCBoZWFkTGVuID0gOAogICAgICAgIGN0eC5iZWdpblBhdGgoKQogICAgICAgIGN0eC5tb3ZlVG8oeDIsIHkyKQogICAgICAgIGN0eC5saW5lVG8oeDIgLSBoZWFkTGVuICogTWF0aC5jb3MoYW5nbGUgLSBNYXRoLlBJIC8gNiksIHkyIC0gaGVhZExlbiAqIE1hdGguc2luKGFuZ2xlIC0gTWF0aC5QSSAvIDYpKQogICAgICAgIGN0eC5saW5lVG8oeDIgLSBoZWFkTGVuICogTWF0aC5jb3MoYW5nbGUgKyBNYXRoLlBJIC8gNiksIHkyIC0gaGVhZExlbiAqIE1hdGguc2luKGFuZ2xlICsgTWF0aC5QSSAvIDYpKQogICAgICAgIGN0eC5saW5lVG8oeDIsIHkyKQogICAgICAgIGN0eC5maWxsKCkKICAgICAgICBjdHgucmVzdG9yZSgpCiAgICAgIH0sCiAgICAgIC8vIOeUu+S7juebruagh+WIsOacgOWQjuS4gOauteeahOWegue6v++8iOiZmue6v++8ie+8m+WmguWegui2s+S4jeWcqOauteWGhe+8jOS7heWwhue6v+auteaciemZkOW7tumVv+iHs+WegueCuQogICAgICBkcmF3UGVycGVuZGljdWxhckF1eExpbmUoKSB7CiAgICAgICAgaWYgKCF0aGlzLnRhcmdldFJhd1Bvc2l0aW9uIHx8IHRoaXMucmF3VHJhamVjdG9yeVBvaW50cy5sZW5ndGggPCAyKSByZXR1cm4KICAgICAgICAvLyDkvb/nlKjigJzlhajph4/ov57nu63lsZXlvIDigJ3nmoTmnIDlkI7kuKTngrnvvIzlhYHorrggUkEg6LaF5Ye65bi46KeE6IyD5Zu077yM5L+d6K+B5Yeg5L2V6L+e57utCiAgICAgICAgY29uc3QgcGFpciA9IHRoaXMuZ2V0V29ybGRBQkZvclBlcnAoKTsgaWYgKCFwYWlyKSByZXR1cm4KICAgICAgICBjb25zdCB7IEEsIEIgfSA9IHBhaXIKICAgICAgICBjb25zdCBPID0geyB4OiAwLCB5OiAwIH0gLy8g55uu5qCH5Zyo5LiW55WM5Z2Q5qCH5Li65Y6f54K577yI5LiOIHdvcmxkRm9yUG9pbnQv5bGV5byA5L+d5oyB5LiA6Ie077yJCiAgICAgICAgLy8g57q/5q61IEFCIOeahOWQkemHj+S4jiBPIOWIsCBBQiDnmoTmipXlvbHlj4LmlbAgdAogICAgICAgIGNvbnN0IHZ4ID0gQi54IC0gQS54CiAgICAgICAgY29uc3QgdnkgPSBCLnkgLSBBLnkKICAgICAgICBjb25zdCBsZW4yID0gdnggKiB2eCArIHZ5ICogdnkKICAgICAgICBpZiAobGVuMiA8IDFlLTkpIHJldHVybgogICAgICAgIGNvbnN0IHQgPSAoKE8ueCAtIEEueCkgKiB2eCArIChPLnkgLSBBLnkpICogdnkpIC8gbGVuMgogICAgICAgIGxldCBIeCwgSHksIHNlZ21lbnQKICAgICAgICBpZiAodCA+PSAwICYmIHQgPD0gMSkgewogICAgICAgICAgLy8g5Z6C6Laz5Zyo57q/5q615LiKCiAgICAgICAgICBIeCA9IEEueCArIHQgKiB2eAogICAgICAgICAgSHkgPSBBLnkgKyB0ICogdnkKICAgICAgICAgIC8vIOWegui2s+WcqOe6v+auteS4iuaXtu+8jOS4jeWGjee7mOWItuaVtOaute+8jOWPqueUuyBP4oaSSCDnmoTlnoLnur8KICAgICAgICAgIHNlZ21lbnQgPSBudWxsCiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIC8vIOWegui2s+WcqOe6v+auteWklu+8muiuoeeul+ecn+ato+eahOWegui2syBI77yM5bm25oqK57q/5q615pydIEgg5pa55ZCR5pyJ6ZmQ5bu26ZW/6IezIEgKICAgICAgICAgIEh4ID0gQS54ICsgdCAqIHZ4CiAgICAgICAgICBIeSA9IEEueSArIHQgKiB2eQogICAgICAgICAgaWYgKHQgPCAwKSB7CiAgICAgICAgICAgIHNlZ21lbnQgPSB7IHgxOiBIeCwgeTE6IEh5LCB4MjogQS54LCB5MjogQS55IH0KICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIHNlZ21lbnQgPSB7IHgxOiBCLngsIHkxOiBCLnksIHgyOiBIeCwgeTI6IEh5IH0KICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgLy8g55S75Z6C57q/77yITy0+SO+8ieS4ju+8iOWPr+iDveeahOW7tumVv++8iee6v+aute+8jOWdh+S9v+eUqOiZmue6vwogICAgICAgIGNvbnN0IGNhbnZhcyA9IHRoaXMuJHJlZnMudHJhamVjdG9yeUNhbnZhcwogICAgICAgIGlmICghY2FudmFzKSByZXR1cm4KICAgICAgICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKQogICAgICAgIGNvbnN0IE9weCA9IHRoaXMuc2NyZWVuRm9yV29ybGQoTy54LCBPLnkpCiAgICAgICAgY29uc3QgSHB4ID0gdGhpcy5zY3JlZW5Gb3JXb3JsZChIeCwgSHkpCiAgICAgICAgLy8gY29uc3QgUzEgPSB0aGlzLnNjcmVlbkZvcldvcmxkKHNlZ21lbnQueDEsIHNlZ21lbnQueTEpCiAgICAgICAgLy8gY29uc3QgUzIgPSB0aGlzLnNjcmVlbkZvcldvcmxkKHNlZ21lbnQueDIsIHNlZ21lbnQueTIpCiAgICAgICAgY3R4LnNhdmUoKQogICAgICAgIGN0eC5zZXRMaW5lRGFzaChbNiwgNl0pCiAgICAgICAgY3R4LmxpbmVXaWR0aCA9IDEuNQogICAgICAgIGN0eC5zdHJva2VTdHlsZSA9ICcjOUU5RTlFJwogICAgICAgIC8vIOWegue6vyBPLUgKICAgICAgICBjdHguYmVnaW5QYXRoKCkKICAgICAgICBjdHgubW92ZVRvKE9weC54LCBPcHgueSkKICAgICAgICBjdHgubGluZVRvKEhweC54LCBIcHgueSkKICAgICAgICBjdHguc3Ryb2tlKCkKICAgICAgICAvLyDlnKjovoXliqnnur/vvIjomZrnur/vvInkuIrnlKjnrq3lpLTmoIfmmI7mlrnlkJHvvJrku44gSCDmjIflkJEgT++8iOaMh+WQkeebruagh++8iQogICAgICAgIC8vIOmAieaLqee6v+auteWGheS4gOeCueS9nOS4uueureWktOS9jee9ru+8jOmBv+WFjeS4juebruagh+eOr+mHjeWPoAogICAgICAgIGNvbnN0IHRBcnJvdyA9IDAuNgogICAgICAgIGNvbnN0IGF4ID0gSHB4LnggKyAoT3B4LnggLSBIcHgueCkgKiB0QXJyb3cKICAgICAgICBjb25zdCBheSA9IEhweC55ICsgKE9weC55IC0gSHB4LnkpICogdEFycm93CiAgICAgICAgY29uc3QgYW5nID0gTWF0aC5hdGFuMihPcHgueSAtIEhweC55LCBPcHgueCAtIEhweC54KQogICAgICAgIGNvbnN0IGhlYWQgPSA4CiAgICAgICAgY3R4LnNldExpbmVEYXNoKFtdKQogICAgICAgIGN0eC5maWxsU3R5bGUgPSAnIzlFOUU5RScKICAgICAgICBjdHguYmVnaW5QYXRoKCkKICAgICAgICBjdHgubW92ZVRvKGF4LCBheSkKICAgICAgICBjdHgubGluZVRvKGF4IC0gaGVhZCAqIE1hdGguY29zKGFuZyAtIE1hdGguUEkgLyA2KSwgYXkgLSBoZWFkICogTWF0aC5zaW4oYW5nIC0gTWF0aC5QSSAvIDYpKQogICAgICAgIGN0eC5saW5lVG8oYXggLSBoZWFkICogTWF0aC5jb3MoYW5nICsgTWF0aC5QSSAvIDYpLCBheSAtIGhlYWQgKiBNYXRoLnNpbihhbmcgKyBNYXRoLlBJIC8gNikpCiAgICAgICAgY3R4LmNsb3NlUGF0aCgpCiAgICAgICAgY3R4LmZpbGwoKQogICAgICAgIC8vIOaBouWkjeiZmue6v+agt+W8j++8jOeUqOS6jue7mOWItuW7tumVv+autQogICAgICAgIGN0eC5zZXRMaW5lRGFzaChbNiwgNl0pCiAgICAgICAgLy8g5LuF5b2T5Z6C6Laz5LiN5Zyo5q615LiK5pe257uY5Yi24oCc5bu26ZW/5Yiw5Z6C54K54oCd55qE6YKj5q61CiAgICAgICAgaWYgKHNlZ21lbnQpIHsKICAgICAgICAgIGNvbnN0IFMxID0gdGhpcy5zY3JlZW5Gb3JXb3JsZChzZWdtZW50LngxLCBzZWdtZW50LnkxKQogICAgICAgICAgY29uc3QgUzIgPSB0aGlzLnNjcmVlbkZvcldvcmxkKHNlZ21lbnQueDIsIHNlZ21lbnQueTIpCiAgICAgICAgICBjdHguYmVnaW5QYXRoKCkKICAgICAgICAgIGN0eC5tb3ZlVG8oUzEueCwgUzEueSkKICAgICAgICAgIGN0eC5saW5lVG8oUzIueCwgUzIueSkKICAgICAgICAgIGN0eC5zdHJva2UoKQogICAgICAgICAgLy8g5Zyo5bu26ZW/5q615LiK5Lmf5qCH5rOo5LiA5Liq5pyd5ZCR4oCc5Z6C6LazIEjigJ3nmoTlsI/nrq3lpLQKICAgICAgICAgIGNvbnN0IGV4U3RhcnQgPSAodCA8IDApID8geyB4OiBBLngsIHk6IEEueSB9IDogeyB4OiBCLngsIHk6IEIueSB9CiAgICAgICAgICBjb25zdCBleEVuZCA9IHsgeDogSHgsIHk6IEh5IH0KICAgICAgICAgIGNvbnN0IEVTID0gdGhpcy5zY3JlZW5Gb3JXb3JsZChleFN0YXJ0LngsIGV4U3RhcnQueSkKICAgICAgICAgIGNvbnN0IEVFID0gdGhpcy5zY3JlZW5Gb3JXb3JsZChleEVuZC54LCBleEVuZC55KQogICAgICAgICAgY29uc3QgZXhkeCA9IEVFLnggLSBFUy54CiAgICAgICAgICBjb25zdCBleGR5ID0gRUUueSAtIEVTLnkKICAgICAgICAgIGNvbnN0IGV4TGVuMiA9IGV4ZHggKiBleGR4ICsgZXhkeSAqIGV4ZHkKICAgICAgICAgIGlmIChleExlbjIgPiAxKSB7CiAgICAgICAgICAgIGNvbnN0IHRFeCA9IDAuNQogICAgICAgICAgICBjb25zdCBlYXggPSBFUy54ICsgZXhkeCAqIHRFeAogICAgICAgICAgICBjb25zdCBlYXkgPSBFUy55ICsgZXhkeSAqIHRFeAogICAgICAgICAgICBjb25zdCBlYW5nID0gTWF0aC5hdGFuMihleGR5LCBleGR4KQogICAgICAgICAgICBjdHguc2V0TGluZURhc2goW10pCiAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKQogICAgICAgICAgICBjdHgubW92ZVRvKGVheCwgZWF5KQogICAgICAgICAgICBjdHgubGluZVRvKGVheCAtIGhlYWQgKiBNYXRoLmNvcyhlYW5nIC0gTWF0aC5QSSAvIDYpLCBlYXkgLSBoZWFkICogTWF0aC5zaW4oZWFuZyAtIE1hdGguUEkgLyA2KSkKICAgICAgICAgICAgY3R4LmxpbmVUbyhlYXggLSBoZWFkICogTWF0aC5jb3MoZWFuZyArIE1hdGguUEkgLyA2KSwgZWF5IC0gaGVhZCAqIE1hdGguc2luKGVhbmcgKyBNYXRoLlBJIC8gNikpCiAgICAgICAgICAgIGN0eC5jbG9zZVBhdGgoKQogICAgICAgICAgICBjdHguZmlsbCgpCiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIGN0eC5yZXN0b3JlKCkKICAgICAgfSwKICAgICAgY29tcHV0ZUF1dG9GaXRTY2FsZSgpIHsKICAgICAgICBjb25zdCBjYW52YXMgPSB0aGlzLiRyZWZzLnRyYWplY3RvcnlDYW52YXMKICAgICAgICBpZiAoIWNhbnZhcyB8fCAhdGhpcy50YXJnZXRSYXdQb3NpdGlvbikgcmV0dXJuIDQwCiAgICAgICAgY29uc3QgY3ggPSB0aGlzLnRhcmdldFJhd1Bvc2l0aW9uLnJhCiAgICAgICAgY29uc3QgY3kgPSB0aGlzLnRhcmdldFJhd1Bvc2l0aW9uLmRlYwogICAgICAgIGxldCBtYXhEeCA9IDAsIG1heER5ID0gMAogICAgICAgIC8vIOWOhuWPsueCuQogICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5yYXdUcmFqZWN0b3J5UG9pbnRzLmxlbmd0aDsgaSsrKSB7CiAgICAgICAgICBjb25zdCBwID0gdGhpcy5yYXdUcmFqZWN0b3J5UG9pbnRzW2ldCiAgICAgICAgICBtYXhEeCA9IE1hdGgubWF4KG1heER4LCBNYXRoLmFicyh0aGlzLm5vcm1hbGl6ZVJhRGVsdGEocC5yYSAtIGN4KSkpCiAgICAgICAgICBtYXhEeSA9IE1hdGgubWF4KG1heER5LCBNYXRoLmFicyhwLmRlYyAtIGN5KSkKICAgICAgICB9CiAgICAgICAgLy8g55uu5qCH546v5Y2K5b6E77yI56Gu5L+d546v5LiN5Lya6aG26L6577yJCiAgICAgICAgY29uc3QgcmluZ0RlZyA9IHRoaXMuZ2V0VGFyZ2V0UmluZ0RlZygpCiAgICAgICAgbWF4RHggPSBNYXRoLm1heChtYXhEeCwgcmluZ0RlZykKICAgICAgICBtYXhEeSA9IE1hdGgubWF4KG1heER5LCByaW5nRGVnKQogICAgICAgIC8vIOWFqOWxj+aXtue6s+WFpeinhuWcuuinkueCueS7pemAgumFjeinhuWcuuahhu+8m+eql+WPo+aooeW8j+S4jee6s+WFpQogICAgICAgIGlmICh0aGlzLm92ZXJsYXlNb2RlID09PSAnZnVsbHNjcmVlbicpIHsKICAgICAgICAgIGlmICh0aGlzLmZpZWxkRGF0YSAmJiBOdW1iZXIuaXNGaW5pdGUodGhpcy5maWVsZERhdGEucmEwKSkgewogICAgICAgICAgICBjb25zdCBjb3JuZXJzID0gWwogICAgICAgICAgICAgIHsgcmE6IHRoaXMuZmllbGREYXRhLnJhMCwgZGVjOiB0aGlzLmZpZWxkRGF0YS5kZWMwIH0sCiAgICAgICAgICAgICAgeyByYTogdGhpcy5maWVsZERhdGEucmExLCBkZWM6IHRoaXMuZmllbGREYXRhLmRlYzEgfSwKICAgICAgICAgICAgICB7IHJhOiB0aGlzLmZpZWxkRGF0YS5yYTIsIGRlYzogdGhpcy5maWVsZERhdGEuZGVjMiB9LAogICAgICAgICAgICAgIHsgcmE6IHRoaXMuZmllbGREYXRhLnJhMywgZGVjOiB0aGlzLmZpZWxkRGF0YS5kZWMzIH0sCiAgICAgICAgICAgIF0KICAgICAgICAgICAgZm9yIChjb25zdCBjIG9mIGNvcm5lcnMpIHsKICAgICAgICAgICAgICBtYXhEeCA9IE1hdGgubWF4KG1heER4LCBNYXRoLmFicyh0aGlzLm5vcm1hbGl6ZVJhRGVsdGEoYy5yYSAtIGN4KSkpCiAgICAgICAgICAgICAgbWF4RHkgPSBNYXRoLm1heChtYXhEeSwgTWF0aC5hYnMoYy5kZWMgLSBjeSkpCiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgaWYgKG1heER4ID09PSAwICYmIG1heER5ID09PSAwKSByZXR1cm4gNDAKICAgICAgICBjb25zdCB3ID0gdGhpcy5vdmVybGF5TW9kZSA9PT0gJ3dpbmRvd2VkJyA/IHRoaXMuYmFzZUNhbnZhc0xvZ2ljYWxTaXplLndpZHRoIDogY2FudmFzLmNsaWVudFdpZHRoCiAgICAgICAgY29uc3QgaCA9IHRoaXMub3ZlcmxheU1vZGUgPT09ICd3aW5kb3dlZCcgPyB0aGlzLmJhc2VDYW52YXNMb2dpY2FsU2l6ZS5oZWlnaHQgOiBjYW52YXMuY2xpZW50SGVpZ2h0CiAgICAgICAgLy8g5Zu65a6a5YOP57Sg5YaF6L656Led77yM6ICD6JmR566t5aS06ZW/5bqm77yIOHB477yJ5LiO54K55Y2K5b6E77yINHB477yJCiAgICAgICAgY29uc3QgYXJyb3dIZWFkID0gOCwgcG9pbnRSID0gNAogICAgICAgIGNvbnN0IHBpeGVsUGFkZGluZyA9IDMyICsgYXJyb3dIZWFkICsgcG9pbnRSCiAgICAgICAgY29uc3QgaGFsZlcgPSBNYXRoLm1heCg2MCwgKHcgLyAyKSAtIHBpeGVsUGFkZGluZykKICAgICAgICBjb25zdCBoYWxmSCA9IE1hdGgubWF4KDUwLCAoaCAvIDIpIC0gcGl4ZWxQYWRkaW5nKQogICAgICAgIC8vIOiuqeacgOi/nOeCueiQveWcqOS4reW/g+WIsOi+ueeVjOi3neemu+eahCA4MCUg5aSE77yI55WZ6Laz5Y+v6KeG5L2Z6YeP77yJCiAgICAgICAgY29uc3QgbWFyZ2luID0gMC44CiAgICAgICAgbGV0IHNjYWxlID0gTWF0aC5tYXgoNSwgTWF0aC5taW4oKGhhbGZXICogbWFyZ2luKSAvIChtYXhEeCB8fCAxZS02KSwgKGhhbGZIICogbWFyZ2luKSAvIChtYXhEeSB8fCAxZS02KSkpCiAgICAgICAgLy8g5LqM5qyh5qCh6aqM77ya5oyJ6K+l5q+U5L6L6L2s5o2i5LiA5qyh77yM56Gu5L+d56Gu5a6e5pyq6LaK55WM77yM5aaC6LaK55WM5YaN57yp5bCP5q+U5L6LCiAgICAgICAgY29uc3QgcGFkID0gcGl4ZWxQYWRkaW5nCiAgICAgICAgY29uc3QgY3hQeCA9IHcgLyAyLCBjeVB4ID0gaCAvIDIKICAgICAgICBsZXQgbWF4QWJzUHhYID0gMCwgbWF4QWJzUHhZID0gMAogICAgICAgIGNvbnN0IGNvbGxlY3QgPSBbXQogICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5yYXdUcmFqZWN0b3J5UG9pbnRzLmxlbmd0aDsgaSsrKSBjb2xsZWN0LnB1c2godGhpcy5yYXdUcmFqZWN0b3J5UG9pbnRzW2ldKQogICAgICAgIGlmICh0aGlzLm92ZXJsYXlNb2RlID09PSAnZnVsbHNjcmVlbicgJiYgdGhpcy5maWVsZERhdGEgJiYgTnVtYmVyLmlzRmluaXRlKHRoaXMuZmllbGREYXRhLnJhMCkpIHsKICAgICAgICAgIGNvbGxlY3QucHVzaCh7IHJhOiB0aGlzLmZpZWxkRGF0YS5yYTAsIGRlYzogdGhpcy5maWVsZERhdGEuZGVjMCB9KQogICAgICAgICAgY29sbGVjdC5wdXNoKHsgcmE6IHRoaXMuZmllbGREYXRhLnJhMSwgZGVjOiB0aGlzLmZpZWxkRGF0YS5kZWMxIH0pCiAgICAgICAgICBjb2xsZWN0LnB1c2goeyByYTogdGhpcy5maWVsZERhdGEucmEyLCBkZWM6IHRoaXMuZmllbGREYXRhLmRlYzIgfSkKICAgICAgICAgIGNvbGxlY3QucHVzaCh7IHJhOiB0aGlzLmZpZWxkRGF0YS5yYTMsIGRlYzogdGhpcy5maWVsZERhdGEuZGVjMyB9KQogICAgICAgIH0KICAgICAgICBmb3IgKGNvbnN0IHAgb2YgY29sbGVjdCkgewogICAgICAgICAgY29uc3QgZHhEZWcgPSB0aGlzLm5vcm1hbGl6ZVJhRGVsdGEocC5yYSAtIGN4KQogICAgICAgICAgY29uc3QgZHlEZWcgPSAocC5kZWMgLSBjeSkKICAgICAgICAgIG1heEFic1B4WCA9IE1hdGgubWF4KG1heEFic1B4WCwgTWF0aC5hYnMoZHhEZWcgKiBzY2FsZSkpCiAgICAgICAgICBtYXhBYnNQeFkgPSBNYXRoLm1heChtYXhBYnNQeFksIE1hdGguYWJzKGR5RGVnICogc2NhbGUpKQogICAgICAgIH0KICAgICAgICBjb25zdCBhbGxvd2VkWCA9IGhhbGZXIC0gcGFkCiAgICAgICAgY29uc3QgYWxsb3dlZFkgPSBoYWxmSCAtIHBhZAogICAgICAgIGNvbnN0IGFkaiA9IE1hdGgubWluKDEsIGFsbG93ZWRYIC8gKG1heEFic1B4WCB8fCAxZS02KSwgYWxsb3dlZFkgLyAobWF4QWJzUHhZIHx8IDFlLTYpKQogICAgICAgIHNjYWxlICo9IGFkagogICAgICAgIHJldHVybiBzY2FsZQogICAgICB9LAogICAgICByZWRyYXdUcmFqZWN0b3J5KCkgewogICAgICAgIGlmICghdGhpcy5zaG93VHJhamVjdG9yeU92ZXJsYXkgfHwgIXRoaXMudGFyZ2V0UmF3UG9zaXRpb24pIHJldHVybgogICAgICAgIHRoaXMuaW5pdFRyYWplY3RvcnlDYW52YXMoKQogICAgICAgIGNvbnN0IGNhbnZhcyA9IHRoaXMuJHJlZnMudHJhamVjdG9yeUNhbnZhcwogICAgICAgIGlmICghY2FudmFzKSByZXR1cm4KICAgICAgICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKQogICAgICAgIC8vIOmihOWFiOWwhuaJgOacieeCuei9rOaNouWIsOS4lueVjOWdkOagh++8jOW5tuWIneWni+WMluaYoOWwhAogICAgICAgIGNvbnN0IHJhd0FsbCA9IHRoaXMucmF3VHJhamVjdG9yeVBvaW50cwogICAgICAgIC8vIOS9v+eUqOWFqOmHj+eCueW6j+WIl+WIneWni+WMli/mianlsZXop4blm77mmKDlsITvvIznoa7kv53ot6ggMC8zNjAg5pe25bGV5byA5pa55ZCR5LiA6Ie0CiAgICAgICAgY29uc3QgZW5zdXJlUmF3ID0gcmF3QWxsCiAgICAgICAgY29uc3Qgd29ybGRTZXEgPSB0aGlzLm1ha2VXb3JsZFNlcShlbnN1cmVSYXcpCiAgICAgICAgLy8g5b2T5a2Y5Zyo6KeG5Zy65pWw5o2u5pe277yM5Lmf5bCG6KeG5Zy65Zub6KeS57qz5YWl5Yid5aeL5pig5bCE77yM6Ziy5q2i55uu5qCH6ZmE6L+R5bC65bqm6L+H5bCP5a+86Ie06KeG5Zy657uY5Yi25byC5bi4CiAgICAgICAgbGV0IGZvdldvcmxkID0gW10KICAgICAgICBpZiAodGhpcy5maWVsZERhdGEpIHsKICAgICAgICAgIGNvbnN0IHRpbWVSZWYgPSByYXdBbGwubGVuZ3RoID8gbmV3IERhdGUocmF3QWxsW3Jhd0FsbC5sZW5ndGggLSAxXS50IHx8IERhdGUubm93KCkpIDogbmV3IERhdGUoKQogICAgICAgICAgY29uc3QgY29ybmVycyA9IFsKICAgICAgICAgICAgeyByYTogdGhpcy5maWVsZERhdGEucmEwLCBkZWM6IHRoaXMuZmllbGREYXRhLmRlYzAgfSwKICAgICAgICAgICAgeyByYTogdGhpcy5maWVsZERhdGEucmExLCBkZWM6IHRoaXMuZmllbGREYXRhLmRlYzEgfSwKICAgICAgICAgICAgeyByYTogdGhpcy5maWVsZERhdGEucmEyLCBkZWM6IHRoaXMuZmllbGREYXRhLmRlYzIgfSwKICAgICAgICAgICAgeyByYTogdGhpcy5maWVsZERhdGEucmEzLCBkZWM6IHRoaXMuZmllbGREYXRhLmRlYzMgfSwKICAgICAgICAgIF0KICAgICAgICAgIGZvdldvcmxkID0gY29ybmVycy5tYXAoYyA9PiB0aGlzLndvcmxkRm9yUG9pbnQoYy5yYSwgYy5kZWMsIHRpbWVSZWYpKQogICAgICAgIH0KICAgICAgICB0aGlzLmVuc3VyZVZpZXdNYXBwaW5nSW5pdGlhbGl6ZWQod29ybGRTZXEuY29uY2F0KGZvdldvcmxkKSkKICAgICAgICAvLyDpgInmi6nnu5jliLbnmoTmlbDmja7pm4bvvJrlhajlsY895YWo6YOo77yb56qX5Y+jPeacgOaWsOS4ieS4qu+8jOS9huS/neaMgeWxleW8gOmUmueCueeos+WumgogICAgICAgIGNvbnN0IHJhdyA9IHRoaXMub3ZlcmxheU1vZGUgPT09ICd3aW5kb3dlZCcgPyByYXdBbGwuc2xpY2UoLTMpIDogcmF3QWxsCiAgICAgICAgY29uc3Qgd29ybGQgPSB0aGlzLm1ha2VXb3JsZFNlcShyYXcpCiAgICAgICAgLy8g5YWI6LWw5LiA6YGN5pu05paw5q+U5L6LL+i+ueeVjO+8jOS4jee7mOWItu+8jOehruS/neS4i+a4uOWbvuWFg+WdkOagh+ezu+S4gOiHtAogICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgd29ybGQubGVuZ3RoOyBpKyspIHRoaXMubWF5YmVFeHBhbmRWaWV3Rm9yUG9pbnQod29ybGRbaV0ueCwgd29ybGRbaV0ueSkKICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZvdldvcmxkLmxlbmd0aDsgaSsrKSB0aGlzLm1heWJlRXhwYW5kVmlld0ZvclBvaW50KGZvdldvcmxkW2ldLngsIGZvdldvcmxkW2ldLnkpCiAgICAgICAgLy8g5YaN57uY6IOM5pmvL+ebruagh+eOrwogICAgICAgIHRoaXMuZHJhd1RhcmdldE1hcmtlcigpCiAgICAgICAgLy8g57uY5Yi26L2o6L+5CiAgICAgICAgdGhpcy50cmFqZWN0b3J5UG9pbnRzID0gW10KICAgICAgICBsZXQgcHJldlB0ID0gbnVsbAogICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgd29ybGQubGVuZ3RoOyBpKyspIHsKICAgICAgICAgIGNvbnN0IHNwdCA9IHRoaXMuc2NyZWVuRm9yV29ybGQod29ybGRbaV0ueCwgd29ybGRbaV0ueSkKICAgICAgICAgIGNvbnN0IHB4ID0gc3B0LngKICAgICAgICAgIGNvbnN0IHB5ID0gc3B0LnkKICAgICAgICAgIGNvbnN0IGlzTGFzdCA9IGkgPT09IHJhdy5sZW5ndGggLSAxCiAgICAgICAgICBpZiAoIWlzTGFzdCkgewogICAgICAgICAgICB0aGlzLmRyYXdQb2ludChweCwgcHksICcjRkZENTRGJykKICAgICAgICAgICAgaWYgKHByZXZQdCkgdGhpcy5kcmF3QXJyb3cocHJldlB0LngsIHByZXZQdC55LCBweCwgcHksICcjRkZENTRGJykKICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIC8vIOW9k+WJjeS9jee9ruS7peepuuW/g+WchuihqOekuu+8iOWNiuW+hOe6piAxIOinkuWIhu+8iQogICAgICAgICAgICBjb25zdCBhcmNtaW4gPSAodGhpcy5jYWxpYnJhdGlvbkNpcmNsZUFyY21pbiB8fCAxKQogICAgICAgICAgICBjb25zdCByUHggPSBNYXRoLm1heCg0LCAoYXJjbWluIC8gNjApICogKCh0aGlzLmN1cnJlbnRQeFBlckRlZyB8fCA0MCkpKQogICAgICAgICAgICB0aGlzLmRyYXdIb2xsb3dDaXJjbGUocHgsIHB5LCByUHgsICcjMDBCRkZGJywgMikKICAgICAgICAgICAgLy8g5ZyI5L2P55uu5qCH77yI55uu5qCH5Zyo5LiW55WM5Y6f54K577yJ77yM5b2T5ZyG5b+D5Yiw5Y6f54K555qE6Led56a75bCP5LqO5Y2K5b6E5pe26KeG5Li65a6M5oiQCiAgICAgICAgICAgIGNvbnN0IHJEZWcgPSBNYXRoLmh5cG90KHdvcmxkW2ldLngsIHdvcmxkW2ldLnkpCiAgICAgICAgICAgIGlmIChyRGVnIDw9IChhcmNtaW4gLyA2MCkpIHsKICAgICAgICAgICAgICBpZiAoIXRoaXMuaXNQb2xhckFsaWduZWQpIHsKICAgICAgICAgICAgICAgIHRoaXMuaXNQb2xhckFsaWduZWQgPSB0cnVlCiAgICAgICAgICAgICAgICB0aGlzLmFkZExvZyh0aGlzLiR0KCdQb2xhciBBbGlnbm1lbnQgQ29tcGxldGVkJyksICdzdWNjZXNzJykKICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KICAgICAgICAgICAgaWYgKHByZXZQdCkgdGhpcy5kcmF3QXJyb3cocHJldlB0LngsIHByZXZQdC55LCBweCwgcHksICcjRkZENTRGJykKICAgICAgICAgIH0KICAgICAgICAgIHByZXZQdCA9IHsgeDogcHgsIHk6IHB5IH0KICAgICAgICAgIHRoaXMudHJhamVjdG9yeVBvaW50cy5wdXNoKHsgeDogcHgsIHk6IHB5IH0pCiAgICAgICAgfQogICAgICAgIC8vIOi+heWKqe+8muebruagh+WIsOacgOWQjuauteeahOWegue6v++8iOiZmue6v++8iQogICAgICAgIHRoaXMuZHJhd1BlcnBlbmRpY3VsYXJBdXhMaW5lKCkKICAgICAgfSwKICAgICAgZHJhd0hvbGxvd0NpcmNsZSh4LCB5LCByID0gOCwgY29sb3IgPSAnI0ZGRkZGRicsIGxpbmVXaWR0aCA9IDIpIHsKICAgICAgICBjb25zdCBjYW52YXMgPSB0aGlzLiRyZWZzLnRyYWplY3RvcnlDYW52YXMKICAgICAgICBpZiAoIWNhbnZhcykgcmV0dXJuCiAgICAgICAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJykKICAgICAgICBjdHguc2F2ZSgpCiAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gY29sb3IKICAgICAgICBjdHgubGluZVdpZHRoID0gbGluZVdpZHRoCiAgICAgICAgY3R4LmJlZ2luUGF0aCgpCiAgICAgICAgY3R4LmFyYyh4LCB5LCByLCAwLCBNYXRoLlBJICogMikKICAgICAgICBjdHguc3Ryb2tlKCkKICAgICAgICBjdHgucmVzdG9yZSgpCiAgICAgIH0sCiAgICAgIC8vIEZvViDnu5jliLblt7LkuI3lho3pnIDopoEKCiAgICAgIHJlc2V0Q2FsaWJyYXRpb24oKSB7CiAgICAgICAgLy8g5L2/55So57uf5LiA55qE5YaF5a2Y5riF55CG5pa55rOVCiAgICAgICAgdGhpcy5jbGVhckNhY2hlZERhdGEoKQoKICAgICAgICB0aGlzLmFkZExvZyh0aGlzLiR0KCdDYWxpYnJhdGlvbiBEYXRhIFJlc2V0JyksICdpbmZvJykKICAgICAgICAvLyB0aGlzLiRidXMuJGVtaXQoJ0FwcFNlbmRNZXNzYWdlJywgJ1Z1ZV9Db21tYW5kJywgJ1Jlc2V0QXV0b1BvbGFyQWxpZ25tZW50JykKICAgICAgICB0aGlzLiRidXMuJGVtaXQoJ0NsZWFyQ2FsaWJyYXRpb25Qb2ludHMnKQogICAgICAgIHRoaXMuJGJ1cy4kZW1pdCgnQ2xlYXJTdGF0dXNUZXh0RnJvbVN0YXJNYXAnKQogICAgICAgIC8vIOa4heepuui9qOi/uQogICAgICAgIHRoaXMucmF3VHJhamVjdG9yeVBvaW50cyA9IFtdCiAgICAgICAgdGhpcy50cmFqZWN0b3J5UG9pbnRzID0gW10KICAgICAgICB0aGlzLmxhc3RSYXdQb3NpdGlvbiA9IG51bGwKICAgICAgICB0aGlzLnRhcmdldFJhd1Bvc2l0aW9uID0gbnVsbAogICAgICB9LAoKICAgICAgcmVzdG9yZUNhbGlicmF0aW9uKCkgewogICAgICAgIHRoaXMuYWRkTG9nKHRoaXMuJHQoJ0NhbGlicmF0aW9uIERhdGEgUmVzdG9yZWQnKSwgJ3N1Y2Nlc3MnKQogICAgICAgIHRoaXMuJGJ1cy4kZW1pdCgnQXBwU2VuZE1lc3NhZ2UnLCAnVnVlX0NvbW1hbmQnLCAnUmVzdG9yZUF1dG9Qb2xhckFsaWdubWVudCcpCiAgICAgIH0sCgogICAgICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09CiAgICAgIC8vIOagoeWHhuaOp+WItuaWueazlQogICAgICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09CiAgICAgIHN0YXJ0QXV0b0NhbGlicmF0aW9uKCkgewogICAgICAgIGlmICghdGhpcy5pc0Nvbm5lY3RlZCkgewogICAgICAgICAgdGhpcy5hZGRMb2codGhpcy4kdCgnRXJyb3I6IE1vdW50IE5vdCBDb25uZWN0ZWQnKSwgJ2Vycm9yJykKICAgICAgICAgIHJldHVybgogICAgICAgIH0KICAgICAgICBpZiAodGhpcy5pc0NhbGlicmF0aW9uUnVubmluZykgewogICAgICAgICAgdGhpcy5zdG9wQXV0b0NhbGlicmF0aW9uKCkKICAgICAgICAgIHJldHVybgogICAgICAgIH0KICAgICAgICB0aGlzLmlzQ2FsaWJyYXRpb25SdW5uaW5nID0gdHJ1ZQogICAgICAgIHRoaXMucmVzZXRDYWxpYnJhdGlvbigpCiAgICAgICAgdGhpcy5hZGRMb2codGhpcy4kdCgnU3RhcnRpbmcgQXV0byBDYWxpYnJhdGlvbicpLCAnaW5mbycpCiAgICAgICAgdGhpcy4kYnVzLiRlbWl0KCdBcHBTZW5kTWVzc2FnZScsICdWdWVfQ29tbWFuZCcsICdTdGFydEF1dG9Qb2xhckFsaWdubWVudCcpCiAgICAgIH0sCgogICAgICBzdG9wQXV0b0NhbGlicmF0aW9uKCkgewogICAgICAgIHRoaXMuaXNDYWxpYnJhdGlvblJ1bm5pbmcgPSBmYWxzZQogICAgICAgIHRoaXMuYWRkTG9nKHRoaXMuJHQoJ0F1dG8gQ2FsaWJyYXRpb24gU3RvcHBlZCcpLCAnd2FybmluZycpCiAgICAgICAgdGhpcy4kYnVzLiRlbWl0KCdBcHBTZW5kTWVzc2FnZScsICdWdWVfQ29tbWFuZCcsICdTdG9wQXV0b1BvbGFyQWxpZ25tZW50JykKICAgICAgfSwKICAgICAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PQogICAgICAvLyDop4blnLrmlbDmja7lpITnkIbmlrnms5UKICAgICAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PQogICAgICB1cGRhdGVGaWVsZERhdGEoZGF0YSkgewogICAgICAgIGlmIChkYXRhICYmIEFycmF5LmlzQXJyYXkoZGF0YSkgJiYgZGF0YS5sZW5ndGggPj0gMTIpIHsgLy8g5L+u5pS56ZW/5bqm5qOA5p+l77yM56Gu5L+d5YyF5ZCr5YGH5p6B6L205pWw5o2uCiAgICAgICAgICBjb25zdCBpc1ZhbGlkRGF0YSA9IGRhdGEuZXZlcnkodmFsID0+IHR5cGVvZiB2YWwgPT09ICdudW1iZXInICYmICFpc05hTih2YWwpKQogICAgICAgICAgaWYgKCFpc1ZhbGlkRGF0YSkgewogICAgICAgICAgICB0aGlzLmFkZExvZyh0aGlzLiR0KCdXYXJuaW5nOiBJbnZhbGlkIEZpZWxkIERhdGEgUmVjZWl2ZWQnKSwgJ3dhcm5pbmcnKQogICAgICAgICAgICByZXR1cm4KICAgICAgICAgIH0KCiAgICAgICAgICB0aGlzLmZpZWxkRGF0YSA9IHsKICAgICAgICAgICAgcmE6IGRhdGFbMF0sCiAgICAgICAgICAgIGRlYzogZGF0YVsxXSwKICAgICAgICAgICAgcmEwOiBkYXRhWzJdLAogICAgICAgICAgICBkZWMwOiBkYXRhWzNdLAogICAgICAgICAgICByYTE6IGRhdGFbNF0sCiAgICAgICAgICAgIGRlYzE6IGRhdGFbNV0sCiAgICAgICAgICAgIHJhMjogZGF0YVs2XSwKICAgICAgICAgICAgZGVjMjogZGF0YVs3XSwKICAgICAgICAgICAgcmEzOiBkYXRhWzhdLAogICAgICAgICAgICBkZWMzOiBkYXRhWzldLAogICAgICAgICAgICB0YXJnZXRyYTogZGF0YVsxMF0sCiAgICAgICAgICAgIHRhcmdldGRlYzogZGF0YVsxMV0sCiAgICAgICAgICAgIGZha2VQb2xhclJBOiBkYXRhWzEyXSwKICAgICAgICAgICAgZmFrZVBvbGFyREVDOiBkYXRhWzEzXSwKICAgICAgICAgICAgcmVhbFBvbGFyUkE6IGRhdGFbMTRdLAogICAgICAgICAgICByZWFsUG9sYXJERUM6IGRhdGFbMTVdCiAgICAgICAgICB9CgogICAgICAgICAgLy8g5L+d5a2Y5LiK5LiA5qyh5L2N572u77yI5Zyo5pu05paw5b2T5YmN5L2N572u5LmL5YmN77yJCiAgICAgICAgICBpZiAodGhpcy5jdXJyZW50UG9zaXRpb24ucmEgIT09ICcwMGggMDBtIDAwcycpIHsKICAgICAgICAgICAgdGhpcy5wcmV2aW91c1Bvc2l0aW9uID0geyAuLi50aGlzLmN1cnJlbnRQb3NpdGlvbiB9CiAgICAgICAgICB9CgogICAgICAgICAgLy8g5pu05paw5b2T5YmN5L2N572uCiAgICAgICAgICB0aGlzLmN1cnJlbnRQb3NpdGlvbiA9IHsKICAgICAgICAgICAgcmE6IHRoaXMuZm9ybWF0Q29vcmRpbmF0ZShkYXRhWzBdLCAncmEnKSwKICAgICAgICAgICAgZGVjOiB0aGlzLmZvcm1hdENvb3JkaW5hdGUoZGF0YVsxXSwgJ2RlYycpCiAgICAgICAgICB9CgogICAgICAgICAgLy8gPT09IOi9qOi/uemAu+i+keaMguaOpSA9PT0KICAgICAgICAgIC8vIOS9v+eUqOWOn+Wni+inkuW6pu+8iOWBh+iuviBkYXRhWzBdLCBkYXRhWzFdLCBkYXRhWzEwXSwgZGF0YVsxMV0g5Li65bqm5Y2V5L2N77yJCiAgICAgICAgICBjb25zdCByYXdSYSA9IGRhdGFbMF0KICAgICAgICAgIGNvbnN0IHJhd0RlYyA9IGRhdGFbMV0KICAgICAgICAgIC8vIOWcqOi/m+WFpeiwg+aVtOmYtuaute+8iOebruagh+aPkOS+m++8ieaXtuWbuuWumuebruagh+eCue+8m+WQpuWImeS4jee7mOWItgogICAgICAgICAgaWYgKGRhdGFbMTBdICE9PSAtMSAmJiBkYXRhWzExXSAhPT0gLTEpIHsKICAgICAgICAgICAgaWYgKCF0aGlzLnRhcmdldFJhd1Bvc2l0aW9uIHx8ICh0aGlzLnRhcmdldFJhd1Bvc2l0aW9uLnJhICE9PSBkYXRhWzEwXSB8fCB0aGlzLnRhcmdldFJhd1Bvc2l0aW9uLmRlYyAhPT0gZGF0YVsxMV0pKSB7CiAgICAgICAgICAgICAgdGhpcy50YXJnZXRSYXdQb3NpdGlvbiA9IHsgcmE6IGRhdGFbMTBdLCBkZWM6IGRhdGFbMTFdIH0KICAgICAgICAgICAgICAvLyDph43nu5jku6Xnm67moIfngrnkuLrkuK3lv4MKICAgICAgICAgICAgICBpZiAodGhpcy5zaG93VHJhamVjdG9yeU92ZXJsYXkpIHRoaXMucmVkcmF3VHJhamVjdG9yeSgpCiAgICAgICAgICAgIH0KICAgICAgICAgICAgY29uc3QgcG9zQ2hhbmdlZCA9ICF0aGlzLmxhc3RSYXdQb3NpdGlvbiB8fCB0aGlzLmxhc3RSYXdQb3NpdGlvbi5yYSAhPT0gcmF3UmEgfHwgdGhpcy5sYXN0UmF3UG9zaXRpb24uZGVjICE9PSByYXdEZWMKICAgICAgICAgICAgaWYgKHBvc0NoYW5nZWQpIHsKICAgICAgICAgICAgICB0aGlzLmFwcGVuZFJhd1RyYWplY3RvcnlQb2ludChyYXdSYSwgcmF3RGVjLCBEYXRlLm5vdygpKQogICAgICAgICAgICAgIC8vIOaUueS4uuWFqOmHj+mHjee7mO+8iOehruS/neiHqumAguW6lOavlOS+i+WMheWQq+aJgOacieeCueOAgeW5tue7mOWItuinhuWcuuahhu+8iQogICAgICAgICAgICAgIGlmICh0aGlzLnNob3dUcmFqZWN0b3J5T3ZlcmxheSkgdGhpcy5yZWRyYXdUcmFqZWN0b3J5KCkKICAgICAgICAgICAgICB0aGlzLmxhc3RSYXdQb3NpdGlvbiA9IHsgcmE6IHJhd1JhLCBkZWM6IHJhd0RlYyB9CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KCiAgICAgICAgICBpZiAoZGF0YVsxMF0gPT09IC0xICYmIGRhdGFbMTFdID09PSAtMSkgewogICAgICAgICAgICAvLyDmoKHlh4bngrnmlLbpm4bpmLbmrrUKICAgICAgICAgICAgdGhpcy5jYWxpYnJhdGlvblBoYXNlID0gJ2NvbGxlY3RpbmcnCiAgICAgICAgICAgIGNvbnN0IHBvaW50TnVtYmVyID0gdGhpcy5jYWxpYnJhdGlvblBvaW50cy5sZW5ndGggKyAxCgogICAgICAgICAgICAvLyDmt7vliqDosIPor5Xkv6Hmga8KICAgICAgICAgICAgdGhpcy5hZGRMb2coYOWHhuWkh+aUtumbhuagoeWHhueCuSR7cG9pbnROdW1iZXJ977yM5b2T5YmN5bey5pyJJHt0aGlzLmNhbGlicmF0aW9uUG9pbnRzLmxlbmd0aH3kuKrngrlgLCAnaW5mbycpCgogICAgICAgICAgICB0cnkgewogICAgICAgICAgICAgIHRoaXMuZHJhd0NhbGlicmF0aW9uUG9pbnRQb2x5Z29uKGRhdGFbMF0sIGRhdGFbMV0sIHBvaW50TnVtYmVyLCB0aGlzLmZpZWxkRGF0YSkKICAgICAgICAgICAgICB0aGlzLmFkZExvZyh0aGlzLiR0KCdDYWxpYnJhdGlvbiBQb2ludCcsIFtwb2ludE51bWJlciwgZGF0YVswXS50b0ZpeGVkKDQpLCBkYXRhWzFdLnRvRml4ZWQoNCldKSwgJ2luZm8nKQoKICAgICAgICAgICAgICAvLyDkv53lrZjmoKHlh4bngrkgLSDpmZDliLbmnIDlpKfmlbDph48KICAgICAgICAgICAgICBpZiAodGhpcy5jYWxpYnJhdGlvblBvaW50cy5sZW5ndGggPCB0aGlzLm1heENhbGlicmF0aW9uUG9pbnRzKSB7CiAgICAgICAgICAgICAgICB0aGlzLmNhbGlicmF0aW9uUG9pbnRzLnB1c2goewogICAgICAgICAgICAgICAgICByYTogZGF0YVswXSwKICAgICAgICAgICAgICAgICAgZGVjOiBkYXRhWzFdLAogICAgICAgICAgICAgICAgICBpbmRleDogcG9pbnROdW1iZXIKICAgICAgICAgICAgICAgIH0pCiAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgIC8vIOWmguaenOi2hei/h+acgOWkp+aVsOmHj++8jOabv+aNouacgOaXp+eahOeCuQogICAgICAgICAgICAgICAgY29uc3Qgb2xkZXN0SW5kZXggPSAocG9pbnROdW1iZXIgLSAxKSAlIHRoaXMubWF4Q2FsaWJyYXRpb25Qb2ludHMKICAgICAgICAgICAgICAgIHRoaXMuY2FsaWJyYXRpb25Qb2ludHNbb2xkZXN0SW5kZXhdID0gewogICAgICAgICAgICAgICAgICByYTogZGF0YVswXSwKICAgICAgICAgICAgICAgICAgZGVjOiBkYXRhWzFdLAogICAgICAgICAgICAgICAgICBpbmRleDogcG9pbnROdW1iZXIKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICB9CgogICAgICAgICAgICAgIHRoaXMuYWRkTG9nKGDmoKHlh4bngrkke3BvaW50TnVtYmVyfeW3sua3u+WKoO+8jOeOsOWcqOaAu+WFseaciSR7dGhpcy5jYWxpYnJhdGlvblBvaW50cy5sZW5ndGh95Liq54K5YCwgJ2luZm8nKQoKICAgICAgICAgICAgICAvLyDlpoLmnpzmlLbpm4bkuoYz5Liq54K577yM6L+b5YWl6LCD5pW06Zi25q61CiAgICAgICAgICAgICAgaWYgKHRoaXMuY2FsaWJyYXRpb25Qb2ludHMubGVuZ3RoID09PSB0aGlzLm1heENhbGlicmF0aW9uUG9pbnRzKSB7CiAgICAgICAgICAgICAgICB0aGlzLmNhbGlicmF0aW9uUGhhc2UgPSAnYWRqdXN0aW5nJwogICAgICAgICAgICAgICAgdGhpcy5hZGRMb2codGhpcy4kdCgnVGhyZWUgY2FsaWJyYXRpb24gcG9pbnRzIGNvbGxlY3RlZCwgZW50ZXJpbmcgYWRqdXN0bWVudCBwaGFzZScpLCAnc3VjY2VzcycpCiAgICAgICAgICAgICAgfQogICAgICAgICAgICB9IGNhdGNoIChlcnJvcikgewogICAgICAgICAgICAgIHRoaXMuYWRkTG9nKHRoaXMuJHQoJ0Vycm9yIHByb2Nlc3NpbmcgY2FsaWJyYXRpb24gcG9pbnQnLCBbZXJyb3IubWVzc2FnZV0pLCAnZXJyb3InKQogICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ+WkhOeQhuagoeWHhueCuemUmeivr++8micsIGVycm9yKQogICAgICAgICAgICB9CiAgICAgICAgICB9IGVsc2UgaWYgKGRhdGFbMTBdICE9PSAtMSAmJiBkYXRhWzExXSAhPT0gLTEpIHsKICAgICAgICAgICAgLy8g6LCD5pW06Zi25q6177ya5pi+56S655uu5qCH5L2N572u5ZKM5YGH5p6B6L20CiAgICAgICAgICAgIHRoaXMuY2FsaWJyYXRpb25QaGFzZSA9ICdhZGp1c3RpbmcnCiAgICAgICAgICAgIHRoaXMudGFyZ2V0UG9pbnQgPSB7IHJhOiBkYXRhWzEwXSwgZGVjOiBkYXRhWzExXSB9CgogICAgICAgICAgICB0cnkgewogICAgICAgICAgICAgIC8vIOWFiOa4hemZpOaJgOacieS5i+WJjeeahOWFg+e0oAogICAgICAgICAgICAgIHRoaXMuYWRkTG9nKCfosIPmlbTmqKHlvI/vvJrlh4blpIfmuIXpmaTkuYvliY3nmoTmoKHlh4blhYPntKAnLCAnaW5mbycpCiAgICAgICAgICAgICAgdGhpcy4kYnVzLiRlbWl0KCdDbGVhckNhbGlicmF0aW9uUG9pbnRzJykKICAgICAgICAgICAgICB0aGlzLmFkZExvZygn6LCD5pW05qih5byP77ya5riF6Zmk5ZG95Luk5bey5Y+R6YCBJywgJ2luZm8nKQoKICAgICAgICAgICAgICAvLyDnu5jliLbmoKHlh4bngrnvvIjlpoLmnpzlt7LmlLbpm4Yz5Liq54K577yJCiAgICAgICAgICAgICAgaWYgKHRoaXMuY2FsaWJyYXRpb25Qb2ludHMubGVuZ3RoID09PSB0aGlzLm1heENhbGlicmF0aW9uUG9pbnRzKSB7CiAgICAgICAgICAgICAgICB0aGlzLmNhbGlicmF0aW9uUG9pbnRzLmZvckVhY2goKHBvaW50LCBpbmRleCkgPT4gewogICAgICAgICAgICAgICAgICBjb25zdCBwb2ludENvb3JkaW5hdGVzID0gdGhpcy5jYWxjdWxhdGVGaWVsZENvcm5lcnMocG9pbnQucmEsIHBvaW50LmRlYywgdGhpcy5maWVsZERhdGEsIGZhbHNlKQogICAgICAgICAgICAgICAgICBjb25zdCBwb2ludENvbG9yID0gewogICAgICAgICAgICAgICAgICAgIHN0cm9rZTogIiNGRkQ3MDAiLCAgICAgICAgLy8g6YeR6Imy6L655qGG77ya5qCh5YeG54K5CiAgICAgICAgICAgICAgICAgICAgc3Ryb2tlT3BhY2l0eTogMSwgICAgICAgICAvLyDovrnmoYbkuI3pgI/mmI7luqYKICAgICAgICAgICAgICAgICAgICBmaWxsOiAiI0ZGRDcwMCIsICAgICAgICAgIC8vIOmHkeiJsuWhq+WFhe+8muagoeWHhueCuQogICAgICAgICAgICAgICAgICAgIGZpbGxPcGFjaXR5OiAwLjMgICAgICAgICAgLy8g5aGr5YWF5LiN6YCP5piO5bqm77yI5Y2K6YCP5piO77yJCiAgICAgICAgICAgICAgICAgIH0KCiAgICAgICAgICAgICAgICAgIHRoaXMuJGJ1cy4kZW1pdCgnRHJhd0NhbGlicmF0aW9uUG9pbnRQb2x5Z29uJywgcG9pbnRDb29yZGluYXRlcywgcG9pbnRDb2xvciwKICAgICAgICAgICAgICAgICAgICBgQ2FsaWJyYXRpb25fUG9pbnRfJHtpbmRleCArIDF9YCwgYOagoeWHhueCuSR7aW5kZXggKyAxfWAsICIjRkZENzAwIikKICAgICAgICAgICAgICAgIH0pCiAgICAgICAgICAgICAgfQoKICAgICAgICAgICAgICAvLyDnu5jliLblvZPliY3kvY3nva7vvIjok53oibLvvIkKICAgICAgICAgICAgICBjb25zdCBjdXJyZW50Q29vcmRpbmF0ZXMgPSB0aGlzLmNhbGN1bGF0ZUZpZWxkQ29ybmVycyhkYXRhWzBdLCBkYXRhWzFdLCB0aGlzLmZpZWxkRGF0YSwgZmFsc2UpCiAgICAgICAgICAgICAgY29uc3QgY3VycmVudENvbG9yID0gewogICAgICAgICAgICAgICAgc3Ryb2tlOiAiIzAwQkZGRiIsICAgICAgICAvLyDok53oibLovrnmoYbvvJrlvZPliY3kvY3nva4KICAgICAgICAgICAgICAgIHN0cm9rZU9wYWNpdHk6IDEsICAgICAgICAgLy8g6L655qGG5LiN6YCP5piO5bqmCiAgICAgICAgICAgICAgICBmaWxsOiAiIzAwQkZGRiIsICAgICAgICAgIC8vIOiTneiJsuWhq+WFhe+8muW9k+WJjeS9jee9rgogICAgICAgICAgICAgICAgZmlsbE9wYWNpdHk6IDAuMyAgICAgICAgICAvLyDloavlhYXkuI3pgI/mmI7luqbvvIjljYrpgI/mmI7vvIkKICAgICAgICAgICAgICB9CgogICAgICAgICAgICAgIHRoaXMuJGJ1cy4kZW1pdCgnRHJhd0NhbGlicmF0aW9uUG9pbnRQb2x5Z29uJywgY3VycmVudENvb3JkaW5hdGVzLCBjdXJyZW50Q29sb3IsCiAgICAgICAgICAgICAgICAnQ3VycmVudF9Qb3NpdGlvbicsICflvZPliY3kvY3nva4nLCAiIzAwQkZGRiIpCgogICAgICAgICAgICAgIC8vIOe7mOWItuebruagh+eCue+8iOe7v+iJsuWchuW9ou+8iQogICAgICAgICAgICAgIGNvbnN0IHRhcmdldENvbG9yID0gewogICAgICAgICAgICAgICAgc3Ryb2tlOiAiIzRDQUY1MCIsICAgICAgICAvLyDnu7/oibLovrnmoYbvvJrnm67moIfngrkKICAgICAgICAgICAgICAgIHN0cm9rZU9wYWNpdHk6IDEsICAgICAgICAgLy8g6L655qGG5LiN6YCP5piO5bqmCiAgICAgICAgICAgICAgICBmaWxsOiAiIzRDQUY1MCIsICAgICAgICAgIC8vIOe7v+iJsuWhq+WFhe+8muebruagh+eCuQogICAgICAgICAgICAgICAgZmlsbE9wYWNpdHk6IDAuMyAgICAgICAgICAvLyDloavlhYXkuI3pgI/mmI7luqbvvIjljYrpgI/mmI7vvIkKICAgICAgICAgICAgICB9CgogICAgICAgICAgICAgIGNvbnN0IHsgYXosIGFsdCB9ID0gdGhpcy5lcXVhdG9yaWFsVG9Ib3Jpem9udGFsKGRhdGFbMTBdLCBkYXRhWzExXSwgbmV3IERhdGUoRGF0ZS5ub3coKSksIHRoaXMuJHN0b3JlLnN0YXRlLmN1cnJlbnRMb2NhdGlvbi5sYXQsIHRoaXMuJHN0b3JlLnN0YXRlLmN1cnJlbnRMb2NhdGlvbi5sbmcpCiAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ+W9k+WJjeS9jee9ruebruagh+eCuScsIGRhdGFbNl0sIGRhdGFbN10gKyAnIOi9rOWMluS4uuWcsOW5s+WdkOagh+S4uicgKyBheiArICcgJyArIGFsdCk7CiAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ+S9v+eUqOaXtumXtOWSjOWcsOeCuScsIG5ldyBEYXRlKERhdGUubm93KCkpLCAkc3RvcmUuc3RhdGUuY3VycmVudExvY2F0aW9uLmxhdCwgJHN0b3JlLnN0YXRlLmN1cnJlbnRMb2NhdGlvbi5sbmcpOwoKICAgICAgICAgICAgICB0aGlzLiRidXMuJGVtaXQoJ0RyYXdUYXJnZXRQb2ludENpcmNsZScsCiAgICAgICAgICAgICAgICBheiwKICAgICAgICAgICAgICAgIGFsdCwKICAgICAgICAgICAgICAgIHRhcmdldENvbG9yLAogICAgICAgICAgICAgICAgJ1RhcmdldF9Qb2ludCcsCiAgICAgICAgICAgICAgICAn55uu5qCH54K5JwogICAgICAgICAgICAgICkKCiAgICAgICAgICAgICAgLy8g57uY5Yi25YGH5p6B6L2077yI57Sr6Imy5ZyG5b2i77yJCiAgICAgICAgICAgICAgaWYgKGRhdGFbMTJdICE9PSAtMSAmJiBkYXRhWzEzXSAhPT0gLTEgJiYgIWlzTmFOKGRhdGFbMTJdKSAmJiAhaXNOYU4oZGF0YVsxM10pKSB7CiAgICAgICAgICAgICAgICBjb25zdCB7IGF6LCBhbHQgfSA9IHRoaXMuZXF1YXRvcmlhbFRvSG9yaXpvbnRhbChkYXRhWzEyXSwgZGF0YVsxM10sIG5ldyBEYXRlKERhdGUubm93KCkpLCB0aGlzLiRzdG9yZS5zdGF0ZS5jdXJyZW50TG9jYXRpb24ubGF0LCB0aGlzLiRzdG9yZS5zdGF0ZS5jdXJyZW50TG9jYXRpb24ubG5nKQogICAgICAgICAgICAgICAgdGhpcy5kcmF3RmFrZVBvbGFyQXhpcyhheiwgYWx0KQogICAgICAgICAgICAgIH0KCiAgICAgICAgICAgICAgdGhpcy5hZGRMb2coYOiwg+aVtOaooeW8j++8muW9k+WJjeS9jee9rigke2RhdGFbMF0udG9GaXhlZCg0KX0sICR7ZGF0YVsxXS50b0ZpeGVkKDQpfSkg55uu5qCH5L2N572uKCR7ZGF0YVs2XS50b0ZpeGVkKDQpfSwgJHtkYXRhWzddLnRvRml4ZWQoNCl9KSDlgYfmnoHovbQoJHtkYXRhWzhdLnRvRml4ZWQoNCl9LCAke2RhdGFbOV0udG9GaXhlZCg0KX0pYCwgJ2luZm8nKQogICAgICAgICAgICB9IGNhdGNoIChlcnJvcikgewogICAgICAgICAgICAgIHRoaXMuYWRkTG9nKHRoaXMuJHQoJ0Vycm9yIHByb2Nlc3NpbmcgYWRqdXN0bWVudCBkYXRhJywgW2Vycm9yLm1lc3NhZ2VdKSwgJ2Vycm9yJykKICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCflpITnkIbosIPmlbTmlbDmja7plJnor6/vvJonLCBlcnJvcikKICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICB0aGlzLmFkZExvZyh0aGlzLiR0KCdFcnJvcjogSW52YWxpZCBGaWVsZCBEYXRhIEZvcm1hdCcpLCAnZXJyb3InKQogICAgICAgIH0KICAgICAgfSwKCiAgICAgIC8vIOe7mOWItuagoeWHhueCuQogICAgICBkcmF3Q2FsaWJyYXRpb25Qb2ludFBvbHlnb24ocmEsIGRlYywgcG9pbnROdW1iZXIsIGZpZWxkRGF0YSkgewogICAgICAgIHRoaXMuYWRkTG9nKHRoaXMuJHQoJ0RyYXdpbmcgQ2FsaWJyYXRpb24gUG9pbnQnLCBbcG9pbnROdW1iZXIsIHJhLCBkZWNdKSwgJ2luZm8nKQoKICAgICAgICB0cnkgewogICAgICAgICAgY29uc3QgY29vcmRpbmF0ZXMgPSB0aGlzLmNhbGN1bGF0ZUZpZWxkQ29ybmVycyhyYSwgZGVjLCBmaWVsZERhdGEpCiAgICAgICAgICB0aGlzLmFkZExvZyh0aGlzLiR0KCdDYWxjdWxhdGVkIEZpZWxkIENvcm5lciBDb29yZGluYXRlcycsIFtKU09OLnN0cmluZ2lmeShjb29yZGluYXRlcyldKSwgJ2luZm8nKQoKICAgICAgICAgIC8vIOmqjOivgeWdkOagh+acieaViOaApwogICAgICAgICAgY29uc3QgdmFsaWRDb29yZGluYXRlcyA9IGNvb3JkaW5hdGVzLmV2ZXJ5KChjb29yZCwgaW5kZXgpID0+IHsKICAgICAgICAgICAgY29uc3QgaXNWYWxpZCA9IGNvb3JkICYmIHR5cGVvZiBjb29yZC5yYSA9PT0gJ251bWJlcicgJiYgdHlwZW9mIGNvb3JkLmRlYyA9PT0gJ251bWJlcicgJiYKICAgICAgICAgICAgICAhaXNOYU4oY29vcmQucmEpICYmICFpc05hTihjb29yZC5kZWMpICYmIGlzRmluaXRlKGNvb3JkLnJhKSAmJiBpc0Zpbml0ZShjb29yZC5kZWMpCiAgICAgICAgICAgIGlmICghaXNWYWxpZCkgewogICAgICAgICAgICAgIHRoaXMuYWRkTG9nKHRoaXMuJHQoJ1dhcm5pbmc6IEludmFsaWQgQ29vcmRpbmF0ZSBQb2ludCcsIFtpbmRleCwgSlNPTi5zdHJpbmdpZnkoY29vcmQpXSksICd3YXJuaW5nJykKICAgICAgICAgICAgfQogICAgICAgICAgICByZXR1cm4gaXNWYWxpZAogICAgICAgICAgfSkKCiAgICAgICAgICBpZiAoIXZhbGlkQ29vcmRpbmF0ZXMpIHsKICAgICAgICAgICAgdGhpcy5hZGRMb2codGhpcy4kdCgnSW52YWxpZCBGaWVsZCBDb29yZGluYXRlcycpLCAnZXJyb3InKQogICAgICAgICAgICByZXR1cm4KICAgICAgICAgIH0KCiAgICAgICAgICBjb25zdCBjb2xvciA9IHRoaXMuZ2V0Q2FsaWJyYXRpb25Qb2ludENvbG9yKCkKCiAgICAgICAgICAvLyDmt7vliqDmlofmnKzmoIfnrb4KICAgICAgICAgIGNvbnN0IGxhYmVsID0gYOagoeWHhueCuSR7cG9pbnROdW1iZXJ9YAogICAgICAgICAgY29uc3QgbGFiZWxDb2xvciA9ICIjRkZGRkZGIgoKICAgICAgICAgIHRoaXMuYWRkTG9nKHRoaXMuJHQoJ1NlbmRpbmcgRHJhdyBDYWxpYnJhdGlvbiBFdmVudCcsIFtwb2ludE51bWJlcl0pLCAnaW5mbycpCiAgICAgICAgICB0aGlzLiRidXMuJGVtaXQoJ0RyYXdDYWxpYnJhdGlvblBvaW50UG9seWdvbicsIGNvb3JkaW5hdGVzLCBjb2xvciwgYENhbGlicmF0aW9uXyR7cG9pbnROdW1iZXJ9YCwgbGFiZWwsIGxhYmVsQ29sb3IpCgogICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7CiAgICAgICAgICB0aGlzLmFkZExvZyh0aGlzLiR0KCdFcnJvciBEcmF3aW5nIENhbGlicmF0aW9uIFBvaW50JywgW2Vycm9yLm1lc3NhZ2VdKSwgJ2Vycm9yJykKICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ+e7mOWItuagoeWHhueCuemUmeivr++8micsIGVycm9yKQogICAgICAgIH0KICAgICAgfSwKCiAgICAgIC8vIOa4hemZpOaJgOacieagoeWHhueCuQogICAgICBjbGVhckNhbGlicmF0aW9uUG9pbnRzKCkgewogICAgICAgIHRoaXMuYWRkTG9nKHRoaXMuJHQoJ0NsZWFyaW5nIEFsbCBDYWxpYnJhdGlvbiBQb2ludHMnKSwgJ2luZm8nKQogICAgICAgIHRoaXMuJGJ1cy4kZW1pdCgnQ2xlYXJDYWxpYnJhdGlvblBvaW50cycpCiAgICAgICAgdGhpcy4kYnVzLiRlbWl0KCdDbGVhclN0YXR1c1RleHRGcm9tU3Rhck1hcCcpCiAgICAgIH0sCgogICAgICAvKioKICAgICAgICog57uY5Yi25p6B6L205qCh5YeG6LCD5pW054K5CiAgICAgICAqIOWcqOaYn+WbvuS4iue7mOWItuW9k+WJjeS9jee9ruOAgeebruagh+S9jee9ruOAgeagoeWHhueCueetieWFs+mUruS9jee9ruagh+iusAogICAgICAgKiBAcGFyYW0ge251bWJlcn0gY3VycmVudFJhIC0g5b2T5YmN6LWk57uP5L2N572uCiAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjdXJyZW50RGVjIC0g5b2T5YmN6LWk57qs5L2N572uICAKICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHRhcmdldFJhIC0g55uu5qCH6LWk57uP5L2N572uCiAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0YXJnZXREZWMgLSDnm67moIfotaTnuqzkvY3nva4KICAgICAgICogQHBhcmFtIHtvYmplY3R9IGZpZWxkRGF0YSAtIOinhuWcuuaVsOaNru+8iOWMheWQq+inhuWcuui+ueeVjOS/oeaBr++8iQogICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGlzVGltZXJVcGRhdGUgLSDmmK/lkKbkuLrlrprml7blmajmm7TmlrDvvIjnlKjkuo7ljLrliIbmiYvliqjmm7TmlrDlkozoh6rliqjmm7TmlrDvvIkKICAgICAgICovCiAgICAgIGRyYXdBZGp1c3RtZW50UG9pbnRzKGN1cnJlbnRSYSwgY3VycmVudERlYywgdGFyZ2V0UmEsIHRhcmdldERlYywgZmllbGREYXRhLCBpc1RpbWVyVXBkYXRlID0gZmFsc2UpIHsKICAgICAgICAvLyDov5nkuKrmlrnms5XnjrDlnKjkuLvopoHnlKjkuo7moKHlh4bngrnmlLbpm4bpmLbmrrUKICAgICAgICAvLyDosIPmlbTpmLbmrrXnmoTnu5jliLbpgLvovpHlt7Lnu4/np7vliLB1cGRhdGVGaWVsZERhdGHmlrnms5XkuK0KCiAgICAgICAgdGhpcy5hZGRMb2codGhpcy4kdCgnU3RhcnRpbmcgRHJhdyBBZGp1c3RtZW50IFBvaW50cycsIFtjdXJyZW50UmEsIGN1cnJlbnREZWMsIHRhcmdldFJhLCB0YXJnZXREZWNdKSwgJ2luZm8nKQoKICAgICAgICB0cnkgewogICAgICAgICAgLy8g5Y+q5Zyo5qCh5YeG54K55pS26ZuG6Zi25q615L2/55So6L+Z5Liq5pa55rOVCiAgICAgICAgICBpZiAodGhpcy5jYWxpYnJhdGlvblBoYXNlID09PSAnY29sbGVjdGluZycpIHsKICAgICAgICAgICAgLy8g57uY5Yi25qCh5YeG54K55pS26ZuG6Zi25q6155qE6YC76L6RCiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRDb29yZGluYXRlcyA9IHRoaXMuY2FsY3VsYXRlRmllbGRDb3JuZXJzKGN1cnJlbnRSYSwgY3VycmVudERlYywgZmllbGREYXRhLCBmYWxzZSkKICAgICAgICAgICAgY29uc3QgY3VycmVudENvbG9yID0gewogICAgICAgICAgICAgIHN0cm9rZTogIiMwMEJGRkYiLCAgICAgICAgLy8g6JOd6Imy6L655qGG77ya5b2T5YmN5L2N572uCiAgICAgICAgICAgICAgc3Ryb2tlT3BhY2l0eTogMSwgICAgICAgICAvLyDovrnmoYbkuI3pgI/mmI7luqYKICAgICAgICAgICAgICBmaWxsOiAiIzAwQkZGRiIsICAgICAgICAgIC8vIOiTneiJsuWhq+WFhe+8muW9k+WJjeS9jee9rgogICAgICAgICAgICAgIGZpbGxPcGFjaXR5OiAwLjMgICAgICAgICAgLy8g5aGr5YWF5LiN6YCP5piO5bqm77yI5Y2K6YCP5piO77yJCiAgICAgICAgICAgIH0KCiAgICAgICAgICAgIHRoaXMuJGJ1cy4kZW1pdCgnRHJhd0NhbGlicmF0aW9uUG9pbnRQb2x5Z29uJywgY3VycmVudENvb3JkaW5hdGVzLCBjdXJyZW50Q29sb3IsCiAgICAgICAgICAgICAgJ0N1cnJlbnRfUG9zaXRpb24nLCAn5b2T5YmN5L2N572uJywgIiMwMEJGRkYiKQogICAgICAgICAgfQoKICAgICAgICB9IGNhdGNoIChlcnJvcikgewogICAgICAgICAgdGhpcy5hZGRMb2codGhpcy4kdCgnRXJyb3IgRHJhd2luZyBBZGp1c3RtZW50IFBvaW50cycsIFtlcnJvci5tZXNzYWdlXSksICdlcnJvcicpCiAgICAgICAgICBjb25zb2xlLmVycm9yKCfnu5jliLbosIPmlbTngrnplJnor6/vvJonLCBlcnJvcikKICAgICAgICB9CiAgICAgIH0sCgogICAgICAvKioKICAgICAgICog6K6h566X6KeG5Zy655qE5LqU5Liq6KeS54K55Z2Q5qCHCiAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjZW50ZXJSYSAtIOinhuWcuuS4reW/g+eahOi1pOe7j+WdkOaghwogICAgICAgKiBAcGFyYW0ge251bWJlcn0gY2VudGVyRGVjIC0g6KeG5Zy65Lit5b+D55qE6LWk57qs5Z2Q5qCHCiAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSBmaWVsZERhdGEgLSDop4blnLrmlbDmja7vvIjljIXlkKvop4blnLrovrnnlYzkv6Hmga/vvIkKICAgICAgICogQHBhcmFtIHtib29sZWFufSB1c2VEZWZhdWx0U2l6ZSAtIOaYr+WQpuS9v+eUqOm7mOiupOinhuWcuuWkp+Wwj++8iOeUqOS6juebruagh+eCueetieWbuuWumuS9jee9ru+8iQogICAgICAgKiBAcmV0dXJucyB7QXJyYXl9IOWMheWQqzXkuKrop5LngrnlnZDmoIfnmoTmlbDnu4TvvIznlKjkuo7nu5jliLblpJrovrnlvaIKICAgICAgICovCiAgICAgIGNhbGN1bGF0ZUZpZWxkQ29ybmVycyhjZW50ZXJSYSwgY2VudGVyRGVjLCBmaWVsZERhdGEsIHVzZURlZmF1bHRTaXplID0gZmFsc2UpIHsKICAgICAgICB0aGlzLmFkZExvZyh0aGlzLiR0KCdDYWxjdWxhdGluZyBGaWVsZCBDb3JuZXJzJywgW2NlbnRlclJhLCBjZW50ZXJEZWNdKSwgJ2luZm8nKQoKICAgICAgICAvLyDlpoLmnpzmjIflrprkvb/nlKjpu5jorqTlpKflsI/miJbogIXmsqHmnInop4blnLrmlbDmja7vvIzkvb/nlKjpu5jorqTnmoQwLjXluqbop4blnLrlpKflsI8KICAgICAgICBpZiAodXNlRGVmYXVsdFNpemUgfHwgIWZpZWxkRGF0YSkgewogICAgICAgICAgdGhpcy5hZGRMb2codGhpcy4kdCgnVXNpbmcgRGVmYXVsdCBGaWVsZCBTaXplOiAwLjUgRGVncmVlcycpLCAnaW5mbycpCiAgICAgICAgICBjb25zdCBmaWVsZFNpemUgPSAwLjUKICAgICAgICAgIGNvbnN0IGNvb3JkaW5hdGVzID0gWwogICAgICAgICAgICB7IHJhOiBjZW50ZXJSYSArIGZpZWxkU2l6ZSAvIDIsIGRlYzogY2VudGVyRGVjICsgZmllbGRTaXplIC8gMiB9LAogICAgICAgICAgICB7IHJhOiBjZW50ZXJSYSAtIGZpZWxkU2l6ZSAvIDIsIGRlYzogY2VudGVyRGVjICsgZmllbGRTaXplIC8gMiB9LAogICAgICAgICAgICB7IHJhOiBjZW50ZXJSYSAtIGZpZWxkU2l6ZSAvIDIsIGRlYzogY2VudGVyRGVjIC0gZmllbGRTaXplIC8gMiB9LAogICAgICAgICAgICB7IHJhOiBjZW50ZXJSYSArIGZpZWxkU2l6ZSAvIDIsIGRlYzogY2VudGVyRGVjIC0gZmllbGRTaXplIC8gMiB9LAogICAgICAgICAgICB7IHJhOiBjZW50ZXJSYSArIGZpZWxkU2l6ZSAvIDIsIGRlYzogY2VudGVyRGVjICsgZmllbGRTaXplIC8gMiB9CiAgICAgICAgICBdCiAgICAgICAgICB0aGlzLmFkZExvZyh0aGlzLiR0KCdEZWZhdWx0IEZpZWxkIENvcm5lcnMnLCBbSlNPTi5zdHJpbmdpZnkoY29vcmRpbmF0ZXMpXSksICdpbmZvJykKICAgICAgICAgIHJldHVybiBjb29yZGluYXRlcwogICAgICAgIH0KCiAgICAgICAgLy8g5aaC5p6c5pyJ6KeG5Zy65pWw5o2u5LiU5LiN5by65Yi25L2/55So6buY6K6k5aSn5bCP77yM5Z+65LqO5Lyg5YWl55qE5Lit5b+D54K55Z2Q5qCH6K6h566X6KeG5Zy66KeS54K5CiAgICAgICAgLy8g6L+Z56eN5oOF5Ya15Li76KaB55So5LqO5b2T5YmN5L2N572u55qE5pi+56S677yM6ZyA6KaB5Y+N5pig5a6e6ZmF55qE6KeG5Zy65aSn5bCPCiAgICAgICAgY29uc3QgeyByYTAsIGRlYzAsIHJhMSwgZGVjMSwgcmEyLCBkZWMyLCByYTMsIGRlYzMgfSA9IGZpZWxkRGF0YQoKICAgICAgICAvLyDorqHnrpfop4blnLrnmoTlrp7pmYXlpKflsI/vvIhSQeWSjERFQ+aWueWQkeeahOi3qOW6pu+8iQogICAKCiAgICAgICAgLy8g5Z+65LqO5Lyg5YWl55qE5Lit5b+D54K55Z2Q5qCH77yM6K6h566X6KeG5Zy655qE5LqU5Liq6KeS54K5CiAgICAgICAgY29uc3QgY29vcmRpbmF0ZXMgPSBbCiAgICAgICAgICB7IHJhOiByYTAsIGRlYzogZGVjMCB9LCAgICAgLy8g5Y+z5LiK6KeSCiAgICAgICAgICB7IHJhOiByYTEsIGRlYzogZGVjMSB9LCAgICAgLy8g5bem5LiK6KeSCiAgICAgICAgICB7IHJhOiByYTIsIGRlYzogZGVjMiB9LCAgICAgLy8g5bem5LiL6KeSCiAgICAgICAgICB7IHJhOiByYTMsIGRlYzogZGVjMyB9LCAgICAgLy8g5Y+z5LiL6KeSCiAgICAgICAgICB7IHJhOiByYTAsIGRlYzogZGVjMCB9ICAgICAgLy8g5Zue5Yiw5Y+z5LiK6KeS77yI6Zet5ZCI5aSa6L655b2i77yJCiAgICAgICAgXQoKICAgICAgICB0aGlzLmFkZExvZyh0aGlzLiR0KCdVc2luZyBGaWVsZCBEYXRhJywgW3JhMCwgZGVjMCwgcmExLCBkZWMxLCByYTIsIGRlYzIsIHJhMywgZGVjM10pLCAnaW5mbycpCiAgICAgICAgdGhpcy5hZGRMb2codGhpcy4kdCgnRmllbGQgQ29ybmVyIENhbGN1bGF0aW9uIFJlc3VsdCcsIFtKU09OLnN0cmluZ2lmeShjb29yZGluYXRlcyldKSwgJ2luZm8nKQogICAgICAgIHJldHVybiBjb29yZGluYXRlcwogICAgICB9LAoKCgogICAgICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09CiAgICAgIC8vIOagvOW8j+WMluaWueazlQogICAgICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09CiAgICAgIGZvcm1hdFRpbWUodGltZXN0YW1wKSB7CiAgICAgICAgaWYgKCF0aW1lc3RhbXApIHJldHVybiAnJwogICAgICAgIGNvbnN0IGRhdGUgPSBuZXcgRGF0ZSh0aW1lc3RhbXApCiAgICAgICAgcmV0dXJuIGRhdGUudG9Mb2NhbGVUaW1lU3RyaW5nKCd6aC1DTicsIHsKICAgICAgICAgIGhvdXIxMjogZmFsc2UsCiAgICAgICAgICBob3VyOiAnMi1kaWdpdCcsCiAgICAgICAgICBtaW51dGU6ICcyLWRpZ2l0JywKICAgICAgICAgIHNlY29uZDogJzItZGlnaXQnCiAgICAgICAgfSkKICAgICAgfSwKCiAgICAgIGZvcm1hdEFkanVzdG1lbnRWYWx1ZSh2YWx1ZSkgewogICAgICAgIGlmICghTnVtYmVyLmlzRmluaXRlKHZhbHVlKSkgcmV0dXJuIGAwLjAke3RoaXMudW5pdEdseXBoKHRoaXMuYWRqdXN0bWVudFVuaXQpfWAKICAgICAgICAvLyB2YWx1ZSDnmoTljZXkvY0gPSBwcm9wcy5hZGp1c3RtZW50VW5pdAogICAgICAgIGNvbnN0IHZhbEFyY21pbiA9IHRoaXMudW5pdFRvQXJjbWluKHZhbHVlLCB0aGlzLmFkanVzdG1lbnRVbml0KQogICAgICAgIC8vIOWxleekuuWNleS9jeS7jeeEtueUqCBwcm9wcy5hZGp1c3RtZW50VW5pdO+8iOS5n+WPr+aUueaIkOWbuuWumidhcmNtaW4n77yJCiAgICAgICAgcmV0dXJuIHRoaXMuZm9ybWF0V2l0aFVuaXQodmFsQXJjbWluLCB0aGlzLmFkanVzdG1lbnRVbml0LCAxKQogICAgICB9LAoKICAgICAgLy8g5qC85byP5YyW5Z2Q5qCH5pi+56S6CiAgICAgIGZvcm1hdENvb3JkaW5hdGUodmFsdWUsIHR5cGUpIHsKICAgICAgICBpZiAodmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHVuZGVmaW5lZCB8fCBpc05hTih2YWx1ZSkpIHsKICAgICAgICAgIHJldHVybiB0eXBlID09PSAncmEnID8gJzAwaCAwMG0gMDBzJyA6ICcrMDDCsCAwMFwnIDAwIicKICAgICAgICB9CgogICAgICAgIGlmICh0eXBlID09PSAncmEnKSB7CiAgICAgICAgICAvLyDmoLzlvI/ljJZSQeS4uuaXtuWIhuenkuagvOW8jwogICAgICAgICAgY29uc3QgaG91cnMgPSBNYXRoLmZsb29yKHZhbHVlIC8gMTUpCiAgICAgICAgICBjb25zdCBtaW51dGVzID0gTWF0aC5mbG9vcigodmFsdWUgJSAxNSkgKiA0KQogICAgICAgICAgY29uc3Qgc2Vjb25kcyA9IE1hdGguZmxvb3IoKCh2YWx1ZSAlIDE1KSAqIDQgLSBtaW51dGVzKSAqIDYwKQogICAgICAgICAgcmV0dXJuIGAke2hvdXJzLnRvU3RyaW5nKCkucGFkU3RhcnQoMiwgJzAnKX1oICR7bWludXRlcy50b1N0cmluZygpLnBhZFN0YXJ0KDIsICcwJyl9bSAke3NlY29uZHMudG9TdHJpbmcoKS5wYWRTdGFydCgyLCAnMCcpfXNgCiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIC8vIOagvOW8j+WMlkRFQ+S4uuW6puWIhuenkuagvOW8jwogICAgICAgICAgY29uc3Qgc2lnbiA9IHZhbHVlID49IDAgPyAnKycgOiAnLScKICAgICAgICAgIGNvbnN0IGFic1ZhbHVlID0gTWF0aC5hYnModmFsdWUpCiAgICAgICAgICBjb25zdCBkZWdyZWVzID0gTWF0aC5mbG9vcihhYnNWYWx1ZSkKICAgICAgICAgIGNvbnN0IG1pbnV0ZXMgPSBNYXRoLmZsb29yKChhYnNWYWx1ZSAtIGRlZ3JlZXMpICogNjApCiAgICAgICAgICBjb25zdCBzZWNvbmRzID0gTWF0aC5mbG9vcigoKGFic1ZhbHVlIC0gZGVncmVlcykgKiA2MCAtIG1pbnV0ZXMpICogNjApCiAgICAgICAgICByZXR1cm4gYCR7c2lnbn0ke2RlZ3JlZXMudG9TdHJpbmcoKS5wYWRTdGFydCgyLCAnMCcpfcKwICR7bWludXRlcy50b1N0cmluZygpLnBhZFN0YXJ0KDIsICcwJyl9JyAke3NlY29uZHMudG9TdHJpbmcoKS5wYWRTdGFydCgyLCAnMCcpfSJgCiAgICAgICAgfQogICAgICB9LAoKCiAgICAgIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0KICAgICAgLy8g6L6F5Yqp5pa55rOVCiAgICAgIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0KICAgICAgcGFyc2VDb29yZGluYXRlKHZhbHVlLCB0eXBlKSB7CiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHsKICAgICAgICAgIGlmICh0eXBlID09PSAncmEnKSB7CiAgICAgICAgICAgIC8vIOino+aekOaXtuWIhuenkuagvOW8jyAiMDBoIDAwbSAwMHMiCiAgICAgICAgICAgIGNvbnN0IG1hdGNoID0gdmFsdWUubWF0Y2goLyhcZCspaFxzKihcZCspbVxzKihcZCspcy8pCiAgICAgICAgICAgIGlmIChtYXRjaCkgewogICAgICAgICAgICAgIGNvbnN0IGhvdXJzID0gcGFyc2VJbnQobWF0Y2hbMV0pCiAgICAgICAgICAgICAgY29uc3QgbWludXRlcyA9IHBhcnNlSW50KG1hdGNoWzJdKQogICAgICAgICAgICAgIGNvbnN0IHNlY29uZHMgPSBwYXJzZUludChtYXRjaFszXSkKICAgICAgICAgICAgICByZXR1cm4gaG91cnMgKyBtaW51dGVzIC8gNjAgKyBzZWNvbmRzIC8gMzYwMAogICAgICAgICAgICB9CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAvLyDop6PmnpDluqbliIbnp5LmoLzlvI8gIiswMMKwIDAwJyAwMCIiCiAgICAgICAgICAgIGNvbnN0IG1hdGNoID0gdmFsdWUubWF0Y2goLyhbKy1dPykoXGQrKcKwXHMqKFxkKyknXHMqKFxkKykiLykKICAgICAgICAgICAgaWYgKG1hdGNoKSB7CiAgICAgICAgICAgICAgY29uc3Qgc2lnbiA9IG1hdGNoWzFdID09PSAnLScgPyAtMSA6IDEKICAgICAgICAgICAgICBjb25zdCBkZWdyZWVzID0gcGFyc2VJbnQobWF0Y2hbMl0pCiAgICAgICAgICAgICAgY29uc3QgbWludXRlcyA9IHBhcnNlSW50KG1hdGNoWzNdKQogICAgICAgICAgICAgIGNvbnN0IHNlY29uZHMgPSBwYXJzZUludChtYXRjaFs0XSkKICAgICAgICAgICAgICByZXR1cm4gc2lnbiAqIChkZWdyZWVzICsgbWludXRlcyAvIDYwICsgc2Vjb25kcyAvIDM2MDApCiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgcmV0dXJuIG51bGwKICAgICAgfSwKCiAgICAgIGFkZFN0YXR1c1RleHRUb1N0YXJNYXAoKSB7CiAgICAgICAgLy8g5re75Yqg54q25oCB5paH5pys5Yiw5pif5Zu+CiAgICAgICAgY29uc3Qgc3RhdHVzVGV4dCA9IHsKICAgICAgICAgIHRleHQ6IGDmnoHovbTmoKHlh4bosIPmlbTkuK0gLSDmoKHlh4bngrk6ICR7dGhpcy5jYWxpYnJhdGlvblBvaW50cy5sZW5ndGh9LzNgLAogICAgICAgICAgcG9zaXRpb246IHsgcmE6IHRoaXMuY3VycmVudFBvc2l0aW9uLnJhLCBkZWM6IHRoaXMuY3VycmVudFBvc2l0aW9uLmRlYyB9LAogICAgICAgICAgY29sb3I6ICIjRkZGRkZGIiwKICAgICAgICAgIGZvbnRTaXplOiAxNCwKICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogInJnYmEoMCwgMCwgMCwgMC43KSIKICAgICAgICB9CgogICAgICAgIC8vIOWPkemAgeeKtuaAgeaWh+acrOWIsOaYn+WbvgogICAgICAgIC8vIHRoaXMuJGJ1cy4kZW1pdCgnQWRkU3RhdHVzVGV4dFRvU3Rhck1hcCcsIHN0YXR1c1RleHQpCiAgICAgIH0sCgogICAgICBnZXRTdGVwQ2xhc3MoaW5kZXgpIHsKICAgICAgICAvLyDmoLnmja7ov5vluqbnmb7liIbmr5Tnoa7lrproioLngrnnirbmgIEKICAgICAgICBjb25zdCBwcm9ncmVzcyA9IHRoaXMucHJvZ3Jlc3NQZXJjZW50YWdlCgogICAgICAgIHN3aXRjaCAoaW5kZXgpIHsKICAgICAgICAgIGNhc2UgMDogLy8g5Yid5aeL5YyW6IqC54K5CiAgICAgICAgICAgIGlmIChwcm9ncmVzcyA+PSBQUk9HUkVTU19USFJFU0hPTERTLklOSVRJQUxJWkFUSU9OKSByZXR1cm4geyBjb21wbGV0ZWQ6IHRydWUgfQogICAgICAgICAgICBpZiAocHJvZ3Jlc3MgPj0gMCkgcmV0dXJuIHsgY3VycmVudDogdHJ1ZSB9CiAgICAgICAgICAgIHJldHVybiB7fQoKICAgICAgICAgIGNhc2UgMTogLy8g56ys5LiA5qyh5qCh5YeG6IqC54K5CiAgICAgICAgICAgIGlmIChwcm9ncmVzcyA+PSBQUk9HUkVTU19USFJFU0hPTERTLkZJUlNUX0NBTElCUkFUSU9OKSByZXR1cm4geyBjb21wbGV0ZWQ6IHRydWUgfQogICAgICAgICAgICBpZiAocHJvZ3Jlc3MgPj0gUFJPR1JFU1NfVEhSRVNIT0xEUy5JTklUSUFMSVpBVElPTikgcmV0dXJuIHsgY3VycmVudDogdHJ1ZSB9CiAgICAgICAgICAgIHJldHVybiB7fQoKICAgICAgICAgIGNhc2UgMjogLy8g56ys5LqM5qyh5qCh5YeG6IqC54K5CiAgICAgICAgICAgIGlmIChwcm9ncmVzcyA+PSBQUk9HUkVTU19USFJFU0hPTERTLlNFQ09ORF9DQUxJQlJBVElPTikgcmV0dXJuIHsgY29tcGxldGVkOiB0cnVlIH0KICAgICAgICAgICAgaWYgKHByb2dyZXNzID49IFBST0dSRVNTX1RIUkVTSE9MRFMuRklSU1RfQ0FMSUJSQVRJT04pIHJldHVybiB7IGN1cnJlbnQ6IHRydWUgfQogICAgICAgICAgICByZXR1cm4ge30KCiAgICAgICAgICBjYXNlIDM6IC8vIOesrOS4ieasoeagoeWHhuiKgueCuQogICAgICAgICAgICBpZiAocHJvZ3Jlc3MgPj0gUFJPR1JFU1NfVEhSRVNIT0xEUy5USElSRF9DQUxJQlJBVElPTikgcmV0dXJuIHsgY29tcGxldGVkOiB0cnVlIH0KICAgICAgICAgICAgaWYgKHByb2dyZXNzID49IFBST0dSRVNTX1RIUkVTSE9MRFMuU0VDT05EX0NBTElCUkFUSU9OKSByZXR1cm4geyBjdXJyZW50OiB0cnVlIH0KICAgICAgICAgICAgcmV0dXJuIHt9CgogICAgICAgICAgZGVmYXVsdDoKICAgICAgICAgICAgcmV0dXJuIHt9CiAgICAgICAgfQogICAgICB9LAoKICAgICAgZ2V0QXppbXV0aEFjdGlvbihhelZhbCkgewogICAgICAgIGlmICghTnVtYmVyLmlzRmluaXRlKGF6VmFsKSkgcmV0dXJuICcnCiAgICAgICAgY29uc3QgYXJjbWluID0gdGhpcy51bml0VG9BcmNtaW4oYXpWYWwsIHRoaXMuYWRqdXN0bWVudFVuaXQpCiAgICAgICAgaWYgKE1hdGguYWJzKGFyY21pbikgPD0gdGhpcy5kZWFkYmFuZEFyY21pbikgcmV0dXJuIHRoaXMuJHQoJ05vIGFkanVzdG1lbnQgbmVlZGVkJykKICAgICAgICBjb25zdCBkaXIgPSB0aGlzLmF6TGFiZWxCeVNpZ24oYXJjbWluKQogICAgICAgIC8vIOi+k+WHuuWNleS9jeS4jiBwcm9wcy5hZGp1c3RtZW50VW5pdCDkv53mjIHkuIDoh7QKICAgICAgICByZXR1cm4gYCR7ZGlyfSAke3RoaXMuZm9ybWF0V2l0aFVuaXQoYXJjbWluLCB0aGlzLmFkanVzdG1lbnRVbml0LCAxKX1gCiAgICAgIH0sCgogICAgICBnZXRBbHRpdHVkZUFjdGlvbihhbHRWYWwpIHsKICAgICAgICBpZiAoIU51bWJlci5pc0Zpbml0ZShhbHRWYWwpKSByZXR1cm4gJycKICAgICAgICBjb25zdCBhcmNtaW4gPSB0aGlzLnVuaXRUb0FyY21pbihhbHRWYWwsIHRoaXMuYWRqdXN0bWVudFVuaXQpCiAgICAgICAgaWYgKE1hdGguYWJzKGFyY21pbikgPD0gdGhpcy5kZWFkYmFuZEFyY21pbikgcmV0dXJuIHRoaXMuJHQoJ05vIGFkanVzdG1lbnQgbmVlZGVkJykKICAgICAgICBjb25zdCBkaXIgPSB0aGlzLmFsdExhYmVsQnlTaWduKGFyY21pbikKICAgICAgICByZXR1cm4gYCR7ZGlyfSAke3RoaXMuZm9ybWF0V2l0aFVuaXQoYXJjbWluLCB0aGlzLmFkanVzdG1lbnRVbml0LCAxKX1gCiAgICAgIH0sCgoKCiAgICAgIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0KICAgICAgLy8g5pel5b+X5pa55rOVCiAgICAgIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0KICAgICAgYWRkTG9nKG1lc3NhZ2UsIGxldmVsID0gJ2luZm8nKSB7CiAgICAgICAgY29uc3QgbG9nID0gewogICAgICAgICAgaWQ6IERhdGUubm93KCkgKyBNYXRoLnJhbmRvbSgpLAogICAgICAgICAgbWVzc2FnZSwKICAgICAgICAgIGxldmVsLAogICAgICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgpCiAgICAgICAgfQogICAgICAgIAogICAgICAgIC8vIOeUn+S6p+eOr+Wig+WHj+WwkWNvbnNvbGXovpPlh7oKICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcpIHsKICAgICAgICAgIGNvbnNvbGUubG9nKGxvZy5tZXNzYWdlKQogICAgICAgIH0KICAgICAgICAKICAgICAgICAvLyDkvb/nlKjlvqrnjq/mlbDnu4TkvJjljJblhoXlrZjkvb/nlKgKICAgICAgICBpZiAodGhpcy5sb2dzLmxlbmd0aCA8IHRoaXMubG9nQ2FwYWNpdHkpIHsKICAgICAgICAgIHRoaXMubG9ncy5wdXNoKGxvZykKICAgICAgICB9IGVsc2UgewogICAgICAgICAgLy8g5b6q546v6KaG55uW5pen5pel5b+XCiAgICAgICAgICB0aGlzLmxvZ3NbdGhpcy5sb2dJbmRleF0gPSBsb2cKICAgICAgICAgIHRoaXMubG9nSW5kZXggPSAodGhpcy5sb2dJbmRleCArIDEpICUgdGhpcy5sb2dDYXBhY2l0eQogICAgICAgIH0KICAgICAgfSwKCiAgICAgIGNsZWFyTG9ncygpIHsKICAgICAgICB0aGlzLmxvZ3MgPSBbXQogICAgICAgIHRoaXMubG9nSW5kZXggPSAwCiAgICAgIH0sCgogICAgICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09CiAgICAgIC8vIOaegei9tOagoeWHhueKtuaAgeabtOaWsOaWueazlQogICAgICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09CiAgICAgIGNhbGN1bGF0ZVBvbGFyQXhpc09mZnNldCgpIHsKICAgICAgICB0aGlzLnBvbGFyQXhpc09mZnNldCA9IHsKICAgICAgICAgIGF6aW11dGg6IHRoaXMuYWRqdXN0bWVudC5hemltdXRoLAogICAgICAgICAgYWx0aXR1ZGU6IHRoaXMuYWRqdXN0bWVudC5hbHRpdHVkZQogICAgICAgIH0KICAgICAgfSwKCiAgICAgIHVwZGF0ZVBvbGFyQWxpZ25tZW50U3RhdGUoc3RhdGVOdW1iZXIsIGxvZ01lc3NhZ2UsIHByb2dyZXNzKSB7CiAgICAgICAgaWYgKGxvZ01lc3NhZ2UgJiYgdHlwZW9mIGxvZ01lc3NhZ2UgPT09ICdzdHJpbmcnKSB7CiAgICAgICAgICBsZXQgbGV2ZWwgPSAnaW5mbycKICAgICAgICAgIGlmIChsb2dNZXNzYWdlLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoJ2Vycm9yJykgfHwgbG9nTWVzc2FnZS50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKCflpLHotKUnKSkgewogICAgICAgICAgICBsZXZlbCA9ICdlcnJvcicKICAgICAgICAgIH0gZWxzZSBpZiAobG9nTWVzc2FnZS50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKCd3YXJuaW5nJykgfHwgbG9nTWVzc2FnZS50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKCforablkYonKSkgewogICAgICAgICAgICBsZXZlbCA9ICd3YXJuaW5nJwogICAgICAgICAgfSBlbHNlIGlmIChsb2dNZXNzYWdlLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoJ3N1Y2Nlc3MnKSB8fCBsb2dNZXNzYWdlLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoJ+aIkOWKnycpIHx8IGxvZ01lc3NhZ2UudG9Mb3dlckNhc2UoKS5pbmNsdWRlcygn5a6M5oiQJykpIHsKICAgICAgICAgICAgbGV2ZWwgPSAnc3VjY2VzcycKICAgICAgICAgIH0KICAgICAgICAgIHRoaXMuYWRkTG9nKGxvZ01lc3NhZ2UsIGxldmVsKQogICAgICAgIH0KCiAgICAgICAgaWYgKHByb2dyZXNzICE9PSB1bmRlZmluZWQgJiYgcHJvZ3Jlc3MgIT09IG51bGwpIHsKICAgICAgICAgIHRoaXMuY3VycmVudFByb2dyZXNzID0gcHJvZ3Jlc3MKCiAgICAgICAgICBpZiAocHJvZ3Jlc3MgPj0gMCAmJiBwcm9ncmVzcyA8PSAxMDApIHsKICAgICAgICAgICAgLy8g5qC55o2u6L+b5bqm5pu05paw5qCh5YeG54q25oCBCiAgICAgICAgICAgIGlmIChwcm9ncmVzcyA+PSAwICYmIHByb2dyZXNzIDwgMTUpIHsKICAgICAgICAgICAgICAvLyDliJ3lp4vljJbpmLbmrrUKICAgICAgICAgICAgICB0aGlzLmNhbGlicmF0aW9uUG9pbnRzID0gW10KICAgICAgICAgICAgICB0aGlzLmlzQ2FsaWJyYXRpb25Db21wbGV0ZSA9IGZhbHNlCiAgICAgICAgICAgICAgdGhpcy5pc1BvbGFyQWxpZ25lZCA9IGZhbHNlCiAgICAgICAgICAgIH0gZWxzZSBpZiAocHJvZ3Jlc3MgPj0gMTUgJiYgcHJvZ3Jlc3MgPCAyNSkgewogICAgICAgICAgICAgIC8vIOesrOS4gOasoeagoeWHhumYtuautSAtIOenu+mZpOaooeaLn+aVsOaNrua3u+WKoO+8jOWunumZheagoeWHhueCueeUsXVwZGF0ZUZpZWxkRGF0YeWkhOeQhgogICAgICAgICAgICAgIC8vIOi/memHjOWPquabtOaWsOeKtuaAge+8jOS4jea3u+WKoOaooeaLn+agoeWHhueCuQogICAgICAgICAgICB9IGVsc2UgaWYgKHByb2dyZXNzID49IDI1ICYmIHByb2dyZXNzIDwgNTApIHsKICAgICAgICAgICAgICAvLyDnrKzkuozmrKHmoKHlh4bpmLbmrrUgLSDnp7vpmaTmqKHmi5/mlbDmja7mt7vliqDvvIzlrp7pmYXmoKHlh4bngrnnlLF1cGRhdGVGaWVsZERhdGHlpITnkIYKICAgICAgICAgICAgICAvLyDov5nph4zlj6rmm7TmlrDnirbmgIHvvIzkuI3mt7vliqDmqKHmi5/moKHlh4bngrkKICAgICAgICAgICAgfSBlbHNlIGlmIChwcm9ncmVzcyA+PSA1MCAmJiBwcm9ncmVzcyA8IDc1KSB7CiAgICAgICAgICAgICAgLy8g56ys5LiJ5qyh5qCh5YeG6Zi25q61IC0g56e76Zmk5qih5ouf5pWw5o2u5re75Yqg77yM5a6e6ZmF5qCh5YeG54K555SxdXBkYXRlRmllbGREYXRh5aSE55CGCiAgICAgICAgICAgICAgLy8g6L+Z6YeM5Y+q5pu05paw54q25oCB77yM5LiN5re75Yqg5qih5ouf5qCh5YeG54K5CiAgICAgICAgICAgIH0gZWxzZSBpZiAocHJvZ3Jlc3MgPj0gNzUgJiYgcHJvZ3Jlc3MgPCA5NSkgewogICAgICAgICAgICAgIC8vIOW+queOr+agoeWHhuiwg+aVtOmYtuautQogICAgICAgICAgICAgIHRoaXMuaXNDYWxpYnJhdGlvbkNvbXBsZXRlID0gdHJ1ZQogICAgICAgICAgICAgIHRoaXMuY2FsY3VsYXRlUG9sYXJBeGlzT2Zmc2V0KCkKCiAgICAgICAgICAgICAgLy8g5qOA5rWL5qCh5YeG5b6q546vCiAgICAgICAgICAgICAgaWYgKHByb2dyZXNzIDwgdGhpcy5sYXN0Q2FsaWJyYXRpb25Qcm9ncmVzcyAmJiB0aGlzLmxhc3RDYWxpYnJhdGlvblByb2dyZXNzID49IDc1KSB7CiAgICAgICAgICAgICAgICB0aGlzLmNhbGlicmF0aW9uTG9vcENvdW50KysKICAgICAgICAgICAgICAgIHRoaXMuYWRkTG9nKHRoaXMuJHQoJ0NhbGlicmF0aW9uIFJvdW5kIFN0YXJ0ZWQnLCBbdGhpcy5jYWxpYnJhdGlvbkxvb3BDb3VudF0pLCAnaW5mbycpCiAgICAgICAgICAgICAgfQoKICAgICAgICAgICAgICAvLyDlnKjlvqrnjq/moKHlh4bpmLbmrrXvvIzov5vluqblj6/og73kvJrlnKg3NS05NeS5i+mXtOazouWKqAogICAgICAgICAgICAgIC8vIOi/meihqOekuuezu+e7n+ato+WcqOi/m+ihjOWkmuasoeagoeWHhuiwg+aVtAogICAgICAgICAgICAgIGlmIChwcm9ncmVzcyA+IDg1KSB7CiAgICAgICAgICAgICAgICB0aGlzLmFkZExvZyh0aGlzLiR0KCdDYWxpYnJhdGlvbiBQcm9ncmVzcyBJbmZvJywgW01hdGgucm91bmQocHJvZ3Jlc3MpLCB0aGlzLmNhbGlicmF0aW9uTG9vcENvdW50XSksICdpbmZvJykKICAgICAgICAgICAgICB9CgogICAgICAgICAgICAgIHRoaXMubGFzdENhbGlicmF0aW9uUHJvZ3Jlc3MgPSBwcm9ncmVzcwogICAgICAgICAgICB9IGVsc2UgaWYgKHByb2dyZXNzID49IDk1ICYmIHByb2dyZXNzIDw9IDEwMCkgewogICAgICAgICAgICAgIC8vIOacgOe7iOmqjOivgemYtuautQogICAgICAgICAgICAgIHRoaXMuaXNDYWxpYnJhdGlvbkNvbXBsZXRlID0gdHJ1ZQogICAgICAgICAgICAgIHRoaXMuY2FsY3VsYXRlUG9sYXJBeGlzT2Zmc2V0KCkKCiAgICAgICAgICAgICAgaWYgKE1hdGguYWJzKHRoaXMucG9sYXJBeGlzT2Zmc2V0LmF6aW11dGgpIDwgMS4wICYmIE1hdGguYWJzKHRoaXMucG9sYXJBeGlzT2Zmc2V0LmFsdGl0dWRlKSA8IDEuMCkgewogICAgICAgICAgICAgICAgdGhpcy5pc1BvbGFyQWxpZ25lZCA9IHRydWUKICAgICAgICAgICAgICAgIHRoaXMuYWRkTG9nKHRoaXMuJHQoJ1BvbGFyIEFsaWdubWVudCBDb21wbGV0ZWQnKSwgJ3N1Y2Nlc3MnKQogICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICB0aGlzLmFkZExvZyh0aGlzLiR0KCdQb2xhciBBbGlnbm1lbnQgTmVlZHMgTWFudWFsIEFkanVzdG1lbnQnKSwgJ3dhcm5pbmcnKQogICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgIH0KICAgICAgfSwKCiAgICAgIHVwZGF0ZVBvbGFyQWxpZ25tZW50SXNSdW5uaW5nKGlzUnVubmluZykgewogICAgICAgIHRoaXMuaXNDYWxpYnJhdGlvblJ1bm5pbmcgPSBpc1J1bm5pbmcKICAgICAgICB0aGlzLmhhc0FjY2VwdFVwZGF0ZU1lc3NhZ2UgPSB0cnVlCiAgICAgIH0sCgogICAgICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09CiAgICAgIC8vIOWdkOagh+i9rOaNouaWueazlQogICAgICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09CiAgICAgIC8qKgogICAgICAgKiDotaTpgZPlnZDmoIcgKFJBLCBEZWMpIOKGkiDlnLDlubPlnZDmoIcgKEF6LCBBbHQpCiAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSByYURlZyDotaTnu48gKOW6piwgMH4zNjApCiAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBkZWNEZWcg6LWk57qsICjluqYsIC05MH4rOTApCiAgICAgICAqIEBwYXJhbSB7RGF0ZX0gZGF0ZVVUQyDop4LmtYvml7bpl7QgKFVUQyDml7bpl7QpCiAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBsYXREZWcg6KeC5rWL54K557qs5bqmICjluqYsIOWMl+ato+WNl+i0nykKICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGxvbkRlZyDop4LmtYvngrnnu4/luqYgKOW6piwg5Lic5q2j6KW/6LSfKQogICAgICAgKiBAcmV0dXJucyB7e2F6OiBudW1iZXIsIGFsdDogbnVtYmVyfX0g5pa55L2N6KeSL+mrmOW6puinkiAo5bqmKQogICAgICAgKi8KICAgICAgZXF1YXRvcmlhbFRvSG9yaXpvbnRhbChyYURlZywgZGVjRGVnLCBkYXRlVVRDLCBsYXREZWcsIGxvbkRlZykgewogICAgICAgIC8vIOW3peWFtwogICAgICAgIGNvbnN0IHRvSkQgPSBkID0+IChOdW1iZXIoZCkgLyA4NjQwMDAwMCkgKyAyNDQwNTg3LjU7IC8vIERhdGUvbXMg4oaSIEpECiAgICAgICAgY29uc3QgZDJyID0geCA9PiB4ICogTWF0aC5QSSAvIDE4MCwgcjJkID0geCA9PiB4ICogMTgwIC8gTWF0aC5QSTsKICAgICAgICBjb25zdCBub3JtMzYwID0gYSA9PiAoKGEgJSAzNjApICsgMzYwKSAlIDM2MDsKICAgICAgICBjb25zdCBjbGFtcCA9ICh4LCBsbyA9IC0xLCBoaSA9IDEpID0+IE1hdGgubWluKGhpLCBNYXRoLm1heChsbywgeCkpOwoKICAgICAgICAvLyDlhaXlj4LlvZLkuIDljJYgKyDnoazmoKHpqowKICAgICAgICByYURlZyA9IE51bWJlcihyYURlZyk7CiAgICAgICAgZGVjRGVnID0gTnVtYmVyKGRlY0RlZyk7CiAgICAgICAgbGF0RGVnID0gTnVtYmVyKGxhdERlZyk7CiAgICAgICAgbG9uRGVnID0gTnVtYmVyKGxvbkRlZyk7CiAgICAgICAgY29uc3QgdG1zID0gTnVtYmVyKGRhdGVVVEMpOyAvLyBEYXRlIOaIluaXtumXtOaIs+mDveWPrwoKICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcpIHsKICAgICAgICAgIGNvbnNvbGUubG9nKCdFUeKGkkhPUiDlhaXlj4I6JywgeyByYURlZywgZGVjRGVnLCBsYXREZWcsIGxvbkRlZywgZGF0ZVVUQywgdG1zIH0pOwogICAgICAgIH0KCiAgICAgICAgaWYgKCFbcmFEZWcsIGRlY0RlZywgbGF0RGVnLCBsb25EZWcsIHRtc10uZXZlcnkoTnVtYmVyLmlzRmluaXRlKSkgewogICAgICAgICAgY29uc29sZS5lcnJvcignRVHihpJIT1Ig5YWl5Y+C6Z2e5rOVOicsIHsgcmFEZWcsIGRlY0RlZywgbGF0RGVnLCBsb25EZWcsIGRhdGVVVEMsIHRtcyB9KTsKICAgICAgICAgIHJldHVybiB7IGF6OiBOYU4sIGFsdDogTmFOIH07CiAgICAgICAgfQoKICAgICAgICB0cnkgewogICAgICAgICAgLy8gMSkgSkQgJiBHTVNUCiAgICAgICAgICBjb25zdCBKRCA9IHRvSkQodG1zKTsKICAgICAgICAgIGNvbnN0IGQgPSBKRCAtIDI0NTE1NDUuMDsKICAgICAgICAgIGxldCBHTVNUID0gbm9ybTM2MCgyODAuNDYwNjE4MzcgKyAzNjAuOTg1NjQ3MzY2MjkgKiBkKTsgLy8g5bqmCgogICAgICAgICAgLy8gMikgTFNU77yI5Lic57uP5Li65q2j77yJCiAgICAgICAgICBsZXQgTFNUID0gbm9ybTM2MChHTVNUICsgbG9uRGVnKTsKCiAgICAgICAgICAvLyAzKSBIQe+8iC0xODB+MTgwIOabtOeos++8iQogICAgICAgICAgbGV0IEhBID0gTFNUIC0gcmFEZWc7CiAgICAgICAgICBIQSA9ICgoSEEgKyAxODApICUgMzYwKSAtIDE4MDsKCiAgICAgICAgICAvLyA0KSBBbHQgLyBBeu+8iOeos+WumuW9ouW8j++8iQogICAgICAgICAgY29uc3QgaGEgPSBkMnIoSEEpOwogICAgICAgICAgY29uc3QgZGVjID0gZDJyKGRlY0RlZyk7CiAgICAgICAgICBjb25zdCBsYXQgPSBkMnIobGF0RGVnKTsKCiAgICAgICAgICBjb25zdCBzaW5BbHQgPSBjbGFtcCgKICAgICAgICAgICAgTWF0aC5zaW4oZGVjKSAqIE1hdGguc2luKGxhdCkgKyBNYXRoLmNvcyhkZWMpICogTWF0aC5jb3MobGF0KSAqIE1hdGguY29zKGhhKQogICAgICAgICAgKTsKICAgICAgICAgIGNvbnN0IGFsdCA9IE1hdGguYXNpbihzaW5BbHQpOwogICAgICAgICAgY29uc3QgeSA9IC1NYXRoLnNpbihoYSkgKiBNYXRoLmNvcyhkZWMpOwogICAgICAgICAgY29uc3QgeCA9IE1hdGguc2luKGRlYykgKiBNYXRoLmNvcyhsYXQpIC0gTWF0aC5jb3MoZGVjKSAqIE1hdGguc2luKGxhdCkgKiBNYXRoLmNvcyhoYSk7CiAgICAgICAgICBjb25zdCBheiA9IE1hdGguYXRhbjIoeSwgeCk7CgogICAgICAgICAgY29uc3QgYWx0RGVnID0gcjJkKGFsdCk7CiAgICAgICAgICBjb25zdCBhekRlZyA9IG5vcm0zNjAocjJkKGF6KSk7CgogICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnKSB7CiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdFUeKGkkhPUiDnu5Pmnpw6JywgewogICAgICAgICAgICAgIEpELCBHTVNULCBMU1QsIEhBLAogICAgICAgICAgICAgIGhhUmFkOiBoYSwgZGVjUmFkOiBkZWMsIGxhdFJhZDogbGF0LAogICAgICAgICAgICAgIGF6OiBhekRlZywgYWx0OiBhbHREZWcKICAgICAgICAgICAgfSk7CiAgICAgICAgICB9CgogICAgICAgICAgcmV0dXJuIHsgYXo6IGF6RGVnLCBhbHQ6IGFsdERlZyB9OwogICAgICAgIH0gY2F0Y2ggKGUpIHsKICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0VR4oaSSE9SIOiuoeeul+W8guW4uDonLCBlLCB7CiAgICAgICAgICAgIHJhRGVnLCBkZWNEZWcsIGxhdERlZywgbG9uRGVnLCBkYXRlVVRDLCB0bXMKICAgICAgICAgIH0pOwogICAgICAgICAgcmV0dXJuIHsgYXo6IE5hTiwgYWx0OiBOYU4gfTsKICAgICAgICB9CiAgICAgIH0sCgoKCgoKICAgICAgLy8gPT09IOWinuW8uueahOWNoeeJh+S/oeaBr+abtOaWsOaWueazlSA9PT0KICAgICAgdXBkYXRlQ2FyZEluZm8oY3VycmVudFJhLCBjdXJyZW50RGVjLCB0YXJnZXRSYSwgdGFyZ2V0RGVjLCBhemltdXRoVmFsLCBhbHRpdHVkZVZhbCwgcmFBZGp1c3RtZW50LCBkZWNBZGp1c3RtZW50LCB1bml0SGludCkgewogICAgICAgIGNvbnN0IHBhcnNlVmFsdWUgPSB2ID0+ICh2ID09PSBudWxsIHx8IHYgPT09ICcnIHx8IHYgPT09IHVuZGVmaW5lZCkgPyAwIDogKE51bWJlcih2KSB8fCAwKQoKICAgICAgICBjb25zdCBjdXJyZW50UmFOdW0gPSBwYXJzZVZhbHVlKGN1cnJlbnRSYSkKICAgICAgICBjb25zdCBjdXJyZW50RGVjTnVtID0gcGFyc2VWYWx1ZShjdXJyZW50RGVjKQogICAgICAgIGNvbnN0IHRhcmdldFJhTnVtID0gcGFyc2VWYWx1ZSh0YXJnZXRSYSkKICAgICAgICBjb25zdCB0YXJnZXREZWNOdW0gPSBwYXJzZVZhbHVlKHRhcmdldERlYykKICAgICAgICBjb25zdCBhelZhbCA9IHBhcnNlVmFsdWUoYXppbXV0aFZhbCkKICAgICAgICBjb25zdCBhbHRWYWwgPSBwYXJzZVZhbHVlKGFsdGl0dWRlVmFsKQoKICAgICAgICAvLyAxKSDkvY3nva7mmL7npLrvvIjljp/moLfvvIkKICAgICAgICB0aGlzLmN1cnJlbnRQb3NpdGlvbi5yYSA9IHRoaXMuZm9ybWF0Q29vcmRpbmF0ZShjdXJyZW50UmFOdW0sICdyYScpCiAgICAgICAgdGhpcy5jdXJyZW50UG9zaXRpb24uZGVjID0gdGhpcy5mb3JtYXRDb29yZGluYXRlKGN1cnJlbnREZWNOdW0sICdkZWMnKQogICAgICAgIHRoaXMudGFyZ2V0UG9zaXRpb24ucmEgPSB0aGlzLmZvcm1hdENvb3JkaW5hdGUodGFyZ2V0UmFOdW0sICdyYScpCiAgICAgICAgdGhpcy50YXJnZXRQb3NpdGlvbi5kZWMgPSB0aGlzLmZvcm1hdENvb3JkaW5hdGUodGFyZ2V0RGVjTnVtLCAnZGVjJykKCiAgICAgICAgLy8gMikg6LCD5pW06YeP77ya5Lul5Lyg5YWl5Y2V5L2N5Li65YeG5YaZ5YWl77yI6buY6K6k55SoIHByb3BzLmFkanVzdG1lbnRVbml077yJCiAgICAgICAgY29uc3QgaW5Vbml0ID0gdW5pdEhpbnQgfHwgdGhpcy5hZGp1c3RtZW50VW5pdAogICAgICAgIC8vIOWmguaenOS8oOWFpeaYryLluqYi77yM5L2G5L2gIHByb3BzIOiuvuS4uuS6hiJhcmNtaW4i77yM5Lmf5rKh5YWz57O74oCU4oCU5pi+56S65Lya6Ieq5Yqo5o2i566XCiAgICAgICAgLy8g6L+Z6YeM5L+d5a2YIuWOn+Wni+aVsCArIOWug+eahOWNleS9je+8iOmAmui/hyBwcm9wc++8iSIKICAgICAgICB0aGlzLmFkanVzdG1lbnQuYXppbXV0aCA9IGF6VmFsCiAgICAgICAgdGhpcy5hZGp1c3RtZW50LmFsdGl0dWRlID0gYWx0VmFsCiAgICAgICAgdGhpcy5hZGp1c3RtZW50VW5pdCA9IGluVW5pdCAgLy8g5aaC5p6c5biM5pyb5q+P5qyh6ZqP5pWw5o2u5YiH5o2i5Y2V5L2N77yM5Y+v5Yqg5YWl6L+Z5LiA6KGMCgogICAgICAgIC8vIDMpIOWcqOiwg+aVtOmYtuaute+8jOavj+asoeaOpeaUtuWIsOiwg+aVtOaVsOaNruaXtuWinuWKoOagoeWHhui9ruaVsAogICAgICAgIGlmICh0aGlzLmNhbGlicmF0aW9uUGhhc2UgPT09ICdhZGp1c3RpbmcnKSB7CiAgICAgICAgICB0aGlzLmNhbGlicmF0aW9uTG9vcENvdW50KysKICAgICAgICAgIHRoaXMuYWRkTG9nKHRoaXMuJHQoJ0NhbGlicmF0aW9uIFJvdW5kIFN0YXJ0ZWQnLCBbdGhpcy5jYWxpYnJhdGlvbkxvb3BDb3VudF0pLCAnaW5mbycpCiAgICAgICAgfQoKICAgICAgICAvLyA0KSDmnoHovbTlrozmiJDliKTlrprvvIjnlKjop5LliIbmr5TovoPvvIkKICAgICAgICBjb25zdCBhekFyY21pbiA9IHRoaXMudW5pdFRvQXJjbWluKGF6VmFsLCBpblVuaXQpCiAgICAgICAgY29uc3QgYWx0QXJjbWluID0gdGhpcy51bml0VG9BcmNtaW4oYWx0VmFsLCBpblVuaXQpCiAgICAgICAgdGhpcy5pc1BvbGFyQWxpZ25lZCA9IE1hdGguYWJzKGF6QXJjbWluKSA8IDEuMCAmJiBNYXRoLmFicyhhbHRBcmNtaW4pIDwgMS4wCgogICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50JykgewogICAgICAgICAgY29uc29sZS5sb2coJ1BvbGFyQWxpZ25tZW50IHVwZGF0ZTonLCB7CiAgICAgICAgICAgIHVuaXQ6IGluVW5pdCwKICAgICAgICAgICAgYWRqX3JhdzogeyBhemltdXRoOiBhelZhbCwgYWx0aXR1ZGU6IGFsdFZhbCB9LAogICAgICAgICAgICBhZGpfYXJjbWluOiB7IGF6OiBhekFyY21pbiwgYWx0OiBhbHRBcmNtaW4gfSwKICAgICAgICAgICAgaXNQb2xhckFsaWduZWQ6IHRoaXMuaXNQb2xhckFsaWduZWQsCiAgICAgICAgICAgIGNhbGlicmF0aW9uUm91bmQ6IHRoaXMuY2FsaWJyYXRpb25Mb29wQ291bnQKICAgICAgICAgIH0pCiAgICAgICAgfQogICAgICB9LAoKCiAgICAgIC8qKgogICAgICAgKiDmoLnmja7kuInkuKrmoKHlh4bngrnorqHnrpflgYfmnoHovbTkvY3nva4KICAgICAgICog5L2/55So5LiJ54K55p6B6L205qCh5YeG566X5rOVCiAgICAgICAqLwogICAgICBjYWxjdWxhdGVGYWtlUG9sYXJBeGlzKCkgewogICAgICAgIGlmICh0aGlzLmNhbGlicmF0aW9uUG9pbnRzLmxlbmd0aCAhPT0gdGhpcy5tYXhDYWxpYnJhdGlvblBvaW50cykgewogICAgICAgICAgdGhpcy5hZGRMb2coJ+mcgOimgTPkuKrmoKHlh4bngrnmiY3og73orqHnrpflgYfmnoHovbTkvY3nva4nLCAnd2FybmluZycpCiAgICAgICAgICByZXR1cm4gZmFsc2UKICAgICAgICB9CgogICAgICAgIHRyeSB7CiAgICAgICAgICBjb25zdCBbcDEsIHAyLCBwM10gPSB0aGlzLmNhbGlicmF0aW9uUG9pbnRzCgogICAgICAgICAgLy8g5bCG5LiJ5Liq54K56L2s5o2i5Li656yb5Y2h5bCU5Z2Q5qCHCiAgICAgICAgICBjb25zdCBjYXJ0MSA9IHRoaXMuZXF1YXRvcmlhbFRvQ2FydGVzaWFuKHAxLnJhLCBwMS5kZWMpCiAgICAgICAgICBjb25zdCBjYXJ0MiA9IHRoaXMuZXF1YXRvcmlhbFRvQ2FydGVzaWFuKHAyLnJhLCBwMi5kZWMpCiAgICAgICAgICBjb25zdCBjYXJ0MyA9IHRoaXMuZXF1YXRvcmlhbFRvQ2FydGVzaWFuKHAzLnJhLCBwMy5kZWMpCgogICAgICAgICAgLy8g6K6h566X5Lik5Liq5ZCR6YePCiAgICAgICAgICBjb25zdCB2MSA9IHsKICAgICAgICAgICAgeDogY2FydDIueCAtIGNhcnQxLngsCiAgICAgICAgICAgIHk6IGNhcnQyLnkgLSBjYXJ0MS55LAogICAgICAgICAgICB6OiBjYXJ0Mi56IC0gY2FydDEuegogICAgICAgICAgfQogICAgICAgICAgY29uc3QgdjIgPSB7CiAgICAgICAgICAgIHg6IGNhcnQzLnggLSBjYXJ0MS54LAogICAgICAgICAgICB5OiBjYXJ0My55IC0gY2FydDEueSwKICAgICAgICAgICAgejogY2FydDMueiAtIGNhcnQxLnoKICAgICAgICAgIH0KCiAgICAgICAgICAvLyDorqHnrpfms5XlkJHph4/vvIjlj4nnp6/vvIkKICAgICAgICAgIGNvbnN0IG5vcm1hbCA9IHRoaXMuY3Jvc3NQcm9kdWN0KHYxLCB2MikKCiAgICAgICAgICAvLyDmo4Dmn6Xms5XlkJHph4/mmK/lkKbkuLrpm7blkJHph48KICAgICAgICAgIGNvbnN0IG5vcm1hbExlbmd0aCA9IHRoaXMudmVjdG9yTGVuZ3RoKG5vcm1hbCkKICAgICAgICAgIGlmIChub3JtYWxMZW5ndGggPCAxZS0xMCkgewogICAgICAgICAgICB0aGlzLmFkZExvZygn5LiJ5Liq5qCh5YeG54K55YWx57q/77yM5peg5rOV6K6h566X5YGH5p6B6L205L2N572uJywgJ2Vycm9yJykKICAgICAgICAgICAgcmV0dXJuIGZhbHNlCiAgICAgICAgICB9CgogICAgICAgICAgLy8g5b2S5LiA5YyW5rOV5ZCR6YePCiAgICAgICAgICBjb25zdCB1bml0Tm9ybWFsID0gdGhpcy5ub3JtYWxpemVWZWN0b3Iobm9ybWFsKQoKICAgICAgICAgIC8vIOiuoeeul+S4juWNleS9jeeQg+mdoueahOS6pOeCue+8iOWBh+aegeeCue+8iQogICAgICAgICAgY29uc3QgZmFrZVBvbGFyUG9pbnQgPSB7CiAgICAgICAgICAgIHg6IHVuaXROb3JtYWwueCwKICAgICAgICAgICAgeTogdW5pdE5vcm1hbC55LAogICAgICAgICAgICB6OiB1bml0Tm9ybWFsLnoKICAgICAgICAgIH0KCiAgICAgICAgICAvLyDpgInmi6nmraPnoa7nmoTkuqTngrnvvIh65Z2Q5qCH5Li65q2j55qE77yJCiAgICAgICAgICBpZiAoZmFrZVBvbGFyUG9pbnQueiA8IDApIHsKICAgICAgICAgICAgZmFrZVBvbGFyUG9pbnQueCA9IC1mYWtlUG9sYXJQb2ludC54CiAgICAgICAgICAgIGZha2VQb2xhclBvaW50LnkgPSAtZmFrZVBvbGFyUG9pbnQueQogICAgICAgICAgICBmYWtlUG9sYXJQb2ludC56ID0gLWZha2VQb2xhclBvaW50LnoKICAgICAgICAgIH0KCiAgICAgICAgICAvLyDlsIblgYfmnoHngrnovazmjaLkuLrotaTpgZPlnZDmoIcKICAgICAgICAgIGNvbnN0IGZha2VQb2xhckVxdWF0b3JpYWwgPSB0aGlzLmNhcnRlc2lhblRvRXF1YXRvcmlhbChmYWtlUG9sYXJQb2ludCkKCiAgICAgICAgICAvLyDkv53lrZjlgYfmnoHovbTkvY3nva4KICAgICAgICAgIHRoaXMuZmFrZVBvbGFyQXhpcy5yYSA9IGZha2VQb2xhckVxdWF0b3JpYWwucmEKICAgICAgICAgIHRoaXMuZmFrZVBvbGFyQXhpcy5kZWMgPSBmYWtlUG9sYXJFcXVhdG9yaWFsLmRlYwogICAgICAgICAgdGhpcy5mYWtlUG9sYXJBeGlzLmNhbGN1bGF0ZWQgPSB0cnVlCgogICAgICAgICAgdGhpcy5hZGRMb2coYOWBh+aegei9tOS9jee9ruiuoeeul+WujOaIkDogUkE9JHtmYWtlUG9sYXJFcXVhdG9yaWFsLnJhLnRvRml4ZWQoNCl9wrAsIERFQz0ke2Zha2VQb2xhckVxdWF0b3JpYWwuZGVjLnRvRml4ZWQoNCl9wrBgLCAnc3VjY2VzcycpCgogICAgICAgICAgcmV0dXJuIHRydWUKICAgICAgICB9IGNhdGNoIChlcnJvcikgewogICAgICAgICAgdGhpcy5hZGRMb2coYOiuoeeul+WBh+aegei9tOS9jee9ruaXtuWHuumUmTogJHtlcnJvci5tZXNzYWdlfWAsICdlcnJvcicpCiAgICAgICAgICBjb25zb2xlLmVycm9yKCforqHnrpflgYfmnoHovbTkvY3nva7plJnor6/vvJonLCBlcnJvcikKICAgICAgICAgIHJldHVybiBmYWxzZQogICAgICAgIH0KICAgICAgfSwKCiAgICAgIC8qKgogICAgICAgKiDlsIbotaTpgZPlnZDmoIfovazmjaLkuLrnrJvljaHlsJTlnZDmoIcKICAgICAgICovCiAgICAgIGVxdWF0b3JpYWxUb0NhcnRlc2lhbihyYSwgZGVjLCByYWRpdXMgPSAxKSB7CiAgICAgICAgY29uc3QgcmFSYWQgPSByYSAqIE1hdGguUEkgLyAxODAuMAogICAgICAgIGNvbnN0IGRlY1JhZCA9IGRlYyAqIE1hdGguUEkgLyAxODAuMAoKICAgICAgICByZXR1cm4gewogICAgICAgICAgeDogcmFkaXVzICogTWF0aC5jb3MoZGVjUmFkKSAqIE1hdGguY29zKHJhUmFkKSwKICAgICAgICAgIHk6IHJhZGl1cyAqIE1hdGguY29zKGRlY1JhZCkgKiBNYXRoLnNpbihyYVJhZCksCiAgICAgICAgICB6OiByYWRpdXMgKiBNYXRoLnNpbihkZWNSYWQpCiAgICAgICAgfQogICAgICB9LAoKICAgICAgLyoqCiAgICAgICAqIOWwhuesm+WNoeWwlOWdkOagh+i9rOaNouS4uui1pOmBk+WdkOaghwogICAgICAgKi8KICAgICAgY2FydGVzaWFuVG9FcXVhdG9yaWFsKGNhcnQpIHsKICAgICAgICBjb25zdCByYWRpdXMgPSBNYXRoLnNxcnQoY2FydC54ICogY2FydC54ICsgY2FydC55ICogY2FydC55ICsgY2FydC56ICogY2FydC56KQoKICAgICAgICBjb25zdCBkZWMgPSBNYXRoLmFzaW4oY2FydC56IC8gcmFkaXVzKSAqIDE4MC4wIC8gTWF0aC5QSQogICAgICAgIGxldCByYSA9IE1hdGguYXRhbjIoY2FydC55LCBjYXJ0LngpICogMTgwLjAgLyBNYXRoLlBJCgogICAgICAgIC8vIOehruS/nVJB5ZyoMC0zNjDluqbojIPlm7TlhoUKICAgICAgICBpZiAocmEgPCAwKSByYSArPSAzNjAuMAoKICAgICAgICByZXR1cm4geyByYSwgZGVjIH0KICAgICAgfSwKCiAgICAgIC8qKgogICAgICAgKiDorqHnrpfkuKTkuKrlkJHph4/nmoTlj4nnp68KICAgICAgICovCiAgICAgIGNyb3NzUHJvZHVjdCh2MSwgdjIpIHsKICAgICAgICByZXR1cm4gewogICAgICAgICAgeDogdjEueSAqIHYyLnogLSB2MS56ICogdjIueSwKICAgICAgICAgIHk6IHYxLnogKiB2Mi54IC0gdjEueCAqIHYyLnosCiAgICAgICAgICB6OiB2MS54ICogdjIueSAtIHYxLnkgKiB2Mi54CiAgICAgICAgfQogICAgICB9LAoKICAgICAgLyoqCiAgICAgICAqIOiuoeeul+WQkemHj+mVv+W6pgogICAgICAgKi8KICAgICAgdmVjdG9yTGVuZ3RoKHYpIHsKICAgICAgICByZXR1cm4gTWF0aC5zcXJ0KHYueCAqIHYueCArIHYueSAqIHYueSArIHYueiAqIHYueikKICAgICAgfSwKCiAgICAgIC8qKgogICAgICAgKiDlvZLkuIDljJblkJHph48KICAgICAgICovCiAgICAgIG5vcm1hbGl6ZVZlY3Rvcih2KSB7CiAgICAgICAgY29uc3QgbGVuZ3RoID0gdGhpcy52ZWN0b3JMZW5ndGgodikKICAgICAgICByZXR1cm4gewogICAgICAgICAgeDogdi54IC8gbGVuZ3RoLAogICAgICAgICAgeTogdi55IC8gbGVuZ3RoLAogICAgICAgICAgejogdi56IC8gbGVuZ3RoCiAgICAgICAgfQogICAgICB9LAoKICAgICAgLyoqCiAgICAgICAqIOe7mOWItuWBh+aegei9tOS9jee9rgogICAgICAgKi8KICAgICAgZHJhd0Zha2VQb2xhckF4aXMoZmFrZVBvbGFyUkEsIGZha2VQb2xhckRFQykgewogICAgICAgIHRoaXMuYWRkTG9nKGDnu5jliLblgYfmnoHovbTkvY3nva46IFJBPSR7ZmFrZVBvbGFyUkEudG9GaXhlZCg0KX3CsCwgREVDPSR7ZmFrZVBvbGFyREVDLnRvRml4ZWQoNCl9wrBgLCAnaW5mbycpCgogICAgICAgIHRyeSB7CiAgICAgICAgICAvLyDlrprkuYnlgYfmnoHovbTnmoTpopzoibLvvIjntKvoibLvvIkKICAgICAgICAgIGNvbnN0IGZha2VQb2xhckNvbG9yID0gewogICAgICAgICAgICBzdHJva2U6ICIjOUMyN0IwIiwgICAgICAgIC8vIOe0q+iJsui+ueahhgogICAgICAgICAgICBzdHJva2VPcGFjaXR5OiAxLCAgICAgICAgIC8vIOi+ueahhuS4jemAj+aYjuW6pgogICAgICAgICAgICBmaWxsOiAiIzlDMjdCMCIsICAgICAgICAgIC8vIOe0q+iJsuWhq+WFhQogICAgICAgICAgICBmaWxsT3BhY2l0eTogMC4zICAgICAgICAgIC8vIOWhq+WFheS4jemAj+aYjuW6pu+8iOWNiumAj+aYju+8iQogICAgICAgICAgfQoKICAgICAgICAgIC8vIOS9v+eUqOS4k+mXqOeahOWBh+aegei9tOe7mOWItuS6i+S7tu+8jOmBv+WFjeS4juebruagh+eCueWGsueqgQogICAgICAgICAgdGhpcy4kYnVzLiRlbWl0KCdEcmF3RmFrZVBvbGFyQXhpc0NpcmNsZScsCiAgICAgICAgICAgIGZha2VQb2xhclJBLAogICAgICAgICAgICBmYWtlUG9sYXJERUMsCiAgICAgICAgICAgIGZha2VQb2xhckNvbG9yLAogICAgICAgICAgICAnRmFrZVBvbGFyQXhpcycsCiAgICAgICAgICAgICflgYfmnoHovbQnCiAgICAgICAgICApCgogICAgICAgICAgdGhpcy5hZGRMb2coYOWBh+aegei9tOS9jee9ruW3sue7mOWItjogUkE9JHtmYWtlUG9sYXJSQS50b0ZpeGVkKDQpfcKwLCBERUM9JHtmYWtlUG9sYXJERUMudG9GaXhlZCg0KX3CsGAsICdpbmZvJykKCiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHsKICAgICAgICAgIHRoaXMuYWRkTG9nKGDnu5jliLblgYfmnoHovbTkvY3nva7ml7blh7rplJk6ICR7ZXJyb3IubWVzc2FnZX1gLCAnZXJyb3InKQogICAgICAgICAgY29uc29sZS5lcnJvcign57uY5Yi25YGH5p6B6L205L2N572u6ZSZ6K+v77yaJywgZXJyb3IpCiAgICAgICAgfQogICAgICB9LAogICAgICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09CiAgICAgIC8vIOWNleS9jeaNoueul+aWueazlQogICAgICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09CiAgICAgIHVuaXRUb0FyY21pbih2YWwsIHVuaXQpIHsKICAgICAgICBpZiAoIU51bWJlci5pc0Zpbml0ZSh2YWwpKSByZXR1cm4gTmFOCiAgICAgICAgaWYgKHVuaXQgPT09ICdkZWcnKSByZXR1cm4gdmFsICogNjAKICAgICAgICBpZiAodW5pdCA9PT0gJ2FyY3NlYycpIHJldHVybiB2YWwgLyA2MAogICAgICAgIHJldHVybiB2YWwgLy8gJ2FyY21pbicKICAgICAgfSwKICAgICAgYXJjbWluVG9Vbml0KHZhbEFyY21pbiwgdW5pdCkgewogICAgICAgIGlmICghTnVtYmVyLmlzRmluaXRlKHZhbEFyY21pbikpIHJldHVybiBOYU4KICAgICAgICBpZiAodW5pdCA9PT0gJ2RlZycpIHJldHVybiB2YWxBcmNtaW4gLyA2MAogICAgICAgIGlmICh1bml0ID09PSAnYXJjc2VjJykgcmV0dXJuIHZhbEFyY21pbiAqIDYwCiAgICAgICAgcmV0dXJuIHZhbEFyY21pbgogICAgICB9LAogICAgICB1bml0R2x5cGgodW5pdCkgewogICAgICAgIGlmICh1bml0ID09PSAnZGVnJykgcmV0dXJuICfCsCcKICAgICAgICBpZiAodW5pdCA9PT0gJ2FyY3NlYycpIHJldHVybiAn4oCzJwogICAgICAgIHJldHVybiAn4oCyJyAvLyBhcmNtaW4KICAgICAgfSwKCiAgICAgIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0KICAgICAgLy8g5bem5Y+zL+S4iuS4i+aYoOWwhO+8iOmdouWQkeaegeeCue+8ieaWueazlQogICAgICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09CiAgICAgIC8vIOagueaNruW9k+WJjeWdkOagh+iuoeeul+acneWQkeWTquS4quaegeeCuQogICAgICBjYWxjdWxhdGVGYWNpbmdQb2xlKCkgewogICAgICAgIGlmICghdGhpcy4kc3RvcmUgfHwgIXRoaXMuJHN0b3JlLnN0YXRlLmN1cnJlbnRMb2NhdGlvbikgewogICAgICAgICAgcmV0dXJuICdub3J0aCcgLy8g6buY6K6k6L+U5Zue5YyX5p6BCiAgICAgICAgfQogICAgICAgIAogICAgICAgIGNvbnN0IGxhdCA9IHRoaXMuJHN0b3JlLnN0YXRlLmN1cnJlbnRMb2NhdGlvbi5sYXQKICAgICAgICAvLyDljJfljYrnkIPvvIjnuqzluqYgPiAw77yJ6Z2i5ZCR5YyX5p6B77yM5Y2X5Y2K55CD77yI57qs5bqmIDwgMO+8iemdouWQkeWNl+aegQogICAgICAgIHJldHVybiBsYXQgPj0gMCA/ICdub3J0aCcgOiAnc291dGgnCiAgICAgIH0sCgogICAgICAvLyBhelNpZ24gPiAwID0g5pyd5Lic77ybYXpTaWduIDwgMCA9IOacneilvwogICAgICBhekxhYmVsQnlTaWduKGF6U2lnbikgewogICAgICAgIC8vIOWKqOaAgeiuoeeul+acneWQkeaegeeCue+8jOiAjOS4jeaYr+S9v+eUqCBwcm9wcwogICAgICAgIGNvbnN0IGZhY2luZ1BvbGUgPSB0aGlzLmNhbGN1bGF0ZUZhY2luZ1BvbGUoKQogICAgICAgIC8vIOmdouWQkeWMl+aegeeCue+8muS4nD3ihpLlj7PvvIzopb894oaQ5bem77yb6Z2i5ZCR5Y2X5p6B54K55YiZ55u45Y+NCiAgICAgICAgY29uc3QgZWFzdCA9IChmYWNpbmdQb2xlID09PSAnbm9ydGgnKSA/IHRoaXMuJHQoJ+KGkiBSaWdodCAoRWFzdCknKSA6IHRoaXMuJHQoJ+KGkCBMZWZ0IChFYXN0KScpCiAgICAgICAgY29uc3Qgd2VzdCA9IChmYWNpbmdQb2xlID09PSAnbm9ydGgnKSA/IHRoaXMuJHQoJ+KGkCBMZWZ0IChXZXN0KScpIDogdGhpcy4kdCgn4oaSIFJpZ2h0IChXZXN0KScpCiAgICAgICAgcmV0dXJuIGF6U2lnbiA+PSAwID8gZWFzdCA6IHdlc3QKICAgICAgfSwKICAgICAgLy8gYWx0U2lnbiA+IDAgPSDmiqzpq5jvvJthbHRTaWduIDwgMCA9IOmZjeS9jgogICAgICBhbHRMYWJlbEJ5U2lnbihhbHRTaWduKSB7CiAgICAgICAgcmV0dXJuIGFsdFNpZ24gPj0gMCA/IHRoaXMuJHQoJ+KGkSBVcCAoUmFpc2UpJykgOiB0aGlzLiR0KCfihpMgRG93biAoTG93ZXIpJykKICAgICAgfSwKCiAgICAgIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0KICAgICAgLy8g57uf5LiA5qC85byP5YyWIuaVsOWAvCArIOWNleS9jSLmlrnms5UKICAgICAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PQogICAgICBmb3JtYXRXaXRoVW5pdCh2YWxJbkFyY21pbiwgdW5pdCwgZGlnaXRzID0gMSkgewogICAgICAgIGNvbnN0IHYgPSB0aGlzLmFyY21pblRvVW5pdChNYXRoLmFicyh2YWxJbkFyY21pbiksIHVuaXQpCiAgICAgICAgY29uc3QgZ2x5cGggPSB0aGlzLnVuaXRHbHlwaCh1bml0KQogICAgICAgIHJldHVybiBgJHt2LnRvRml4ZWQoZGlnaXRzKX0ke2dseXBofWAKICAgICAgfSwKCiAgICAgIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0KICAgICAgLy8g6aKc6Imy5bel5YW35pa55rOVCiAgICAgIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0KICAgICAgZ2V0Q2FsaWJyYXRpb25Qb2ludENvbG9yKCkgewogICAgICAgIHJldHVybiB7CiAgICAgICAgICBzdHJva2U6IENPTE9SUy5XSElURSwKICAgICAgICAgIHN0cm9rZU9wYWNpdHk6IDEsCiAgICAgICAgICBmaWxsOiBDT0xPUlMuV0hJVEUsCiAgICAgICAgICBmaWxsT3BhY2l0eTogMC4yCiAgICAgICAgfQogICAgICB9LAoKICAgICAgZ2V0Q3VycmVudFBvc2l0aW9uQ29sb3IoKSB7CiAgICAgICAgcmV0dXJuIHsKICAgICAgICAgIHN0cm9rZTogIiMwMEJGRkYiLAogICAgICAgICAgc3Ryb2tlT3BhY2l0eTogMSwKICAgICAgICAgIGZpbGw6ICIjMDBCRkZGIiwKICAgICAgICAgIGZpbGxPcGFjaXR5OiAwLjMKICAgICAgICB9CiAgICAgIH0sCgogICAgICBnZXRUYXJnZXRQb2ludENvbG9yKCkgewogICAgICAgIHJldHVybiB7CiAgICAgICAgICBzdHJva2U6IENPTE9SUy5TVUNDRVNTLAogICAgICAgICAgc3Ryb2tlT3BhY2l0eTogMSwKICAgICAgICAgIGZpbGw6IENPTE9SUy5TVUNDRVNTLAogICAgICAgICAgZmlsbE9wYWNpdHk6IDAuMwogICAgICAgIH0KICAgICAgfSwKCiAgICAgIGdldEZha2VQb2xhckF4aXNDb2xvcigpIHsKICAgICAgICByZXR1cm4gewogICAgICAgICAgc3Ryb2tlOiAiIzlDMjdCMCIsCiAgICAgICAgICBzdHJva2VPcGFjaXR5OiAxLAogICAgICAgICAgZmlsbDogIiM5QzI3QjAiLAogICAgICAgICAgZmlsbE9wYWNpdHk6IDAuMwogICAgICAgIH0KICAgICAgfSwKICAgIH0sCiAgfQo="},{"version":3,"sources":["AutomaticPolarAlignmentCalibration.vue"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA6RA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"AutomaticPolarAlignmentCalibration.vue","sourceRoot":"src/components","sourcesContent":["<template>\n  <div class=\"polar-alignment-root\">\n  <!-- 最小化状态 -->\n  <div v-if=\"visible && isMinimized\" class=\"polar-alignment-minimized\" :class=\"{ 'dragging': isDraggingState }\"\n    :style=\"{ left: position.x + 'px', top: position.y + 'px' }\">\n    <div class=\"minimized-header\">\n      <div class=\"minimized-drag-area\" @mousedown=\"startDrag\" @touchstart=\"startDrag\">\n        <v-icon class=\"minimized-icon\">mdi-compass-rose</v-icon>\n        <span class=\"minimized-title\">{{ $t('Polar Alignment') }}</span>\n      </div>\n      <div class=\"minimized-controls\">\n        <button class=\"minimized-btn\" @click=\"toggleMinimize\" :title=\"$t('Expand')\">\n          <v-icon>mdi-chevron-up</v-icon>\n        </button>\n      </div>\n    </div>\n    <div class=\"minimized-status\">\n      <div class=\"status-indicator\" :class=\"{ 'online': isConnected }\"></div>\n      <span class=\"status-text\">{{ isConnected ? $t('Connected') : $t('Disconnected') }}</span>\n    </div>\n  </div>\n\n  <!-- 完整界面 -->\n  <div v-else-if=\"visible\" class=\"polar-alignment-widget\"\n    :class=\"{ 'collapsed': isCollapsed, 'dragging': isDraggingState }\"\n    :style=\"{ left: position.x + 'px', top: position.y + 'px', pointerEvents: (showTrajectoryOverlay && overlayMode === 'fullscreen' ? 'none' : 'auto') }\">\n\n    <!-- 拖动手柄 -->\n    <div class=\"widget-header\">\n      <div class=\"header-drag-area\" @mousedown=\"startDrag\" @touchstart=\"startDrag\">\n        <div class=\"header-left\">\n          <v-icon class=\"header-icon\">mdi-compass-rose</v-icon>\n          <span class=\"header-title\">{{ $t('Polar Alignment Calibration') }}</span>\n          <div class=\"connection-indicator\">\n            <div class=\"status-dot\" :class=\"{ 'online': isConnected }\"></div>\n          </div>\n        </div>\n      </div>\n\n      <div class=\"header-controls\">\n        <button class=\"header-btn\" @click=\"toggleCollapse\" :title=\"isCollapsed ? $t('Expand') : $t('Collapse')\">\n          <v-icon>{{ isCollapsed ? 'mdi-chevron-down' : 'mdi-chevron-up' }}</v-icon>\n        </button>\n        <button class=\"header-btn\" @click=\"toggleTrajectoryOverlay\" :title=\"showTrajectoryOverlay ? $t('Hide Trajectory Canvas') : $t('Show Trajectory Canvas')\">\n          <v-icon>{{ showTrajectoryOverlay ? 'mdi-eye-off' : 'mdi-crosshairs-gps' }}</v-icon>\n        </button>\n        <button class=\"header-btn\" @click=\"toggleMinimize\" :title=\"$t('Minimize')\">\n          <v-icon>mdi-minus</v-icon>\n        </button>\n      </div>\n    </div>\n\n    <!-- 收缩状态内容 -->\n    <div v-if=\"isCollapsed\" class=\"widget-content collapsed\" :class=\"{ 'dragging': isDraggingState }\">\n      <div class=\"collapsed-info\">\n        <div class=\"collapsed-progress\">\n          <div class=\"progress-circle\" :style=\"{ '--progress': progressPercentage + '%' }\">\n            <span class=\"progress-text\">{{ Math.round(progressPercentage) }}%</span>\n          </div>\n        </div>\n        <div class=\"collapsed-status\">\n          <div class=\"status-item\">\n            <span class=\"status-label\">方位角:</span>\n            <span class=\"status-value\" :class=\"{ 'needs-adjustment': needsAzimuthAdjustment }\">\n              {{ formatAdjustmentValue(adjustment.azimuth) }}\n            </span>\n          </div>\n          <div class=\"status-item\">\n            <span class=\"status-label\">高度角:</span>\n            <span class=\"status-value\" :class=\"{ 'needs-adjustment': needsAltitudeAdjustment }\">\n              {{ formatAdjustmentValue(adjustment.altitude) }}\n            </span>\n          </div>\n        </div>\n      </div>\n    </div>\n\n    <!-- 展开状态内容 -->\n    <div v-else class=\"widget-content expanded\" :class=\"{ 'dragging': isDraggingState }\">\n      <div class=\"content-sections\">\n        <!-- 校准步骤进度条 -->\n        <div class=\"calibration-progress\">\n          <div class=\"progress-header\">\n            <div class=\"progress-title\">{{ $t('Calibration Progress') }}</div>\n            <div v-if=\"progressPercentage >= 75 && progressPercentage < 95\" class=\"calibration-loop-info\">\n              {{ $t('Calibration Round', [calibrationLoopCount]) }}\n            </div>\n          </div>\n          <div class=\"progress-bar\">\n            <div class=\"progress-fill\" :style=\"{ width: progressPercentage + '%' }\"></div>\n            <div class=\"progress-nodes\">\n              <!-- 初始化节点 -->\n              <div class=\"progress-node\" :class=\"getStepClass(0)\">\n                <div class=\"node-circle\">\n                  <v-icon v-if=\"progressPercentage >= 15\">mdi-check</v-icon>\n                  <v-icon v-else>mdi-cog</v-icon>\n                </div>\n                <div class=\"node-label\">{{ $t('Initialization') }}</div>\n              </div>\n\n              <!-- 第一次校准节点 -->\n              <div class=\"progress-node\" :class=\"getStepClass(1)\">\n                <div class=\"node-circle\">\n                  <v-icon v-if=\"progressPercentage >= 25\">mdi-check</v-icon>\n                  <span v-else>1</span>\n                </div>\n                <div class=\"node-label\">{{ $t('First Calibration') }}</div>\n              </div>\n\n              <!-- 第二次校准节点 -->\n              <div class=\"progress-node\" :class=\"getStepClass(2)\">\n                <div class=\"node-circle\">\n                  <v-icon v-if=\"progressPercentage >= 50\">mdi-check</v-icon>\n                  <span v-else>2</span>\n                </div>\n                <div class=\"node-label\">{{ $t('Second Calibration') }}</div>\n              </div>\n\n              <!-- 第三次校准节点 -->\n              <div class=\"progress-node\" :class=\"getStepClass(3)\">\n                <div class=\"node-circle\">\n                  <v-icon v-if=\"progressPercentage >= 75\">mdi-check</v-icon>\n                  <span v-else>3</span>\n                </div>\n                <div class=\"node-label\">{{ $t('Third Calibration') }}</div>\n              </div>\n\n              <!-- 校准调整节点 -->\n              <div class=\"progress-node calibration-node\"\n                :class=\"{ 'active': progressPercentage >= 75, 'looping': progressPercentage >= 75 && progressPercentage < 95 }\">\n                <div class=\"node-circle\">\n                  <v-icon v-if=\"progressPercentage >= 95\">mdi-check</v-icon>\n                  <v-icon v-else-if=\"progressPercentage >= 75\">mdi-refresh</v-icon>\n                  <v-icon v-else>mdi-tune</v-icon>\n                </div>\n                <div class=\"node-label\">{{ $t('Calibration') }}</div>\n              </div>\n\n              <!-- 最终验证节点 -->\n              <div class=\"progress-node verification-node\" :class=\"{ 'active': progressPercentage >= 95 }\">\n                <div class=\"node-circle\">\n                  <v-icon v-if=\"isPolarAligned\">mdi-check</v-icon>\n                  <v-icon v-else>mdi-target</v-icon>\n                </div>\n                <div class=\"node-label\">{{ $t('Verification') }}</div>\n              </div>\n            </div>\n          </div>\n        </div>\n\n        <!-- 日志显示 -->\n        <div class=\"log-section\">\n          <div class=\"log-display\">\n            <div v-if=\"displayLogs.length > 0\" class=\"latest-log\" :class=\"displayLogs[0].level\">\n              <div class=\"log-timestamp\">{{ formatTime(displayLogs[0].timestamp) }}</div>\n              <div class=\"log-message\">{{ displayLogs[0].message }}</div>\n            </div>\n            <div v-else class=\"log-empty\">\n              {{ $t('No activity logs') }}\n            </div>\n          </div>\n        </div>\n\n        <!-- 位置信息 -->\n        <div class=\"position-section\">\n          <div class=\"position-grid\">\n            <div class=\"position-cell current\">\n              <div class=\"cell-label\">{{ $t('current RA') }}</div>\n              <div class=\"cell-value\">{{ currentPosition.ra }}</div>\n            </div>\n            <div class=\"position-cell current\">\n              <div class=\"cell-label\">{{ $t('current DEC') }}</div>\n              <div class=\"cell-value\">{{ currentPosition.dec }}</div>\n            </div>\n            <div class=\"position-cell target\">\n              <div class=\"cell-label\">{{ $t('target RA') }}</div>\n              <div class=\"cell-value\">{{ targetPosition.ra }}</div>\n            </div>\n            <div class=\"position-cell target\">\n              <div class=\"cell-label\">{{ $t('target DEC') }}</div>\n              <div class=\"cell-value\">{{ targetPosition.dec }}</div>\n            </div>\n          </div>\n        </div>\n\n        <!-- 调整指导 -->\n        <div class=\"adjustment-section\">\n          <div class=\"adjustment-instructions\">\n            <div class=\"adjustment-item\" :class=\"{ 'active': needsAzimuthAdjustment }\">\n              <div class=\"adjustment-icon\">\n                <v-icon>mdi-compass</v-icon>\n              </div>\n              <div class=\"adjustment-details\">\n                <div class=\"adjustment-header\">\n                  <span class=\"adjustment-type\">{{ $t('Azimuth') }}</span>\n                  <span class=\"adjustment-value\">{{ formatAdjustmentValue(adjustment.azimuth) }}</span>\n                </div>\n                <div class=\"adjustment-action\">\n                  {{ needsAzimuthAdjustment ? getAzimuthAction(adjustment.azimuth) : $t('No adjustment needed') }}\n                </div>\n\n              </div>\n            </div>\n\n            <div class=\"adjustment-item\" :class=\"{ 'active': needsAltitudeAdjustment }\">\n              <div class=\"adjustment-icon\">\n                <v-icon>mdi-compass</v-icon>\n              </div>\n              <div class=\"adjustment-details\">\n                <div class=\"adjustment-header\">\n                  <span class=\"adjustment-type\">{{ $t('Altitude') }}</span>\n                  <span class=\"adjustment-value\">{{ formatAdjustmentValue(adjustment.altitude) }}</span>\n                </div>\n                <div class=\"adjustment-action\">\n                  {{ needsAltitudeAdjustment ? getAltitudeAction(adjustment.altitude) : $t('No adjustment needed') }}\n                </div>\n\n              </div>\n            </div>\n          </div>\n        </div>\n\n        <!-- 控制按钮 -->\n        <div class=\"control-section\">\n          <div class=\"action-buttons\">\n            <button class=\"action-btn primary\" @click=\"startAutoCalibration\" :disabled=\"!canAutoCalibrate\">\n              <v-icon v-if=\"!isCalibrationRunning\">mdi-play-circle</v-icon>\n              <v-icon v-else>mdi-stop-circle</v-icon>\n              <span>{{ isCalibrationRunning ? $t('Stop Calibration') : $t('Start Auto Calibration') }}</span>\n            </button>\n\n\n\n          </div>\n        </div>\n      </div>\n    </div>\n  </div>\n\n  <!-- 轨迹画布：全屏模式 -->\n  <div v-if=\"visible && showTrajectoryOverlay && overlayMode === 'fullscreen'\" class=\"trajectory-overlay\"\n       @wheel.prevent=\"onOverlayWheel\" @mousedown.stop @touchstart.stop>\n    <canvas ref=\"trajectoryCanvas\"></canvas>\n    <button class=\"overlay-close-btn\" @click.stop=\"toggleTrajectoryOverlay\" :title=\"$t('Hide Trajectory Canvas')\">\n      <v-icon>mdi-close</v-icon>\n    </button>\n    <div class=\"overlay-hint\">{{ $t('Trajectory.Instruction') }}</div>\n    <div class=\"overlay-panel\">\n      <div class=\"panel-row\">\n        <span class=\"panel-label\">{{ $t('Current') }}:</span>\n        <span class=\"panel-value\">RA {{ currentPosition.ra }} / DEC {{ currentPosition.dec }}</span>\n      </div>\n      <div class=\"panel-row\">\n        <span class=\"panel-label\">{{ $t('Target') }}:</span>\n        <span class=\"panel-value\">RA {{ targetPosition.ra }} / DEC {{ targetPosition.dec }}</span>\n      </div>\n      <div class=\"panel-actions\">\n        <!-- <button class=\"panel-btn\" disabled :title=\"$t('Disabled')\">{{ $t('Clear All Trajectory') }}</button> -->\n        <button class=\"panel-btn\" @click.stop=\"clearOldTrajectory\">{{ $t('Clear Old Trajectory') }}</button>\n        <button class=\"panel-btn\" @click.stop=\"switchToWindowed\">{{ $t('Switch to Windowed Mode') }}</button>\n      </div>\n    </div>\n  </div>\n\n  <!-- 轨迹画布：窗口模式 -->\n  <div v-if=\"visible && showTrajectoryOverlay && overlayMode === 'windowed'\"\n       class=\"trajectory-window\" :style=\"{ left: windowedRect.x + 'px', top: windowedRect.y + 'px', width: windowedRect.width + 'px', height: windowedRect.height + 'px' }\"\n       @mousedown.stop @touchstart.stop>\n    <div class=\"window-header\" @mousedown.stop=\"startWindowDrag\" @touchstart.stop=\"startWindowDrag\">\n      <span class=\"window-title\">{{ $t('Trajectory') }}</span>\n      <div class=\"window-actions\">\n        <button class=\"panel-btn small\" @click.stop=\"switchToFullscreen\">{{ $t('Switch to Fullscreen Mode') }}</button>\n        <button class=\"panel-btn small\" @click.stop=\"clearOldTrajectory\">{{ $t('Clear Old Trajectory') }}</button>\n        <!-- <button class=\"panel-btn small\" disabled :title=\"$t('Disabled')\">{{ $t('Clear All Trajectory') }}</button> -->\n        <button class=\"panel-btn small\" @click.stop=\"toggleTrajectoryOverlay\" :title=\"$t('Hide Trajectory Canvas')\"><v-icon>mdi-close</v-icon></button>\n      </div>\n    </div>\n    <div class=\"window-content\">\n      <canvas ref=\"trajectoryCanvas\"></canvas>\n    </div>\n  </div>\n  </div>\n</template>\n\n<script>\n// 常量定义\nconst COLORS = {\n  PRIMARY: '#64b5f6',\n  SUCCESS: '#4caf50',\n  WARNING: '#ff9800',\n  ERROR: '#f44336',\n  INFO: '#2196f3',\n  WHITE: '#ffffff',\n  BACKGROUND: 'rgba(35, 35, 45, 0.95)',\n  SURFACE: 'rgba(60, 60, 70, 0.9)'\n}\n\nconst CALIBRATION_PHASES = {\n  INITIAL: 'initial',\n  COLLECTING: 'collecting',\n  ADJUSTING: 'adjusting',\n  VERIFYING: 'verifying'\n}\n\nconst PROGRESS_THRESHOLDS = {\n  INITIALIZATION: 15,\n  FIRST_CALIBRATION: 25,\n  SECOND_CALIBRATION: 50,\n  THIRD_CALIBRATION: 75,\n  CALIBRATION_LOOP: 95,\n  COMPLETION: 100\n}\n\nconst DIMENSIONS = {\n  MINIMIZED: { width: 250, height: 80 },\n  COLLAPSED: { width: 300, height: 120 },\n  EXPANDED: { width: 350, height: 400 }\n}\n\nconst LOG_LIMIT = 100\nconst DISPLAY_LOG_LIMIT = 10\n\nexport default {\n  name: 'AutomaticPolarAlignmentCalibration',\n\n  props: {\n    visible: {\n      type: Boolean,\n      default: false\n    },\n    autoStart: {\n      type: Boolean,\n      default: false\n    },\n    // 新增：传入调整数据的单位（'deg' | 'arcmin' | 'arcsec'）\n    adjustmentUnit: { type: String, default: 'arcmin' },\n\n    // 新增：用户站位视角（'north' | 'south'），用于左右映射\n    facingPole: { type: String, default: 'north' },\n\n    // 新增：动作死区（以角分定义，UI判定是否需要动作）\n    deadbandArcmin: { type: Number, default: 0.5 }\n  },\n\n  data() {\n    return {\n      // 连接状态\n      isConnected: false,\n\n      // 位置信息\n      currentPosition: {\n        ra: '00h 00m 00s',\n        dec: '+00° 00\\' 00\"'\n      },\n      targetPosition: {\n        ra: '00h 00m 00s',\n        dec: '+00° 00\\' 00\"'\n      },\n      previousPosition: {\n        ra: '00h 00m 00s',\n        dec: '+00° 00\\' 00\"'\n      },\n\n      // 校准数据\n      isCalibrationComplete: false,\n      isPolarAligned: false,\n\n      // 调整信息\n      adjustment: {\n        azimuth: 0.0,\n        altitude: 0.0\n      },\n\n      // 日志系统 - 使用循环数组优化内存\n      logs: [],\n      logIndex: 0,\n      logCapacity: LOG_LIMIT,\n\n      // 校准运行状态\n      isCalibrationRunning: false,\n\n      // 视场数据\n      fieldData: null,\n\n      // 当前进度\n      currentProgress: 0,\n\n      // === 新增：界面控制状态 ===\n      // 拖动状态\n      isDragging: false,\n      dragOffset: { x: 0, y: 0 },\n\n      // 控件位置\n      position: { x: 50, y: 50 },\n\n      // 界面状态\n      isMinimized: false,\n      isCollapsed: false,\n\n      // === 新增：性能优化 ===\n      // 缓存尺寸计算结果\n      cachedDimensions: {\n        width: 350,\n        height: 400\n      },\n      // 拖动状态标记\n      isDraggingState: false,\n\n      // 内存清理定时器\n      memoryCleanupTimer: null,\n\n      // 计算缓存\n      cachedAzimuthArcmin: null,\n      cachedAltitudeArcmin: null,\n      lastAzimuthValue: null,\n      lastAltitudeValue: null,\n\n      // 拖动性能优化\n      lastDragTime: 0,\n\n      // 极轴偏移量\n      polarAxisOffset: {\n        azimuth: 0,\n        altitude: 0\n      },\n\n      // 校准循环计数\n      calibrationLoopCount: 0,\n      lastCalibrationProgress: 0,\n\n      // 校准阶段状态\n      calibrationPhase: 'initial', // 'initial', 'collecting', 'adjusting', 'verifying'\n      calibrationPoints: [], // 存储三个校准点的坐标\n      maxCalibrationPoints: 3, // 最大校准点数量\n      targetPoint: null, // 存储目标点坐标\n\n      // 移除假极轴相关数据\n      // fakePolarAxis: {\n      //   ra: null,\n      //   dec: null,\n      //   calculated: false\n      // },\n\n      // === 轨迹画布状态 ===\n      showTrajectoryOverlay: false,\n      overlayMode: 'fullscreen', // 'fullscreen' | 'windowed'\n      trajectoryScale: 1, // 已弃用（不再使用手动缩放）\n      autoFitPxPerDeg: 40, // 自动适配计算出的 px/deg（基于当前画布尺寸与数据范围）\n      trajectoryPoints: [], // [{x, y}] in overlay canvas space after transform\n      rawTrajectoryPoints: [], // 保存原始的 {ra, dec} 序列\n      lastRawPosition: null, // {ra, dec} numeric\n      targetRawPosition: null, // {ra, dec} numeric, fixed as overlay center reference\n      windowedRect: { x: 40, y: 80, width: 420, height: 300 },\n      // 逻辑画布尺寸：用于窗口模式将“全屏画布”按比例缩放进窗口\n      baseCanvasLogicalSize: { width: 1280, height: 720 },\n      windowDrag: { active: false, offsetX: 0, offsetY: 0 },\n      // === 视图变换（仅缩小比例；以目标与首点填满画布） ===\n      currentPxPerDeg: null, // 当前像素/度，只会缩小\n      viewMinWorldX: null, // 世界坐标：X 为 dRA(unwrapped)，Y 为 dDec\n      viewMaxWorldX: null,\n      viewMinWorldY: null,\n      viewMaxWorldY: null,\n      raUnwrapAnchor: null, // dRA 展开锚点（首点相对目标）\n      viewPadRatioX: 0.12,\n      viewPadRatioY: 0.10,\n      viewOffsetXPx: 0,\n      viewOffsetYPx: 0,\n      // 轨迹点合并容差（角分）\n      trajectoryMergeTolArcmin: 2.0,  // 轨迹点合并容差（角分）\n      calibrationCircleArcmin: 1.0,  // 校准圆半径（角分）-- 约等于校准精度\n\n      hasAcceptUpdateMessage: false, // 是否已经接受更新消息,防止由于组件加载顺序导致组件更新丢失\n    }\n  },\n\n  computed: {\n    // 显示的日志 - 使用缓存优化\n    displayLogs() {\n      // 返回最近的10条日志，按时间倒序（用于显示最新一条）\n      const logs = this.logs\n      if (logs.length <= DISPLAY_LOG_LIMIT) {\n        return logs.slice().reverse()\n      }\n      return logs.slice(-DISPLAY_LOG_LIMIT).reverse()\n    },\n\n    // 校准进度百分比\n    progressPercentage() {\n      // 使用从后端传入的进度\n      return this.currentProgress\n    },\n\n    // 是否可以自动校准\n    canAutoCalibrate() {\n      return this.isConnected\n    },\n\n    // 是否需要方位角调整 - 使用缓存避免重复计算\n    needsAzimuthAdjustment() {\n      const v = this.adjustment?.azimuth\n      if (!Number.isFinite(v)) return false\n      // 使用缓存的值，避免重复计算\n      return this.cachedAzimuthArcmin !== null ? \n        Math.abs(this.cachedAzimuthArcmin) > this.deadbandArcmin : \n        Math.abs(this.unitToArcmin(v, this.adjustmentUnit)) > this.deadbandArcmin\n    },\n\n    // 是否需要高度角调整 - 使用缓存避免重复计算\n    needsAltitudeAdjustment() {\n      const v = this.adjustment?.altitude\n      if (!Number.isFinite(v)) return false\n      // 使用缓存的值，避免重复计算\n      return this.cachedAltitudeArcmin !== null ? \n        Math.abs(this.cachedAltitudeArcmin) > this.deadbandArcmin : \n        Math.abs(this.unitToArcmin(v, this.adjustmentUnit)) > this.deadbandArcmin\n    }\n  },\n\n  watch: {\n    visible(newVal) {\n      if (newVal && this.autoStart) {\n        this.startAutoCalibration()\n      }\n    },\n    \n    // 监听当前坐标变化，自动更新朝向极点\n    '$store.state.currentLocation.lat': {\n      handler(newLat, oldLat) {\n        if (newLat !== oldLat && newLat !== undefined) {\n          const facingPole = this.calculateFacingPole()\n          this.addLog(this.$t('Location Changed', [facingPole, newLat]), 'info')\n          \n          // 如果正在调整阶段，重新计算调整建议\n          if (this.calibrationPhase === 'adjusting') {\n            this.addLog(this.$t('Recalculating Adjustment Directions'), 'info')\n          }\n        }\n      },\n      immediate: false\n    },\n\n    // 监听调整值变化，更新缓存 - 使用防抖避免频繁更新\n    'adjustment.azimuth': {\n      handler: function(newVal) {\n        if (Number.isFinite(newVal)) {\n          // 清除之前的定时器\n          if (this._azimuthUpdateTimer) {\n            clearTimeout(this._azimuthUpdateTimer)\n          }\n          // 使用防抖，延迟100ms更新\n          this._azimuthUpdateTimer = setTimeout(() => {\n            this.cachedAzimuthArcmin = this.unitToArcmin(newVal, this.adjustmentUnit)\n            this.lastAzimuthValue = newVal\n          }, 100)\n        }\n      },\n      immediate: true\n    },\n\n    'adjustment.altitude': {\n      handler: function(newVal) {\n        if (Number.isFinite(newVal)) {\n          // 清除之前的定时器\n          if (this._altitudeUpdateTimer) {\n            clearTimeout(this._altitudeUpdateTimer)\n          }\n          // 使用防抖，延迟100ms更新\n          this._altitudeUpdateTimer = setTimeout(() => {\n            this.cachedAltitudeArcmin = this.unitToArcmin(newVal, this.adjustmentUnit)\n            this.lastAltitudeValue = newVal\n          }, 100)\n        }\n      },\n      immediate: true\n    }\n  },\n\n    mounted() {\n      // 实现组件初始化逻辑\n      this.initialize()\n\n      // 初始化缓存的尺寸信息\n      this.updateCachedDimensions()\n\n      // 监听信号总线事件\n      this.$bus.$on('showPolarAlignment', this.showInterface)\n      this.$bus.$on('hidePolarAlignment', this.hideInterface)\n\n      // 监听赤道仪连接状态\n      this.$bus.$on('MountConnected', this.updateMountConnection)\n\n      // 接收状态更新\n      this.$bus.$on('PolarAlignmentState', this.updatePolarAlignmentState)\n\n      // 监听视场数据更新\n      this.$bus.$on('FieldDataUpdate', this.updateFieldData)\n\n      // 监听卡片信息更新\n      this.$bus.$on('updateCardInfo', this.updateCardInfo)\n\n      // 监听自动校准状态\n      this.$bus.$on('PolarAlignmentIsRunning', this.updatePolarAlignmentIsRunning)\n\n      // 组件加载完成后，若尚未收到更新消息，则主动请求极轴对齐状态\n      if (!this.hasAcceptUpdateMessage) {\n        this.$bus.$emit('AppSendMessage', 'Vue_Command', 'getPolarAlignmentState')\n      }\n\n      // 启动定期内存清理（每5分钟清理一次）\n      this.startMemoryCleanup()\n    },\n\n    beforeDestroy() {\n      // 移除信号总线监听\n      this.$bus.$off('showPolarAlignment', this.showInterface)\n      this.$bus.$off('hidePolarAlignment', this.hideInterface)\n      this.$bus.$off('MountConnected', this.updateMountConnection)\n      this.$bus.$off('PolarAlignmentState', this.updatePolarAlignmentState)\n      this.$bus.$off('FieldDataUpdate', this.updateFieldData)\n      this.$bus.$off('updateCardInfo', this.updateCardInfo)\n      this.$bus.$off('PolarAlignmentIsRunning', this.updatePolarAlignmentIsRunning)\n\n      // 清理拖动事件监听\n      this.cleanupDragListeners()\n\n      // 清理缓存数据\n      this.clearCachedData()\n\n      // 停止内存清理定时器\n      this.stopMemoryCleanup()\n\n      // 清理防抖定时器\n      this.clearDebounceTimers()\n\n      // 实现组件销毁逻辑\n      this.cleanup()\n    },\n\n    methods: {\n      // ========================================\n      // 信号总线事件处理\n      // ========================================\n      showInterface() {\n        this.$emit('update:visible', true)\n      },\n\n      hideInterface() {\n        this.$emit('update:visible', false)\n      },\n\n      updateMountConnection(status) {\n        this.isConnected = status === 1\n        const statusText = this.isConnected ? this.$t('Connected') : this.$t('Disconnected')\n        this.addLog(this.$t('Mount Connection Status', [statusText]), this.isConnected ? 'success' : 'warning')\n      },\n\n      // ========================================\n      // 初始化和清理\n      // ========================================\n      initialize() {\n        this.addLog(this.$t('Polar Alignment Component Initialized'), 'info')\n        \n        // 记录当前朝向极点\n        const facingPole = this.calculateFacingPole()\n        const lat = this.$store?.state?.currentLocation?.lat || 'unknown'\n        this.addLog(this.$t('Facing Pole', [facingPole, lat]), 'info')\n      },\n\n      cleanup() {\n        this.addLog(this.$t('Polar Alignment Component Cleaned'), 'info')\n      },\n\n      // 内存使用监控（仅在开发环境）\n      getMemoryUsage() {\n        if (process.env.NODE_ENV === 'development' && performance.memory) {\n          return {\n            usedJSHeapSize: Math.round(performance.memory.usedJSHeapSize / 1024 / 1024) + 'MB',\n            totalJSHeapSize: Math.round(performance.memory.totalJSHeapSize / 1024 / 1024) + 'MB',\n            jsHeapSizeLimit: Math.round(performance.memory.jsHeapSizeLimit / 1024 / 1024) + 'MB',\n            logsCount: this.logs.length,\n            calibrationPointsCount: this.calibrationPoints.length\n          }\n        }\n        return null\n      },\n\n      // 启动定期内存清理\n      startMemoryCleanup() {\n        this.memoryCleanupTimer = setInterval(() => {\n          this.performMemoryCleanup()\n        }, 5 * 60 * 1000) // 每5分钟清理一次\n      },\n\n      // 停止内存清理定时器\n      stopMemoryCleanup() {\n        if (this.memoryCleanupTimer) {\n          clearInterval(this.memoryCleanupTimer)\n          this.memoryCleanupTimer = null\n        }\n      },\n\n      // 执行内存清理\n      performMemoryCleanup() {\n        // 清理过期的日志（保留最近50条）\n        if (this.logs.length > 50) {\n          this.logs = this.logs.slice(-50)\n          this.logIndex = Math.min(this.logIndex, 50)\n        }\n\n        // 清理过期的校准点（如果超过最大数量）\n        if (this.calibrationPoints.length > this.maxCalibrationPoints) {\n          this.calibrationPoints = this.calibrationPoints.slice(-this.maxCalibrationPoints)\n        }\n\n        // 强制垃圾回收（如果可用）\n        if (window.gc && typeof window.gc === 'function') {\n          window.gc()\n        }\n\n        // 在开发环境输出内存使用情况\n        if (process.env.NODE_ENV === 'development') {\n          const memoryInfo = this.getMemoryUsage()\n          if (memoryInfo) {\n            console.log('Memory cleanup performed:', memoryInfo)\n          }\n        }\n      },\n\n      // 清理拖动事件监听器\n      cleanupDragListeners() {\n        document.removeEventListener('mousemove', this.onDrag)\n        document.removeEventListener('mouseup', this.stopDrag)\n        document.removeEventListener('touchmove', this.onDrag)\n        document.removeEventListener('touchend', this.stopDrag)\n      },\n\n      // 清理防抖定时器\n      clearDebounceTimers() {\n        if (this._azimuthUpdateTimer) {\n          clearTimeout(this._azimuthUpdateTimer)\n          this._azimuthUpdateTimer = null\n        }\n        if (this._altitudeUpdateTimer) {\n          clearTimeout(this._altitudeUpdateTimer)\n          this._altitudeUpdateTimer = null\n        }\n      },\n\n      // 清理缓存数据\n      clearCachedData() {\n        // 清理计算缓存\n        this.cachedAzimuthArcmin = null\n        this.cachedAltitudeArcmin = null\n        this.lastAzimuthValue = null\n        this.lastAltitudeValue = null\n        this.lastDragTime = 0\n        \n        // 清理日志数据\n        this.logs = []\n        this.logIndex = 0\n        \n        // 清理校准数据\n        this.calibrationPoints = []\n        this.targetPoint = null\n        this.fieldData = null\n        \n        // 清理位置数据\n        this.currentPosition = { ra: '00h 00m 00s', dec: '+00° 00\\' 00\"' }\n        this.targetPosition = { ra: '00h 00m 00s', dec: '+00° 00\\' 00\"' }\n        this.previousPosition = { ra: '00h 00m 00s', dec: '+00° 00\\' 00\"' }\n        \n        // 清理调整数据\n        this.adjustment = { azimuth: 0.0, altitude: 0.0 }\n        this.polarAxisOffset = { azimuth: 0, altitude: 0 }\n        \n        // 重置状态\n        this.isCalibrationComplete = false\n        this.isPolarAligned = false\n        this.calibrationLoopCount = 0\n        this.lastCalibrationProgress = 0\n        this.calibrationPhase = 'initial'\n      },\n\n      // ========================================\n      // 拖动控制方法\n      // ========================================\n      startDrag(event) {\n        if (event.target.closest('.header-controls, .minimized-controls, .header-btn, .minimized-btn')) {\n          return\n        }\n\n        this.isDragging = true\n        this.isDraggingState = true\n\n        // 添加dragging类，移除过渡动画\n        this.$el.classList.add('dragging')\n\n        const rect = event.currentTarget.getBoundingClientRect()\n        const clientX = event.clientX || event.touches?.[0]?.clientX || 0\n        const clientY = event.clientY || event.touches?.[0]?.clientY || 0\n\n        this.dragOffset = {\n          x: clientX - rect.left,\n          y: clientY - rect.top\n        }\n\n        // 预计算并缓存尺寸，避免拖动时重复计算\n        this.updateCachedDimensions()\n\n        // 优化触摸事件处理\n        if (event.type === 'touchstart') {\n          document.addEventListener('touchmove', this.onDrag, { passive: false })\n          document.addEventListener('touchend', this.stopDrag, { passive: false })\n        } else {\n          document.addEventListener('mousemove', this.onDrag)\n          document.addEventListener('mouseup', this.stopDrag)\n        }\n      },\n\n      onDrag(event) {\n        if (!this.isDragging) return\n\n        // 阻止默认行为，提高触摸响应性\n        if (event.type === 'touchmove') {\n          event.preventDefault()\n        }\n\n        // 使用更高效的节流机制\n        const now = Date.now()\n        if (this.lastDragTime && now - this.lastDragTime < 16) return // 60fps限制\n        this.lastDragTime = now\n        \n        const clientX = event.clientX || event.touches?.[0]?.clientX || 0\n        const clientY = event.clientY || event.touches?.[0]?.clientY || 0\n\n        const newX = clientX - this.dragOffset.x\n        const newY = clientY - this.dragOffset.y\n\n        // 使用缓存的尺寸，避免重复计算\n        const maxX = window.innerWidth - this.cachedDimensions.width\n        const maxY = window.innerHeight - this.cachedDimensions.height\n\n        this.position = {\n          x: Math.max(0, Math.min(newX, maxX)),\n          y: Math.max(0, Math.min(newY, maxY))\n        }\n      },\n\n      stopDrag() {\n        this.isDragging = false\n        this.isDraggingState = false\n\n        // 移除dragging类，恢复过渡动画\n        this.$el.classList.remove('dragging')\n\n        // 清理所有事件监听器\n        this.cleanupDragListeners()\n      },\n\n      // 新增：更新缓存的尺寸信息\n      updateCachedDimensions() {\n        if (this.isMinimized) {\n          this.cachedDimensions = { ...DIMENSIONS.MINIMIZED }\n        } else if (this.isCollapsed) {\n          this.cachedDimensions = { ...DIMENSIONS.COLLAPSED }\n        } else {\n          // 展开状态，使用基础尺寸\n          this.cachedDimensions = { ...DIMENSIONS.EXPANDED }\n        }\n      },\n\n      // 获取组件高度（优化版本）\n      getComponentHeight() {\n        // 如果正在拖动，使用缓存的尺寸\n        if (this.isDraggingState) {\n          return this.cachedDimensions.height\n        }\n\n        // 正常状态下的计算\n        if (this.isMinimized) {\n          return 80 // 最小化状态高度\n        } else if (this.isCollapsed) {\n          return 120 // 收缩状态高度\n        } else {\n          // 展开状态，根据内容自适应\n          const baseHeight = 400 // 基础高度\n          const logHeight = this.displayLogs.length > 0 ? 60 : 40\n          const adjustmentHeight = this.needsAzimuthAdjustment || this.needsAltitudeAdjustment ? 120 : 80\n          return Math.min(baseHeight + logHeight + adjustmentHeight, window.innerHeight * 0.8)\n        }\n      },\n\n      // ========================================\n      // 界面状态控制方法\n      // ========================================\n      toggleMinimize() {\n        this.isMinimized = !this.isMinimized\n        this.isCollapsed = false\n        // 更新缓存的尺寸信息\n        this.updateCachedDimensions()\n        this.addLog(this.isMinimized ? this.$t('Interface Minimized') : this.$t('Interface Expanded'), 'info')\n      },\n\n      toggleCollapse() {\n        this.isCollapsed = !this.isCollapsed\n        // 更新缓存的尺寸信息\n        this.updateCachedDimensions()\n        this.addLog(this.isCollapsed ? this.$t('Interface Collapsed') : this.$t('Interface Expanded'), 'info')\n      },\n\n      // === 轨迹画布相关 ===\n      toggleTrajectoryOverlay() {\n        this.showTrajectoryOverlay = !this.showTrajectoryOverlay\n        if (this.showTrajectoryOverlay) {\n          if (this.overlayMode === 'fullscreen') this.enableOverlayEventCapture(); else this.disableOverlayEventCapture()\n          this.$nextTick(() => {\n            this.initTrajectoryCanvas()\n            this.redrawTrajectory()\n          })\n        } else {\n          this.disableOverlayEventCapture()\n        }\n      },\n      switchToWindowed() {\n        this.overlayMode = 'windowed'\n        this.disableOverlayEventCapture()\n        this.resetViewMapping()\n        this.$nextTick(() => {\n          this.initTrajectoryCanvas()\n          this.redrawTrajectory()\n        })\n      },\n      switchToFullscreen() {\n        this.overlayMode = 'fullscreen'\n        this.enableOverlayEventCapture()\n        this.resetViewMapping()\n        this.clearTrajectoryCanvas()\n        this.$nextTick(() => {\n          this.initTrajectoryCanvas()\n          this.redrawTrajectory()\n        })\n      },\n      onOverlayWheel(e) {\n        // 已取消全屏缩放需求：忽略滚轮，仅防止穿透\n        e.preventDefault()\n      },\n      resetViewMapping() {\n        this.currentPxPerDeg = null\n        this.viewMinWorldX = null\n        this.viewMaxWorldX = null\n        this.viewMinWorldY = null\n        this.viewMaxWorldY = null\n        this.raUnwrapAnchor = null\n        this.viewOffsetXPx = 0\n        this.viewOffsetYPx = 0\n      },\n      // 清空视图映射，但保留 RA 展开锚点，防止清理旧点或模式切换时方向翻转\n      resetViewMappingKeepAnchor() {\n        const anchor = this.raUnwrapAnchor\n        this.currentPxPerDeg = null\n        this.viewMinWorldX = null\n        this.viewMaxWorldX = null\n        this.viewMinWorldY = null\n        this.viewMaxWorldY = null\n        this.viewOffsetXPx = 0\n        this.viewOffsetYPx = 0\n        this.raUnwrapAnchor = anchor\n      },\n      startWindowDrag(event) {\n        const e = event.touches ? event.touches[0] : event\n        this.windowDrag.active = true\n        this.windowDrag.offsetX = e.clientX - this.windowedRect.x\n        this.windowDrag.offsetY = e.clientY - this.windowedRect.y\n        window.addEventListener('mousemove', this.onWindowDragMove, { passive: false })\n        window.addEventListener('mouseup', this.stopWindowDrag, { passive: false })\n        window.addEventListener('touchmove', this.onWindowDragMove, { passive: false })\n        window.addEventListener('touchend', this.stopWindowDrag, { passive: false })\n      },\n      onWindowDragMove(event) {\n        if (!this.windowDrag.active) return\n        const e = event.touches ? event.touches[0] : event\n        const nx = e.clientX - this.windowDrag.offsetX\n        const ny = e.clientY - this.windowDrag.offsetY\n        this.windowedRect.x = Math.max(0, Math.min(nx, window.innerWidth - this.windowedRect.width))\n        this.windowedRect.y = Math.max(0, Math.min(ny, window.innerHeight - this.windowedRect.height))\n      },\n      stopWindowDrag() {\n        this.windowDrag.active = false\n        window.removeEventListener('mousemove', this.onWindowDragMove)\n        window.removeEventListener('mouseup', this.stopWindowDrag)\n        window.removeEventListener('touchmove', this.onWindowDragMove)\n        window.removeEventListener('touchend', this.stopWindowDrag)\n      },\n      enableOverlayEventCapture() {\n        // 拦截全局滚轮/触摸/鼠标事件，避免穿透到底图\n        const preventAll = e => { e.preventDefault(); e.stopPropagation(); }\n        this._overlayHandlers = this._overlayHandlers || {}\n        this._overlayHandlers.wheel = preventAll\n        this._overlayHandlers.touchmove = preventAll\n        this._overlayHandlers.mousedown = preventAll\n        window.addEventListener('wheel', this._overlayHandlers.wheel, { passive: false, capture: true })\n        window.addEventListener('touchmove', this._overlayHandlers.touchmove, { passive: false, capture: true })\n        window.addEventListener('mousedown', this._overlayHandlers.mousedown, { passive: false, capture: true })\n      },\n      disableOverlayEventCapture() {\n        if (!this._overlayHandlers) return\n        window.removeEventListener('wheel', this._overlayHandlers.wheel, { capture: true })\n        window.removeEventListener('touchmove', this._overlayHandlers.touchmove, { capture: true })\n        window.removeEventListener('mousedown', this._overlayHandlers.mousedown, { capture: true })\n        this._overlayHandlers = null\n      },\n      clearAllTrajectory() {\n        this.rawTrajectoryPoints = []\n        this.trajectoryPoints = []\n        this.lastRawPosition = null\n        this.resetViewMapping()\n        this.redrawTrajectory()\n      },\n      clearOldTrajectory() {\n        if (this.rawTrajectoryPoints.length <= 2) return\n        this.rawTrajectoryPoints = this.rawTrajectoryPoints.slice(-2)\n        this.trajectoryPoints = []\n        this.resetViewMappingKeepAnchor()\n        this.redrawTrajectory()\n      },\n      initTrajectoryCanvas() {\n        const canvas = this.$refs.trajectoryCanvas\n        if (!canvas) return\n        const dpr = window.devicePixelRatio || 1\n        let w, h, scaleX = 1, scaleY = 1\n        if (this.overlayMode === 'fullscreen') {\n          w = window.innerWidth\n          h = window.innerHeight\n          canvas.width = Math.round(w * dpr)\n          canvas.height = Math.round(h * dpr)\n          canvas.style.width = w + 'px'\n          canvas.style.height = h + 'px'\n        } else {\n          // 窗口模式：使用逻辑画布尺寸，绘制后整体缩放到窗口区域\n          const HEADER = 32\n          const vw = Math.max(50, Math.round(this.windowedRect.width))\n          const vh = Math.max(50, Math.round(this.windowedRect.height - HEADER))\n          const lw = this.baseCanvasLogicalSize.width\n          const lh = this.baseCanvasLogicalSize.height\n          // 计算将逻辑画布缩放到可视窗口的缩放比\n          scaleX = vw / lw\n          scaleY = vh / lh\n          // Canvas 显示尺寸 = 窗口尺寸，内部像素 = 显示尺寸 * DPR\n          w = vw\n          h = vh\n          canvas.style.width = vw + 'px'\n          canvas.style.height = vh + 'px'\n          canvas.width = Math.round(vw * dpr)\n          canvas.height = Math.round(vh * dpr)\n        }\n        const ctx = canvas.getContext('2d')\n        // 设置设备像素比缩放\n        ctx.setTransform(dpr, 0, 0, dpr, 0, 0)\n        // 窗口模式下增加整体缩放，将逻辑画布缩放到窗口尺寸\n        if (this.overlayMode === 'windowed') {\n          ctx.scale(scaleX, scaleY)\n        }\n        this.clearTrajectoryCanvas()\n        // 背景由 drawTargetMarker 统一绘制\n      },\n      clearTrajectoryCanvas() {\n        const canvas = this.$refs.trajectoryCanvas\n        if (!canvas) return\n        const ctx = canvas.getContext('2d')\n        ctx.save()\n        ctx.setTransform(1, 0, 0, 1, 0, 0)\n        ctx.clearRect(0, 0, canvas.width, canvas.height)\n        ctx.restore()\n      },\n      // === 视图映射与工具 ===\n      getCanvasGeom() {\n        const canvas = this.$refs.trajectoryCanvas\n        if (!canvas) return null\n        // 在窗口模式下，Canvas 内部逻辑为 baseCanvasLogicalSize，\n        // 外部通过 ctx.scale 显示到窗口，所以几何计算返回逻辑尺寸\n        const w = this.overlayMode === 'windowed' ? this.baseCanvasLogicalSize.width : canvas.clientWidth\n        const h = this.overlayMode === 'windowed' ? this.baseCanvasLogicalSize.height : canvas.clientHeight\n        const padX = Math.round(w * (this.viewPadRatioX || 0.12))\n        const padY = Math.round(h * (this.viewPadRatioY || 0.10))\n        return { w, h, padX, padY }\n      },\n      worldForPoint(raDeg, decDeg, timeMsOrDate = null) {\n        // 使用地平坐标（Az/Alt）绘制：世界坐标以“目标点”为原点\n        if (!this.targetRawPosition) return { x: 0, y: 0 }\n        const loc = this.$store?.state?.currentLocation || {}\n        const lat = Number(loc.lat)\n        const lon = Number(loc.lng)\n        if (!Number.isFinite(lat) || !Number.isFinite(lon)) return { x: 0, y: 0 }\n        const t = (timeMsOrDate instanceof Date) ? timeMsOrDate : new Date(timeMsOrDate || Date.now())\n        const cur = this.equatorialToHorizontal(raDeg, decDeg, t, lat, lon)\n        const tgt = this.equatorialToHorizontal(this.targetRawPosition.ra, this.targetRawPosition.dec, t, lat, lon)\n        let dx = this.normalizeAzDelta(cur.az - tgt.az) // dAz（考虑 0/360 包裹）\n        let dy = cur.alt - tgt.alt                    // dAlt\n        // 使用基于首点的展开锚点，避免跨 0/360 跳变\n        if (this.raUnwrapAnchor != null) {\n          while (dx - this.raUnwrapAnchor > 180) dx -= 360\n          while (dx - this.raUnwrapAnchor < -180) dx += 360\n        }\n        return { x: dx, y: dy }\n      },\n      makeWorldSeq(rawPoints) {\n        if (!this.targetRawPosition || !rawPoints || rawPoints.length === 0) return []\n        const loc = this.$store?.state?.currentLocation || {}\n        const lat = Number(loc.lat)\n        const lon = Number(loc.lng)\n        if (!Number.isFinite(lat) || !Number.isFinite(lon)) return []\n        const times = rawPoints.map((p, idx) => {\n          if (p.t) return new Date(p.t)\n          if (idx > 0 && rawPoints[idx - 1].t) return new Date(rawPoints[idx - 1].t)\n          return new Date()\n        })\n        const targAltAz = times.map(t => this.equatorialToHorizontal(this.targetRawPosition.ra, this.targetRawPosition.dec, t, lat, lon))\n        const curAltAz = rawPoints.map((p, i) => this.equatorialToHorizontal(p.ra, p.dec, times[i], lat, lon))\n        const dAzNorm = curAltAz.map((c, i) => this.normalizeAzDelta(c.az - targAltAz[i].az))\n        let anchor = this.raUnwrapAnchor\n        if (anchor == null && dAzNorm.length > 0) anchor = dAzNorm[0]\n        const aligned = dAzNorm.map(x => {\n          let v = x\n          while (v - anchor > 180) v -= 360\n          while (v - anchor < -180) v += 360\n          return v\n        })\n        const dAzs = this.unwrapRaDeltaSequence(aligned)\n        return rawPoints.map((p, i) => ({ x: dAzs[i], y: curAltAz[i].alt - targAltAz[i].alt }))\n      },\n      // 基于“全量轨迹”的连续展开，返回用于垂线的最后两点世界坐标（允许超出常规范围）\n      getWorldABForPerp() {\n        if (!this.targetRawPosition || this.rawTrajectoryPoints.length < 2) return null\n        const loc = this.$store?.state?.currentLocation || {}\n        const lat = Number(loc.lat)\n        const lon = Number(loc.lng)\n        if (!Number.isFinite(lat) || !Number.isFinite(lon)) return null\n        const all = this.rawTrajectoryPoints\n        const tA = new Date(all[all.length - 2].t || Date.now())\n        const tB = new Date(all[all.length - 1].t || Date.now())\n        const tgtA = this.equatorialToHorizontal(this.targetRawPosition.ra, this.targetRawPosition.dec, tA, lat, lon)\n        const tgtB = this.equatorialToHorizontal(this.targetRawPosition.ra, this.targetRawPosition.dec, tB, lat, lon)\n        const curA = this.equatorialToHorizontal(all[all.length - 2].ra, all[all.length - 2].dec, tA, lat, lon)\n        const curB = this.equatorialToHorizontal(all[all.length - 1].ra, all[all.length - 1].dec, tB, lat, lon)\n        let dxA = this.normalizeAzDelta(curA.az - tgtA.az)\n        let dxB = this.normalizeAzDelta(curB.az - tgtB.az)\n        if (this.raUnwrapAnchor != null) {\n          while (dxA - this.raUnwrapAnchor > 180) dxA -= 360\n          while (dxA - this.raUnwrapAnchor < -180) dxA += 360\n          while (dxB - this.raUnwrapAnchor > 180) dxB -= 360\n          while (dxB - this.raUnwrapAnchor < -180) dxB += 360\n        }\n        const A = { x: dxA, y: curA.alt - tgtA.alt }\n        const B = { x: dxB, y: curB.alt - tgtB.alt }\n        return { A, B }\n      },\n      screenForWorld(wx, wy) {\n        const g = this.getCanvasGeom()\n        if (!g || !Number.isFinite(this.currentPxPerDeg)) return { x: 0, y: 0 }\n        const { w, h, padX, padY } = g\n        const x = padX + this.viewOffsetXPx + (wx - (this.viewMinWorldX || 0)) * this.currentPxPerDeg\n        const y = h - padY - this.viewOffsetYPx - (wy - (this.viewMinWorldY || 0)) * this.currentPxPerDeg\n        return { x, y }\n      },\n      ensureViewMappingInitialized(seqWorld) {\n        if (!seqWorld || seqWorld.length === 0) return\n        if (this.currentPxPerDeg != null && this.viewMinWorldX != null) return\n        const g = this.getCanvasGeom()\n        if (!g) return\n        const { w, h, padX, padY } = g\n        // 起始点：序列第一个；目标原点为 (0,0)\n        const first = seqWorld[0]\n        // 初始化展开锚点为首点 X（相对目标）\n        this.raUnwrapAnchor = first.x\n        const minX = Math.min(0, first.x)\n        const maxX = Math.max(0, first.x)\n        const minY = Math.min(0, first.y)\n        const maxY = Math.max(0, first.y)\n        const spanX = Math.max(1e-6, maxX - minX)\n        const spanY = Math.max(1e-6, maxY - minY)\n        const scaleX = (w - 2 * padX) / spanX\n        const scaleY = (h - 2 * padY) / spanY\n        this.currentPxPerDeg = Math.max(5, Math.min(scaleX, scaleY))\n        this.viewMinWorldX = minX\n        this.viewMaxWorldX = maxX\n        this.viewMinWorldY = minY\n        this.viewMaxWorldY = maxY\n        // 初次视图内容居中：仅在初始化时设置一次偏移\n        const contentWpx = spanX * this.currentPxPerDeg\n        const contentHpx = spanY * this.currentPxPerDeg\n        this.viewOffsetXPx = Math.round(((w - 2 * padX) - contentWpx) / 2)\n        this.viewOffsetYPx = Math.round(((h - 2 * padY) - contentHpx) / 2)\n      },\n      maybeExpandViewForPoint(wx, wy) {\n        // 若点在当前屏幕内，则不更新比例尺；若越界，扩展边界并仅缩小比例尺\n        const g = this.getCanvasGeom()\n        if (!g || this.currentPxPerDeg == null) return\n        const { w, h, padX, padY } = g\n        const px = padX + this.viewOffsetXPx + (wx - this.viewMinWorldX) * this.currentPxPerDeg\n        const py = h - padY - this.viewOffsetYPx - (wy - this.viewMinWorldY) * this.currentPxPerDeg\n        const inside = px >= padX && px <= (w - padX) && py >= padY && py <= (h - padY)\n        if (inside) return\n        // 扩展世界边界到包含该点\n        const newMinX = Math.min(this.viewMinWorldX, wx)\n        const newMaxX = Math.max(this.viewMaxWorldX, wx)\n        const newMinY = Math.min(this.viewMinWorldY, wy)\n        const newMaxY = Math.max(this.viewMaxWorldY, wy)\n        const spanX = Math.max(1e-6, newMaxX - newMinX)\n        const spanY = Math.max(1e-6, newMaxY - newMinY)\n        const scaleX = (w - 2 * padX) / spanX\n        const scaleY = (h - 2 * padY) / spanY\n        const candidate = Math.max(5, Math.min(scaleX, scaleY))\n        // 仅缩小\n        this.currentPxPerDeg = this.currentPxPerDeg == null ? candidate : Math.min(this.currentPxPerDeg, candidate)\n        this.viewMinWorldX = newMinX\n        this.viewMaxWorldX = newMaxX\n        this.viewMinWorldY = newMinY\n        this.viewMaxWorldY = newMaxY\n        // 固定锚点：不再重算偏移，保持目标点屏幕位置恒定\n      },\n      drawTargetMarker(scaleOverride = null) {\n        const canvas = this.$refs.trajectoryCanvas\n        if (!canvas) return\n        const ctx = canvas.getContext('2d')\n        const g = this.getCanvasGeom()\n        if (!g) return\n        const { w, h } = g\n        ctx.save()\n        // 背景\n        ctx.fillStyle = 'black'\n        ctx.fillRect(0, 0, w, h)\n        // 目标圆环\n        const center = this.screenForWorld(0, 0)\n        const ringDeg = this.getTargetRingDeg()\n        const scale = (scaleOverride != null ? scaleOverride : this.currentPxPerDeg) || 40\n        // 半径限制：不超出可见区域\n        const rPx = Math.max(6, Math.min(Math.min(w, h) * 0.45, ringDeg * scale))\n        ctx.strokeStyle = '#4CAF50'\n        ctx.lineWidth = 2\n        ctx.beginPath()\n        ctx.arc(center.x, center.y, rPx, 0, Math.PI * 2)\n        ctx.stroke()\n        ctx.fillStyle = '#4CAF50'\n        ctx.beginPath()\n        ctx.arc(center.x, center.y, 3, 0, Math.PI * 2)\n        ctx.fill()\n        ctx.restore()\n      },\n      drawTargetAtCenter(ringDegOverride = null) {\n        const canvas = this.$refs.trajectoryCanvas\n        if (!canvas) return\n        const ctx = canvas.getContext('2d')\n        const cx = Math.round((this.overlayMode === 'windowed' ? this.baseCanvasLogicalSize.width : canvas.clientWidth) / 2)\n        const cy = Math.round((this.overlayMode === 'windowed' ? this.baseCanvasLogicalSize.height : canvas.clientHeight) / 2)\n        ctx.save()\n        // 黑色背景\n        ctx.fillStyle = 'black'\n        const bw = this.overlayMode === 'windowed' ? this.baseCanvasLogicalSize.width : canvas.clientWidth\n        const bh = this.overlayMode === 'windowed' ? this.baseCanvasLogicalSize.height : canvas.clientHeight\n        ctx.fillRect(0, 0, bw, bh)\n        // 目标点环（空心）+ 中心小点\n        const base = this.autoFitPxPerDeg || 40\n        const scalePxPerDeg = base\n        const ringDeg = ringDegOverride !== null ? ringDegOverride : this.getTargetRingDeg()\n        const halfW = bw / 2\n        const halfH = bh / 2\n        const pad = 24\n        const rMax = Math.max(6, Math.min(halfW - pad, halfH - pad))\n        const rPx = Math.max(6, Math.min(rMax, ringDeg * scalePxPerDeg))\n        // 空心圆\n        ctx.strokeStyle = '#4CAF50'\n        ctx.lineWidth = 2\n        ctx.beginPath()\n        ctx.arc(cx, cy, rPx, 0, Math.PI * 2)\n        ctx.stroke()\n        // 中心小点\n        ctx.fillStyle = '#4CAF50'\n        ctx.beginPath()\n        ctx.arc(cx, cy, 3, 0, Math.PI * 2)\n        ctx.fill()\n        ctx.restore()\n      },\n      getTargetRingDeg() {\n        // 环大小不超过视场半径（取 RA/DEC 跨度的较小一半，留 90% 边距）\n        if (!this.fieldData) return 0.3\n        const ras = [this.fieldData.ra0, this.fieldData.ra1, this.fieldData.ra2, this.fieldData.ra3]\n        const decs = [this.fieldData.dec0, this.fieldData.dec1, this.fieldData.dec2, this.fieldData.dec3]\n        const raSpan = Math.max(...ras) - Math.min(...ras)\n        const decSpan = Math.max(...decs) - Math.min(...decs)\n        const halfMin = Math.max(0.01, Math.min(raSpan, decSpan) / 2)\n        return halfMin * 0.9\n      },\n      raDecToCanvasDelta(raDeg, decDeg) {\n        // 将相对目标点的 (ΔRA, ΔDEC) 转换为画布像素偏移。\n        // 使用自适应像素/度比例，并在全屏模式下再乘以用户缩放因子。\n        const base = this.autoFitPxPerDeg || 40\n        const scalePxPerDeg = base\n        // 固定约定：RA 增大向右\n        const dx = (this.normalizeRaDelta(raDeg)) * scalePxPerDeg\n        const dy = (-decDeg) * scalePxPerDeg\n        return { dx, dy }\n      },\n      normalizeRaDelta(deltaDeg) {\n        // 将 RA 差值归一到 [-180, 180)\n        let x = deltaDeg\n        x = ((x + 540) % 360) - 180\n        return x\n      },\n      normalizeAzDelta(deltaDeg) {\n        // 将 Az 差值归一到 [-180, 180)\n        let x = deltaDeg\n        x = ((x + 540) % 360) - 180\n        return x\n      },\n\n      // === 轨迹点合并/追加（按 Alt/Az 容差） ===\n      appendRawTrajectoryPoint(raDeg, decDeg, timeMs = Date.now()) {\n        if (!Number.isFinite(raDeg) || !Number.isFinite(decDeg)) return\n        const loc = this.$store?.state?.currentLocation || {}\n        const lat = Number(loc.lat)\n        const lon = Number(loc.lng)\n        if (!Number.isFinite(lat) || !Number.isFinite(lon)) {\n          // 无法转换 Alt/Az，则直接追加\n          this.rawTrajectoryPoints.push({ ra: raDeg, dec: decDeg, t: timeMs })\n          return\n        }\n        const t = new Date(timeMs)\n        // 计算当前点与上一点在 Alt/Az 上的距离\n        const curAltAz = this.equatorialToHorizontal(raDeg, decDeg, t, lat, lon)\n        const tolDeg = (Number(this.trajectoryMergeTolArcmin) || 0) / 60\n        const last = this.rawTrajectoryPoints[this.rawTrajectoryPoints.length - 1]\n        if (!last) {\n          this.rawTrajectoryPoints.push({ ra: raDeg, dec: decDeg, t: timeMs })\n          return\n        }\n        const lastAltAz = this.equatorialToHorizontal(last.ra, last.dec, new Date(last.t || timeMs), lat, lon)\n        const dAz = this.normalizeAzDelta(curAltAz.az - lastAltAz.az)\n        const dAlt = curAltAz.alt - lastAltAz.alt\n        const sep = Math.hypot(dAz, dAlt)\n        if (sep <= tolDeg) {\n          // 合并：更新最后一点为当前值（保持时间最新）\n          last.ra = raDeg\n          last.dec = decDeg\n          last.t = timeMs\n        } else {\n          this.rawTrajectoryPoints.push({ ra: raDeg, dec: decDeg, t: timeMs })\n        }\n      },\n      unwrapRaDeltaSequence(dRaDegList) {\n        // 使相邻 dRA 序列在数值上连续，避免跨 0/360 发生长连线\n        if (!dRaDegList || dRaDegList.length === 0) return []\n        const out = [dRaDegList[0]]\n        for (let i = 1; i < dRaDegList.length; i++) {\n          let curr = dRaDegList[i]\n          let prev = out[i - 1]\n          let diff = curr - prev\n          while (diff > 180) { curr -= 360; diff = curr - prev }\n          while (diff < -180) { curr += 360; diff = curr - prev }\n          out.push(curr)\n        }\n        return out\n      },\n      appendTrajectoryPoint(rawRaDeg, rawDecDeg) {\n        // 已保留以兼容调用，但当前重绘使用 redrawTrajectory 覆盖全量绘制\n        if (!this.targetRawPosition) return\n        const canvas = this.$refs.trajectoryCanvas\n        if (!canvas) return\n        const cx = Math.round((this.overlayMode === 'windowed' ? this.baseCanvasLogicalSize.width : canvas.clientWidth) / 2)\n        const cy = Math.round((this.overlayMode === 'windowed' ? this.baseCanvasLogicalSize.height : canvas.clientHeight) / 2)\n        const dRa = rawRaDeg - this.targetRawPosition.ra\n        const dDec = rawDecDeg - this.targetRawPosition.dec\n        const { dx, dy } = this.raDecToCanvasDelta(dRa, dDec)\n        const point = { x: cx + dx, y: cy + dy }\n        this.trajectoryPoints.push(point)\n        this.drawPoint(point.x, point.y, '#FFD54F')\n      },\n      drawPoint(x, y, color) {\n        const canvas = this.$refs.trajectoryCanvas\n        if (!canvas) return\n        const ctx = canvas.getContext('2d')\n        ctx.save()\n        ctx.fillStyle = color || '#00BFFF'\n        ctx.beginPath()\n        ctx.arc(x, y, 3, 0, Math.PI * 2)\n        ctx.fill()\n        ctx.restore()\n      },\n      drawArrow(x1, y1, x2, y2, color) {\n        const canvas = this.$refs.trajectoryCanvas\n        if (!canvas) return\n        const ctx = canvas.getContext('2d')\n        ctx.save()\n        ctx.strokeStyle = color || '#FFD54F'\n        ctx.fillStyle = color || '#FFD54F'\n        ctx.lineWidth = 2\n        ctx.beginPath()\n        ctx.moveTo(x1, y1)\n        ctx.lineTo(x2, y2)\n        ctx.stroke()\n        // 箭头\n        const angle = Math.atan2(y2 - y1, x2 - x1)\n        const headLen = 8\n        ctx.beginPath()\n        ctx.moveTo(x2, y2)\n        ctx.lineTo(x2 - headLen * Math.cos(angle - Math.PI / 6), y2 - headLen * Math.sin(angle - Math.PI / 6))\n        ctx.lineTo(x2 - headLen * Math.cos(angle + Math.PI / 6), y2 - headLen * Math.sin(angle + Math.PI / 6))\n        ctx.lineTo(x2, y2)\n        ctx.fill()\n        ctx.restore()\n      },\n      // 画从目标到最后一段的垂线（虚线）；如垂足不在段内，仅将线段有限延长至垂点\n      drawPerpendicularAuxLine() {\n        if (!this.targetRawPosition || this.rawTrajectoryPoints.length < 2) return\n        // 使用“全量连续展开”的最后两点，允许 RA 超出常规范围，保证几何连续\n        const pair = this.getWorldABForPerp(); if (!pair) return\n        const { A, B } = pair\n        const O = { x: 0, y: 0 } // 目标在世界坐标为原点（与 worldForPoint/展开保持一致）\n        // 线段 AB 的向量与 O 到 AB 的投影参数 t\n        const vx = B.x - A.x\n        const vy = B.y - A.y\n        const len2 = vx * vx + vy * vy\n        if (len2 < 1e-9) return\n        const t = ((O.x - A.x) * vx + (O.y - A.y) * vy) / len2\n        let Hx, Hy, segment\n        if (t >= 0 && t <= 1) {\n          // 垂足在线段上\n          Hx = A.x + t * vx\n          Hy = A.y + t * vy\n          // 垂足在线段上时，不再绘制整段，只画 O→H 的垂线\n          segment = null\n        } else {\n          // 垂足在线段外：计算真正的垂足 H，并把线段朝 H 方向有限延长至 H\n          Hx = A.x + t * vx\n          Hy = A.y + t * vy\n          if (t < 0) {\n            segment = { x1: Hx, y1: Hy, x2: A.x, y2: A.y }\n          } else {\n            segment = { x1: B.x, y1: B.y, x2: Hx, y2: Hy }\n          }\n        }\n        // 画垂线（O->H）与（可能的延长）线段，均使用虚线\n        const canvas = this.$refs.trajectoryCanvas\n        if (!canvas) return\n        const ctx = canvas.getContext('2d')\n        const Opx = this.screenForWorld(O.x, O.y)\n        const Hpx = this.screenForWorld(Hx, Hy)\n        // const S1 = this.screenForWorld(segment.x1, segment.y1)\n        // const S2 = this.screenForWorld(segment.x2, segment.y2)\n        ctx.save()\n        ctx.setLineDash([6, 6])\n        ctx.lineWidth = 1.5\n        ctx.strokeStyle = '#9E9E9E'\n        // 垂线 O-H\n        ctx.beginPath()\n        ctx.moveTo(Opx.x, Opx.y)\n        ctx.lineTo(Hpx.x, Hpx.y)\n        ctx.stroke()\n        // 在辅助线（虚线）上用箭头标明方向：从 H 指向 O（指向目标）\n        // 选择线段内一点作为箭头位置，避免与目标环重叠\n        const tArrow = 0.6\n        const ax = Hpx.x + (Opx.x - Hpx.x) * tArrow\n        const ay = Hpx.y + (Opx.y - Hpx.y) * tArrow\n        const ang = Math.atan2(Opx.y - Hpx.y, Opx.x - Hpx.x)\n        const head = 8\n        ctx.setLineDash([])\n        ctx.fillStyle = '#9E9E9E'\n        ctx.beginPath()\n        ctx.moveTo(ax, ay)\n        ctx.lineTo(ax - head * Math.cos(ang - Math.PI / 6), ay - head * Math.sin(ang - Math.PI / 6))\n        ctx.lineTo(ax - head * Math.cos(ang + Math.PI / 6), ay - head * Math.sin(ang + Math.PI / 6))\n        ctx.closePath()\n        ctx.fill()\n        // 恢复虚线样式，用于绘制延长段\n        ctx.setLineDash([6, 6])\n        // 仅当垂足不在段上时绘制“延长到垂点”的那段\n        if (segment) {\n          const S1 = this.screenForWorld(segment.x1, segment.y1)\n          const S2 = this.screenForWorld(segment.x2, segment.y2)\n          ctx.beginPath()\n          ctx.moveTo(S1.x, S1.y)\n          ctx.lineTo(S2.x, S2.y)\n          ctx.stroke()\n          // 在延长段上也标注一个朝向“垂足 H”的小箭头\n          const exStart = (t < 0) ? { x: A.x, y: A.y } : { x: B.x, y: B.y }\n          const exEnd = { x: Hx, y: Hy }\n          const ES = this.screenForWorld(exStart.x, exStart.y)\n          const EE = this.screenForWorld(exEnd.x, exEnd.y)\n          const exdx = EE.x - ES.x\n          const exdy = EE.y - ES.y\n          const exLen2 = exdx * exdx + exdy * exdy\n          if (exLen2 > 1) {\n            const tEx = 0.5\n            const eax = ES.x + exdx * tEx\n            const eay = ES.y + exdy * tEx\n            const eang = Math.atan2(exdy, exdx)\n            ctx.setLineDash([])\n            ctx.beginPath()\n            ctx.moveTo(eax, eay)\n            ctx.lineTo(eax - head * Math.cos(eang - Math.PI / 6), eay - head * Math.sin(eang - Math.PI / 6))\n            ctx.lineTo(eax - head * Math.cos(eang + Math.PI / 6), eay - head * Math.sin(eang + Math.PI / 6))\n            ctx.closePath()\n            ctx.fill()\n          }\n        }\n        ctx.restore()\n      },\n      computeAutoFitScale() {\n        const canvas = this.$refs.trajectoryCanvas\n        if (!canvas || !this.targetRawPosition) return 40\n        const cx = this.targetRawPosition.ra\n        const cy = this.targetRawPosition.dec\n        let maxDx = 0, maxDy = 0\n        // 历史点\n        for (let i = 0; i < this.rawTrajectoryPoints.length; i++) {\n          const p = this.rawTrajectoryPoints[i]\n          maxDx = Math.max(maxDx, Math.abs(this.normalizeRaDelta(p.ra - cx)))\n          maxDy = Math.max(maxDy, Math.abs(p.dec - cy))\n        }\n        // 目标环半径（确保环不会顶边）\n        const ringDeg = this.getTargetRingDeg()\n        maxDx = Math.max(maxDx, ringDeg)\n        maxDy = Math.max(maxDy, ringDeg)\n        // 全屏时纳入视场角点以适配视场框；窗口模式不纳入\n        if (this.overlayMode === 'fullscreen') {\n          if (this.fieldData && Number.isFinite(this.fieldData.ra0)) {\n            const corners = [\n              { ra: this.fieldData.ra0, dec: this.fieldData.dec0 },\n              { ra: this.fieldData.ra1, dec: this.fieldData.dec1 },\n              { ra: this.fieldData.ra2, dec: this.fieldData.dec2 },\n              { ra: this.fieldData.ra3, dec: this.fieldData.dec3 },\n            ]\n            for (const c of corners) {\n              maxDx = Math.max(maxDx, Math.abs(this.normalizeRaDelta(c.ra - cx)))\n              maxDy = Math.max(maxDy, Math.abs(c.dec - cy))\n            }\n          }\n        }\n        if (maxDx === 0 && maxDy === 0) return 40\n        const w = this.overlayMode === 'windowed' ? this.baseCanvasLogicalSize.width : canvas.clientWidth\n        const h = this.overlayMode === 'windowed' ? this.baseCanvasLogicalSize.height : canvas.clientHeight\n        // 固定像素内边距，考虑箭头长度（8px）与点半径（4px）\n        const arrowHead = 8, pointR = 4\n        const pixelPadding = 32 + arrowHead + pointR\n        const halfW = Math.max(60, (w / 2) - pixelPadding)\n        const halfH = Math.max(50, (h / 2) - pixelPadding)\n        // 让最远点落在中心到边界距离的 80% 处（留足可视余量）\n        const margin = 0.8\n        let scale = Math.max(5, Math.min((halfW * margin) / (maxDx || 1e-6), (halfH * margin) / (maxDy || 1e-6)))\n        // 二次校验：按该比例转换一次，确保确实未越界，如越界再缩小比例\n        const pad = pixelPadding\n        const cxPx = w / 2, cyPx = h / 2\n        let maxAbsPxX = 0, maxAbsPxY = 0\n        const collect = []\n        for (let i = 0; i < this.rawTrajectoryPoints.length; i++) collect.push(this.rawTrajectoryPoints[i])\n        if (this.overlayMode === 'fullscreen' && this.fieldData && Number.isFinite(this.fieldData.ra0)) {\n          collect.push({ ra: this.fieldData.ra0, dec: this.fieldData.dec0 })\n          collect.push({ ra: this.fieldData.ra1, dec: this.fieldData.dec1 })\n          collect.push({ ra: this.fieldData.ra2, dec: this.fieldData.dec2 })\n          collect.push({ ra: this.fieldData.ra3, dec: this.fieldData.dec3 })\n        }\n        for (const p of collect) {\n          const dxDeg = this.normalizeRaDelta(p.ra - cx)\n          const dyDeg = (p.dec - cy)\n          maxAbsPxX = Math.max(maxAbsPxX, Math.abs(dxDeg * scale))\n          maxAbsPxY = Math.max(maxAbsPxY, Math.abs(dyDeg * scale))\n        }\n        const allowedX = halfW - pad\n        const allowedY = halfH - pad\n        const adj = Math.min(1, allowedX / (maxAbsPxX || 1e-6), allowedY / (maxAbsPxY || 1e-6))\n        scale *= adj\n        return scale\n      },\n      redrawTrajectory() {\n        if (!this.showTrajectoryOverlay || !this.targetRawPosition) return\n        this.initTrajectoryCanvas()\n        const canvas = this.$refs.trajectoryCanvas\n        if (!canvas) return\n        const ctx = canvas.getContext('2d')\n        // 预先将所有点转换到世界坐标，并初始化映射\n        const rawAll = this.rawTrajectoryPoints\n        // 使用全量点序列初始化/扩展视图映射，确保跨 0/360 时展开方向一致\n        const ensureRaw = rawAll\n        const worldSeq = this.makeWorldSeq(ensureRaw)\n        // 当存在视场数据时，也将视场四角纳入初始映射，防止目标附近尺度过小导致视场绘制异常\n        let fovWorld = []\n        if (this.fieldData) {\n          const timeRef = rawAll.length ? new Date(rawAll[rawAll.length - 1].t || Date.now()) : new Date()\n          const corners = [\n            { ra: this.fieldData.ra0, dec: this.fieldData.dec0 },\n            { ra: this.fieldData.ra1, dec: this.fieldData.dec1 },\n            { ra: this.fieldData.ra2, dec: this.fieldData.dec2 },\n            { ra: this.fieldData.ra3, dec: this.fieldData.dec3 },\n          ]\n          fovWorld = corners.map(c => this.worldForPoint(c.ra, c.dec, timeRef))\n        }\n        this.ensureViewMappingInitialized(worldSeq.concat(fovWorld))\n        // 选择绘制的数据集：全屏=全部；窗口=最新三个，但保持展开锚点稳定\n        const raw = this.overlayMode === 'windowed' ? rawAll.slice(-3) : rawAll\n        const world = this.makeWorldSeq(raw)\n        // 先走一遍更新比例/边界，不绘制，确保下游图元坐标系一致\n        for (let i = 0; i < world.length; i++) this.maybeExpandViewForPoint(world[i].x, world[i].y)\n        for (let i = 0; i < fovWorld.length; i++) this.maybeExpandViewForPoint(fovWorld[i].x, fovWorld[i].y)\n        // 再绘背景/目标环\n        this.drawTargetMarker()\n        // 绘制轨迹\n        this.trajectoryPoints = []\n        let prevPt = null\n        for (let i = 0; i < world.length; i++) {\n          const spt = this.screenForWorld(world[i].x, world[i].y)\n          const px = spt.x\n          const py = spt.y\n          const isLast = i === raw.length - 1\n          if (!isLast) {\n            this.drawPoint(px, py, '#FFD54F')\n            if (prevPt) this.drawArrow(prevPt.x, prevPt.y, px, py, '#FFD54F')\n          } else {\n            // 当前位置以空心圆表示（半径约 1 角分）\n            const arcmin = (this.calibrationCircleArcmin || 1)\n            const rPx = Math.max(4, (arcmin / 60) * ((this.currentPxPerDeg || 40)))\n            this.drawHollowCircle(px, py, rPx, '#00BFFF', 2)\n            // 圈住目标（目标在世界原点），当圆心到原点的距离小于半径时视为完成\n            const rDeg = Math.hypot(world[i].x, world[i].y)\n            if (rDeg <= (arcmin / 60)) {\n              if (!this.isPolarAligned) {\n                this.isPolarAligned = true\n                this.addLog(this.$t('Polar Alignment Completed'), 'success')\n              }\n            }\n            if (prevPt) this.drawArrow(prevPt.x, prevPt.y, px, py, '#FFD54F')\n          }\n          prevPt = { x: px, y: py }\n          this.trajectoryPoints.push({ x: px, y: py })\n        }\n        // 辅助：目标到最后段的垂线（虚线）\n        this.drawPerpendicularAuxLine()\n      },\n      drawHollowCircle(x, y, r = 8, color = '#FFFFFF', lineWidth = 2) {\n        const canvas = this.$refs.trajectoryCanvas\n        if (!canvas) return\n        const ctx = canvas.getContext('2d')\n        ctx.save()\n        ctx.strokeStyle = color\n        ctx.lineWidth = lineWidth\n        ctx.beginPath()\n        ctx.arc(x, y, r, 0, Math.PI * 2)\n        ctx.stroke()\n        ctx.restore()\n      },\n      // FoV 绘制已不再需要\n\n      resetCalibration() {\n        // 使用统一的内存清理方法\n        this.clearCachedData()\n\n        this.addLog(this.$t('Calibration Data Reset'), 'info')\n        // this.$bus.$emit('AppSendMessage', 'Vue_Command', 'ResetAutoPolarAlignment')\n        this.$bus.$emit('ClearCalibrationPoints')\n        this.$bus.$emit('ClearStatusTextFromStarMap')\n        // 清空轨迹\n        this.rawTrajectoryPoints = []\n        this.trajectoryPoints = []\n        this.lastRawPosition = null\n        this.targetRawPosition = null\n      },\n\n      restoreCalibration() {\n        this.addLog(this.$t('Calibration Data Restored'), 'success')\n        this.$bus.$emit('AppSendMessage', 'Vue_Command', 'RestoreAutoPolarAlignment')\n      },\n\n      // ========================================\n      // 校准控制方法\n      // ========================================\n      startAutoCalibration() {\n        if (!this.isConnected) {\n          this.addLog(this.$t('Error: Mount Not Connected'), 'error')\n          return\n        }\n        if (this.isCalibrationRunning) {\n          this.stopAutoCalibration()\n          return\n        }\n        this.isCalibrationRunning = true\n        this.resetCalibration()\n        this.addLog(this.$t('Starting Auto Calibration'), 'info')\n        this.$bus.$emit('AppSendMessage', 'Vue_Command', 'StartAutoPolarAlignment')\n      },\n\n      stopAutoCalibration() {\n        this.isCalibrationRunning = false\n        this.addLog(this.$t('Auto Calibration Stopped'), 'warning')\n        this.$bus.$emit('AppSendMessage', 'Vue_Command', 'StopAutoPolarAlignment')\n      },\n      // ========================================\n      // 视场数据处理方法\n      // ========================================\n      updateFieldData(data) {\n        if (data && Array.isArray(data) && data.length >= 12) { // 修改长度检查，确保包含假极轴数据\n          const isValidData = data.every(val => typeof val === 'number' && !isNaN(val))\n          if (!isValidData) {\n            this.addLog(this.$t('Warning: Invalid Field Data Received'), 'warning')\n            return\n          }\n\n          this.fieldData = {\n            ra: data[0],\n            dec: data[1],\n            ra0: data[2],\n            dec0: data[3],\n            ra1: data[4],\n            dec1: data[5],\n            ra2: data[6],\n            dec2: data[7],\n            ra3: data[8],\n            dec3: data[9],\n            targetra: data[10],\n            targetdec: data[11],\n            fakePolarRA: data[12],\n            fakePolarDEC: data[13],\n            realPolarRA: data[14],\n            realPolarDEC: data[15]\n          }\n\n          // 保存上一次位置（在更新当前位置之前）\n          if (this.currentPosition.ra !== '00h 00m 00s') {\n            this.previousPosition = { ...this.currentPosition }\n          }\n\n          // 更新当前位置\n          this.currentPosition = {\n            ra: this.formatCoordinate(data[0], 'ra'),\n            dec: this.formatCoordinate(data[1], 'dec')\n          }\n\n          // === 轨迹逻辑挂接 ===\n          // 使用原始角度（假设 data[0], data[1], data[10], data[11] 为度单位）\n          const rawRa = data[0]\n          const rawDec = data[1]\n          // 在进入调整阶段（目标提供）时固定目标点；否则不绘制\n          if (data[10] !== -1 && data[11] !== -1) {\n            if (!this.targetRawPosition || (this.targetRawPosition.ra !== data[10] || this.targetRawPosition.dec !== data[11])) {\n              this.targetRawPosition = { ra: data[10], dec: data[11] }\n              // 重绘以目标点为中心\n              if (this.showTrajectoryOverlay) this.redrawTrajectory()\n            }\n            const posChanged = !this.lastRawPosition || this.lastRawPosition.ra !== rawRa || this.lastRawPosition.dec !== rawDec\n            if (posChanged) {\n              this.appendRawTrajectoryPoint(rawRa, rawDec, Date.now())\n              // 改为全量重绘（确保自适应比例包含所有点、并绘制视场框）\n              if (this.showTrajectoryOverlay) this.redrawTrajectory()\n              this.lastRawPosition = { ra: rawRa, dec: rawDec }\n            }\n          }\n\n          if (data[10] === -1 && data[11] === -1) {\n            // 校准点收集阶段\n            this.calibrationPhase = 'collecting'\n            const pointNumber = this.calibrationPoints.length + 1\n\n            // 添加调试信息\n            this.addLog(`准备收集校准点${pointNumber}，当前已有${this.calibrationPoints.length}个点`, 'info')\n\n            try {\n              this.drawCalibrationPointPolygon(data[0], data[1], pointNumber, this.fieldData)\n              this.addLog(this.$t('Calibration Point', [pointNumber, data[0].toFixed(4), data[1].toFixed(4)]), 'info')\n\n              // 保存校准点 - 限制最大数量\n              if (this.calibrationPoints.length < this.maxCalibrationPoints) {\n                this.calibrationPoints.push({\n                  ra: data[0],\n                  dec: data[1],\n                  index: pointNumber\n                })\n              } else {\n                // 如果超过最大数量，替换最旧的点\n                const oldestIndex = (pointNumber - 1) % this.maxCalibrationPoints\n                this.calibrationPoints[oldestIndex] = {\n                  ra: data[0],\n                  dec: data[1],\n                  index: pointNumber\n                }\n              }\n\n              this.addLog(`校准点${pointNumber}已添加，现在总共有${this.calibrationPoints.length}个点`, 'info')\n\n              // 如果收集了3个点，进入调整阶段\n              if (this.calibrationPoints.length === this.maxCalibrationPoints) {\n                this.calibrationPhase = 'adjusting'\n                this.addLog(this.$t('Three calibration points collected, entering adjustment phase'), 'success')\n              }\n            } catch (error) {\n              this.addLog(this.$t('Error processing calibration point', [error.message]), 'error')\n              console.error('处理校准点错误：', error)\n            }\n          } else if (data[10] !== -1 && data[11] !== -1) {\n            // 调整阶段：显示目标位置和假极轴\n            this.calibrationPhase = 'adjusting'\n            this.targetPoint = { ra: data[10], dec: data[11] }\n\n            try {\n              // 先清除所有之前的元素\n              this.addLog('调整模式：准备清除之前的校准元素', 'info')\n              this.$bus.$emit('ClearCalibrationPoints')\n              this.addLog('调整模式：清除命令已发送', 'info')\n\n              // 绘制校准点（如果已收集3个点）\n              if (this.calibrationPoints.length === this.maxCalibrationPoints) {\n                this.calibrationPoints.forEach((point, index) => {\n                  const pointCoordinates = this.calculateFieldCorners(point.ra, point.dec, this.fieldData, false)\n                  const pointColor = {\n                    stroke: \"#FFD700\",        // 金色边框：校准点\n                    strokeOpacity: 1,         // 边框不透明度\n                    fill: \"#FFD700\",          // 金色填充：校准点\n                    fillOpacity: 0.3          // 填充不透明度（半透明）\n                  }\n\n                  this.$bus.$emit('DrawCalibrationPointPolygon', pointCoordinates, pointColor,\n                    `Calibration_Point_${index + 1}`, `校准点${index + 1}`, \"#FFD700\")\n                })\n              }\n\n              // 绘制当前位置（蓝色）\n              const currentCoordinates = this.calculateFieldCorners(data[0], data[1], this.fieldData, false)\n              const currentColor = {\n                stroke: \"#00BFFF\",        // 蓝色边框：当前位置\n                strokeOpacity: 1,         // 边框不透明度\n                fill: \"#00BFFF\",          // 蓝色填充：当前位置\n                fillOpacity: 0.3          // 填充不透明度（半透明）\n              }\n\n              this.$bus.$emit('DrawCalibrationPointPolygon', currentCoordinates, currentColor,\n                'Current_Position', '当前位置', \"#00BFFF\")\n\n              // 绘制目标点（绿色圆形）\n              const targetColor = {\n                stroke: \"#4CAF50\",        // 绿色边框：目标点\n                strokeOpacity: 1,         // 边框不透明度\n                fill: \"#4CAF50\",          // 绿色填充：目标点\n                fillOpacity: 0.3          // 填充不透明度（半透明）\n              }\n\n              const { az, alt } = this.equatorialToHorizontal(data[10], data[11], new Date(Date.now()), this.$store.state.currentLocation.lat, this.$store.state.currentLocation.lng)\n              // console.log('当前位置目标点', data[6], data[7] + ' 转化为地平坐标为' + az + ' ' + alt);\n              // console.log('使用时间和地点', new Date(Date.now()), $store.state.currentLocation.lat, $store.state.currentLocation.lng);\n\n              this.$bus.$emit('DrawTargetPointCircle',\n                az,\n                alt,\n                targetColor,\n                'Target_Point',\n                '目标点'\n              )\n\n              // 绘制假极轴（紫色圆形）\n              if (data[12] !== -1 && data[13] !== -1 && !isNaN(data[12]) && !isNaN(data[13])) {\n                const { az, alt } = this.equatorialToHorizontal(data[12], data[13], new Date(Date.now()), this.$store.state.currentLocation.lat, this.$store.state.currentLocation.lng)\n                this.drawFakePolarAxis(az, alt)\n              }\n\n              this.addLog(`调整模式：当前位置(${data[0].toFixed(4)}, ${data[1].toFixed(4)}) 目标位置(${data[6].toFixed(4)}, ${data[7].toFixed(4)}) 假极轴(${data[8].toFixed(4)}, ${data[9].toFixed(4)})`, 'info')\n            } catch (error) {\n              this.addLog(this.$t('Error processing adjustment data', [error.message]), 'error')\n              console.error('处理调整数据错误：', error)\n            }\n          }\n        } else {\n          this.addLog(this.$t('Error: Invalid Field Data Format'), 'error')\n        }\n      },\n\n      // 绘制校准点\n      drawCalibrationPointPolygon(ra, dec, pointNumber, fieldData) {\n        this.addLog(this.$t('Drawing Calibration Point', [pointNumber, ra, dec]), 'info')\n\n        try {\n          const coordinates = this.calculateFieldCorners(ra, dec, fieldData)\n          this.addLog(this.$t('Calculated Field Corner Coordinates', [JSON.stringify(coordinates)]), 'info')\n\n          // 验证坐标有效性\n          const validCoordinates = coordinates.every((coord, index) => {\n            const isValid = coord && typeof coord.ra === 'number' && typeof coord.dec === 'number' &&\n              !isNaN(coord.ra) && !isNaN(coord.dec) && isFinite(coord.ra) && isFinite(coord.dec)\n            if (!isValid) {\n              this.addLog(this.$t('Warning: Invalid Coordinate Point', [index, JSON.stringify(coord)]), 'warning')\n            }\n            return isValid\n          })\n\n          if (!validCoordinates) {\n            this.addLog(this.$t('Invalid Field Coordinates'), 'error')\n            return\n          }\n\n          const color = this.getCalibrationPointColor()\n\n          // 添加文本标签\n          const label = `校准点${pointNumber}`\n          const labelColor = \"#FFFFFF\"\n\n          this.addLog(this.$t('Sending Draw Calibration Event', [pointNumber]), 'info')\n          this.$bus.$emit('DrawCalibrationPointPolygon', coordinates, color, `Calibration_${pointNumber}`, label, labelColor)\n\n        } catch (error) {\n          this.addLog(this.$t('Error Drawing Calibration Point', [error.message]), 'error')\n          console.error('绘制校准点错误：', error)\n        }\n      },\n\n      // 清除所有校准点\n      clearCalibrationPoints() {\n        this.addLog(this.$t('Clearing All Calibration Points'), 'info')\n        this.$bus.$emit('ClearCalibrationPoints')\n        this.$bus.$emit('ClearStatusTextFromStarMap')\n      },\n\n      /**\n       * 绘制极轴校准调整点\n       * 在星图上绘制当前位置、目标位置、校准点等关键位置标记\n       * @param {number} currentRa - 当前赤经位置\n       * @param {number} currentDec - 当前赤纬位置  \n       * @param {number} targetRa - 目标赤经位置\n       * @param {number} targetDec - 目标赤纬位置\n       * @param {object} fieldData - 视场数据（包含视场边界信息）\n       * @param {boolean} isTimerUpdate - 是否为定时器更新（用于区分手动更新和自动更新）\n       */\n      drawAdjustmentPoints(currentRa, currentDec, targetRa, targetDec, fieldData, isTimerUpdate = false) {\n        // 这个方法现在主要用于校准点收集阶段\n        // 调整阶段的绘制逻辑已经移到updateFieldData方法中\n\n        this.addLog(this.$t('Starting Draw Adjustment Points', [currentRa, currentDec, targetRa, targetDec]), 'info')\n\n        try {\n          // 只在校准点收集阶段使用这个方法\n          if (this.calibrationPhase === 'collecting') {\n            // 绘制校准点收集阶段的逻辑\n            const currentCoordinates = this.calculateFieldCorners(currentRa, currentDec, fieldData, false)\n            const currentColor = {\n              stroke: \"#00BFFF\",        // 蓝色边框：当前位置\n              strokeOpacity: 1,         // 边框不透明度\n              fill: \"#00BFFF\",          // 蓝色填充：当前位置\n              fillOpacity: 0.3          // 填充不透明度（半透明）\n            }\n\n            this.$bus.$emit('DrawCalibrationPointPolygon', currentCoordinates, currentColor,\n              'Current_Position', '当前位置', \"#00BFFF\")\n          }\n\n        } catch (error) {\n          this.addLog(this.$t('Error Drawing Adjustment Points', [error.message]), 'error')\n          console.error('绘制调整点错误：', error)\n        }\n      },\n\n      /**\n       * 计算视场的五个角点坐标\n       * @param {number} centerRa - 视场中心的赤经坐标\n       * @param {number} centerDec - 视场中心的赤纬坐标\n       * @param {object} fieldData - 视场数据（包含视场边界信息）\n       * @param {boolean} useDefaultSize - 是否使用默认视场大小（用于目标点等固定位置）\n       * @returns {Array} 包含5个角点坐标的数组，用于绘制多边形\n       */\n      calculateFieldCorners(centerRa, centerDec, fieldData, useDefaultSize = false) {\n        this.addLog(this.$t('Calculating Field Corners', [centerRa, centerDec]), 'info')\n\n        // 如果指定使用默认大小或者没有视场数据，使用默认的0.5度视场大小\n        if (useDefaultSize || !fieldData) {\n          this.addLog(this.$t('Using Default Field Size: 0.5 Degrees'), 'info')\n          const fieldSize = 0.5\n          const coordinates = [\n            { ra: centerRa + fieldSize / 2, dec: centerDec + fieldSize / 2 },\n            { ra: centerRa - fieldSize / 2, dec: centerDec + fieldSize / 2 },\n            { ra: centerRa - fieldSize / 2, dec: centerDec - fieldSize / 2 },\n            { ra: centerRa + fieldSize / 2, dec: centerDec - fieldSize / 2 },\n            { ra: centerRa + fieldSize / 2, dec: centerDec + fieldSize / 2 }\n          ]\n          this.addLog(this.$t('Default Field Corners', [JSON.stringify(coordinates)]), 'info')\n          return coordinates\n        }\n\n        // 如果有视场数据且不强制使用默认大小，基于传入的中心点坐标计算视场角点\n        // 这种情况主要用于当前位置的显示，需要反映实际的视场大小\n        const { ra0, dec0, ra1, dec1, ra2, dec2, ra3, dec3 } = fieldData\n\n        // 计算视场的实际大小（RA和DEC方向的跨度）\n   \n\n        // 基于传入的中心点坐标，计算视场的五个角点\n        const coordinates = [\n          { ra: ra0, dec: dec0 },     // 右上角\n          { ra: ra1, dec: dec1 },     // 左上角\n          { ra: ra2, dec: dec2 },     // 左下角\n          { ra: ra3, dec: dec3 },     // 右下角\n          { ra: ra0, dec: dec0 }      // 回到右上角（闭合多边形）\n        ]\n\n        this.addLog(this.$t('Using Field Data', [ra0, dec0, ra1, dec1, ra2, dec2, ra3, dec3]), 'info')\n        this.addLog(this.$t('Field Corner Calculation Result', [JSON.stringify(coordinates)]), 'info')\n        return coordinates\n      },\n\n\n\n      // ========================================\n      // 格式化方法\n      // ========================================\n      formatTime(timestamp) {\n        if (!timestamp) return ''\n        const date = new Date(timestamp)\n        return date.toLocaleTimeString('zh-CN', {\n          hour12: false,\n          hour: '2-digit',\n          minute: '2-digit',\n          second: '2-digit'\n        })\n      },\n\n      formatAdjustmentValue(value) {\n        if (!Number.isFinite(value)) return `0.0${this.unitGlyph(this.adjustmentUnit)}`\n        // value 的单位 = props.adjustmentUnit\n        const valArcmin = this.unitToArcmin(value, this.adjustmentUnit)\n        // 展示单位仍然用 props.adjustmentUnit（也可改成固定'arcmin'）\n        return this.formatWithUnit(valArcmin, this.adjustmentUnit, 1)\n      },\n\n      // 格式化坐标显示\n      formatCoordinate(value, type) {\n        if (value === null || value === undefined || isNaN(value)) {\n          return type === 'ra' ? '00h 00m 00s' : '+00° 00\\' 00\"'\n        }\n\n        if (type === 'ra') {\n          // 格式化RA为时分秒格式\n          const hours = Math.floor(value / 15)\n          const minutes = Math.floor((value % 15) * 4)\n          const seconds = Math.floor(((value % 15) * 4 - minutes) * 60)\n          return `${hours.toString().padStart(2, '0')}h ${minutes.toString().padStart(2, '0')}m ${seconds.toString().padStart(2, '0')}s`\n        } else {\n          // 格式化DEC为度分秒格式\n          const sign = value >= 0 ? '+' : '-'\n          const absValue = Math.abs(value)\n          const degrees = Math.floor(absValue)\n          const minutes = Math.floor((absValue - degrees) * 60)\n          const seconds = Math.floor(((absValue - degrees) * 60 - minutes) * 60)\n          return `${sign}${degrees.toString().padStart(2, '0')}° ${minutes.toString().padStart(2, '0')}' ${seconds.toString().padStart(2, '0')}\"`\n        }\n      },\n\n\n      // ========================================\n      // 辅助方法\n      // ========================================\n      parseCoordinate(value, type) {\n        if (typeof value === 'string') {\n          if (type === 'ra') {\n            // 解析时分秒格式 \"00h 00m 00s\"\n            const match = value.match(/(\\d+)h\\s*(\\d+)m\\s*(\\d+)s/)\n            if (match) {\n              const hours = parseInt(match[1])\n              const minutes = parseInt(match[2])\n              const seconds = parseInt(match[3])\n              return hours + minutes / 60 + seconds / 3600\n            }\n          } else {\n            // 解析度分秒格式 \"+00° 00' 00\"\"\n            const match = value.match(/([+-]?)(\\d+)°\\s*(\\d+)'\\s*(\\d+)\"/)\n            if (match) {\n              const sign = match[1] === '-' ? -1 : 1\n              const degrees = parseInt(match[2])\n              const minutes = parseInt(match[3])\n              const seconds = parseInt(match[4])\n              return sign * (degrees + minutes / 60 + seconds / 3600)\n            }\n          }\n        }\n        return null\n      },\n\n      addStatusTextToStarMap() {\n        // 添加状态文本到星图\n        const statusText = {\n          text: `极轴校准调整中 - 校准点: ${this.calibrationPoints.length}/3`,\n          position: { ra: this.currentPosition.ra, dec: this.currentPosition.dec },\n          color: \"#FFFFFF\",\n          fontSize: 14,\n          backgroundColor: \"rgba(0, 0, 0, 0.7)\"\n        }\n\n        // 发送状态文本到星图\n        // this.$bus.$emit('AddStatusTextToStarMap', statusText)\n      },\n\n      getStepClass(index) {\n        // 根据进度百分比确定节点状态\n        const progress = this.progressPercentage\n\n        switch (index) {\n          case 0: // 初始化节点\n            if (progress >= PROGRESS_THRESHOLDS.INITIALIZATION) return { completed: true }\n            if (progress >= 0) return { current: true }\n            return {}\n\n          case 1: // 第一次校准节点\n            if (progress >= PROGRESS_THRESHOLDS.FIRST_CALIBRATION) return { completed: true }\n            if (progress >= PROGRESS_THRESHOLDS.INITIALIZATION) return { current: true }\n            return {}\n\n          case 2: // 第二次校准节点\n            if (progress >= PROGRESS_THRESHOLDS.SECOND_CALIBRATION) return { completed: true }\n            if (progress >= PROGRESS_THRESHOLDS.FIRST_CALIBRATION) return { current: true }\n            return {}\n\n          case 3: // 第三次校准节点\n            if (progress >= PROGRESS_THRESHOLDS.THIRD_CALIBRATION) return { completed: true }\n            if (progress >= PROGRESS_THRESHOLDS.SECOND_CALIBRATION) return { current: true }\n            return {}\n\n          default:\n            return {}\n        }\n      },\n\n      getAzimuthAction(azVal) {\n        if (!Number.isFinite(azVal)) return ''\n        const arcmin = this.unitToArcmin(azVal, this.adjustmentUnit)\n        if (Math.abs(arcmin) <= this.deadbandArcmin) return this.$t('No adjustment needed')\n        const dir = this.azLabelBySign(arcmin)\n        // 输出单位与 props.adjustmentUnit 保持一致\n        return `${dir} ${this.formatWithUnit(arcmin, this.adjustmentUnit, 1)}`\n      },\n\n      getAltitudeAction(altVal) {\n        if (!Number.isFinite(altVal)) return ''\n        const arcmin = this.unitToArcmin(altVal, this.adjustmentUnit)\n        if (Math.abs(arcmin) <= this.deadbandArcmin) return this.$t('No adjustment needed')\n        const dir = this.altLabelBySign(arcmin)\n        return `${dir} ${this.formatWithUnit(arcmin, this.adjustmentUnit, 1)}`\n      },\n\n\n\n      // ========================================\n      // 日志方法\n      // ========================================\n      addLog(message, level = 'info') {\n        const log = {\n          id: Date.now() + Math.random(),\n          message,\n          level,\n          timestamp: new Date()\n        }\n        \n        // 生产环境减少console输出\n        if (process.env.NODE_ENV === 'development') {\n          console.log(log.message)\n        }\n        \n        // 使用循环数组优化内存使用\n        if (this.logs.length < this.logCapacity) {\n          this.logs.push(log)\n        } else {\n          // 循环覆盖旧日志\n          this.logs[this.logIndex] = log\n          this.logIndex = (this.logIndex + 1) % this.logCapacity\n        }\n      },\n\n      clearLogs() {\n        this.logs = []\n        this.logIndex = 0\n      },\n\n      // ========================================\n      // 极轴校准状态更新方法\n      // ========================================\n      calculatePolarAxisOffset() {\n        this.polarAxisOffset = {\n          azimuth: this.adjustment.azimuth,\n          altitude: this.adjustment.altitude\n        }\n      },\n\n      updatePolarAlignmentState(stateNumber, logMessage, progress) {\n        if (logMessage && typeof logMessage === 'string') {\n          let level = 'info'\n          if (logMessage.toLowerCase().includes('error') || logMessage.toLowerCase().includes('失败')) {\n            level = 'error'\n          } else if (logMessage.toLowerCase().includes('warning') || logMessage.toLowerCase().includes('警告')) {\n            level = 'warning'\n          } else if (logMessage.toLowerCase().includes('success') || logMessage.toLowerCase().includes('成功') || logMessage.toLowerCase().includes('完成')) {\n            level = 'success'\n          }\n          this.addLog(logMessage, level)\n        }\n\n        if (progress !== undefined && progress !== null) {\n          this.currentProgress = progress\n\n          if (progress >= 0 && progress <= 100) {\n            // 根据进度更新校准状态\n            if (progress >= 0 && progress < 15) {\n              // 初始化阶段\n              this.calibrationPoints = []\n              this.isCalibrationComplete = false\n              this.isPolarAligned = false\n            } else if (progress >= 15 && progress < 25) {\n              // 第一次校准阶段 - 移除模拟数据添加，实际校准点由updateFieldData处理\n              // 这里只更新状态，不添加模拟校准点\n            } else if (progress >= 25 && progress < 50) {\n              // 第二次校准阶段 - 移除模拟数据添加，实际校准点由updateFieldData处理\n              // 这里只更新状态，不添加模拟校准点\n            } else if (progress >= 50 && progress < 75) {\n              // 第三次校准阶段 - 移除模拟数据添加，实际校准点由updateFieldData处理\n              // 这里只更新状态，不添加模拟校准点\n            } else if (progress >= 75 && progress < 95) {\n              // 循环校准调整阶段\n              this.isCalibrationComplete = true\n              this.calculatePolarAxisOffset()\n\n              // 检测校准循环\n              if (progress < this.lastCalibrationProgress && this.lastCalibrationProgress >= 75) {\n                this.calibrationLoopCount++\n                this.addLog(this.$t('Calibration Round Started', [this.calibrationLoopCount]), 'info')\n              }\n\n              // 在循环校准阶段，进度可能会在75-95之间波动\n              // 这表示系统正在进行多次校准调整\n              if (progress > 85) {\n                this.addLog(this.$t('Calibration Progress Info', [Math.round(progress), this.calibrationLoopCount]), 'info')\n              }\n\n              this.lastCalibrationProgress = progress\n            } else if (progress >= 95 && progress <= 100) {\n              // 最终验证阶段\n              this.isCalibrationComplete = true\n              this.calculatePolarAxisOffset()\n\n              if (Math.abs(this.polarAxisOffset.azimuth) < 1.0 && Math.abs(this.polarAxisOffset.altitude) < 1.0) {\n                this.isPolarAligned = true\n                this.addLog(this.$t('Polar Alignment Completed'), 'success')\n              } else {\n                this.addLog(this.$t('Polar Alignment Needs Manual Adjustment'), 'warning')\n              }\n            }\n          }\n        }\n      },\n\n      updatePolarAlignmentIsRunning(isRunning) {\n        this.isCalibrationRunning = isRunning\n        this.hasAcceptUpdateMessage = true\n      },\n\n      // ========================================\n      // 坐标转换方法\n      // ========================================\n      /**\n       * 赤道坐标 (RA, Dec) → 地平坐标 (Az, Alt)\n       * @param {number} raDeg 赤经 (度, 0~360)\n       * @param {number} decDeg 赤纬 (度, -90~+90)\n       * @param {Date} dateUTC 观测时间 (UTC 时间)\n       * @param {number} latDeg 观测点纬度 (度, 北正南负)\n       * @param {number} lonDeg 观测点经度 (度, 东正西负)\n       * @returns {{az: number, alt: number}} 方位角/高度角 (度)\n       */\n      equatorialToHorizontal(raDeg, decDeg, dateUTC, latDeg, lonDeg) {\n        // 工具\n        const toJD = d => (Number(d) / 86400000) + 2440587.5; // Date/ms → JD\n        const d2r = x => x * Math.PI / 180, r2d = x => x * 180 / Math.PI;\n        const norm360 = a => ((a % 360) + 360) % 360;\n        const clamp = (x, lo = -1, hi = 1) => Math.min(hi, Math.max(lo, x));\n\n        // 入参归一化 + 硬校验\n        raDeg = Number(raDeg);\n        decDeg = Number(decDeg);\n        latDeg = Number(latDeg);\n        lonDeg = Number(lonDeg);\n        const tms = Number(dateUTC); // Date 或时间戳都可\n\n        if (process.env.NODE_ENV === 'development') {\n          console.log('EQ→HOR 入参:', { raDeg, decDeg, latDeg, lonDeg, dateUTC, tms });\n        }\n\n        if (![raDeg, decDeg, latDeg, lonDeg, tms].every(Number.isFinite)) {\n          console.error('EQ→HOR 入参非法:', { raDeg, decDeg, latDeg, lonDeg, dateUTC, tms });\n          return { az: NaN, alt: NaN };\n        }\n\n        try {\n          // 1) JD & GMST\n          const JD = toJD(tms);\n          const d = JD - 2451545.0;\n          let GMST = norm360(280.46061837 + 360.98564736629 * d); // 度\n\n          // 2) LST（东经为正）\n          let LST = norm360(GMST + lonDeg);\n\n          // 3) HA（-180~180 更稳）\n          let HA = LST - raDeg;\n          HA = ((HA + 180) % 360) - 180;\n\n          // 4) Alt / Az（稳定形式）\n          const ha = d2r(HA);\n          const dec = d2r(decDeg);\n          const lat = d2r(latDeg);\n\n          const sinAlt = clamp(\n            Math.sin(dec) * Math.sin(lat) + Math.cos(dec) * Math.cos(lat) * Math.cos(ha)\n          );\n          const alt = Math.asin(sinAlt);\n          const y = -Math.sin(ha) * Math.cos(dec);\n          const x = Math.sin(dec) * Math.cos(lat) - Math.cos(dec) * Math.sin(lat) * Math.cos(ha);\n          const az = Math.atan2(y, x);\n\n          const altDeg = r2d(alt);\n          const azDeg = norm360(r2d(az));\n\n          if (process.env.NODE_ENV === 'development') {\n            console.log('EQ→HOR 结果:', {\n              JD, GMST, LST, HA,\n              haRad: ha, decRad: dec, latRad: lat,\n              az: azDeg, alt: altDeg\n            });\n          }\n\n          return { az: azDeg, alt: altDeg };\n        } catch (e) {\n          console.error('EQ→HOR 计算异常:', e, {\n            raDeg, decDeg, latDeg, lonDeg, dateUTC, tms\n          });\n          return { az: NaN, alt: NaN };\n        }\n      },\n\n\n\n\n\n      // === 增强的卡片信息更新方法 ===\n      updateCardInfo(currentRa, currentDec, targetRa, targetDec, azimuthVal, altitudeVal, raAdjustment, decAdjustment, unitHint) {\n        const parseValue = v => (v === null || v === '' || v === undefined) ? 0 : (Number(v) || 0)\n\n        const currentRaNum = parseValue(currentRa)\n        const currentDecNum = parseValue(currentDec)\n        const targetRaNum = parseValue(targetRa)\n        const targetDecNum = parseValue(targetDec)\n        const azVal = parseValue(azimuthVal)\n        const altVal = parseValue(altitudeVal)\n\n        // 1) 位置显示（原样）\n        this.currentPosition.ra = this.formatCoordinate(currentRaNum, 'ra')\n        this.currentPosition.dec = this.formatCoordinate(currentDecNum, 'dec')\n        this.targetPosition.ra = this.formatCoordinate(targetRaNum, 'ra')\n        this.targetPosition.dec = this.formatCoordinate(targetDecNum, 'dec')\n\n        // 2) 调整量：以传入单位为准写入（默认用 props.adjustmentUnit）\n        const inUnit = unitHint || this.adjustmentUnit\n        // 如果传入是\"度\"，但你 props 设为了\"arcmin\"，也没关系——显示会自动换算\n        // 这里保存\"原始数 + 它的单位（通过 props）\"\n        this.adjustment.azimuth = azVal\n        this.adjustment.altitude = altVal\n        this.adjustmentUnit = inUnit  // 如果希望每次随数据切换单位，可加入这一行\n\n        // 3) 在调整阶段，每次接收到调整数据时增加校准轮数\n        if (this.calibrationPhase === 'adjusting') {\n          this.calibrationLoopCount++\n          this.addLog(this.$t('Calibration Round Started', [this.calibrationLoopCount]), 'info')\n        }\n\n        // 4) 极轴完成判定（用角分比较）\n        const azArcmin = this.unitToArcmin(azVal, inUnit)\n        const altArcmin = this.unitToArcmin(altVal, inUnit)\n        this.isPolarAligned = Math.abs(azArcmin) < 1.0 && Math.abs(altArcmin) < 1.0\n\n        if (process.env.NODE_ENV === 'development') {\n          console.log('PolarAlignment update:', {\n            unit: inUnit,\n            adj_raw: { azimuth: azVal, altitude: altVal },\n            adj_arcmin: { az: azArcmin, alt: altArcmin },\n            isPolarAligned: this.isPolarAligned,\n            calibrationRound: this.calibrationLoopCount\n          })\n        }\n      },\n\n\n      /**\n       * 根据三个校准点计算假极轴位置\n       * 使用三点极轴校准算法\n       */\n      calculateFakePolarAxis() {\n        if (this.calibrationPoints.length !== this.maxCalibrationPoints) {\n          this.addLog('需要3个校准点才能计算假极轴位置', 'warning')\n          return false\n        }\n\n        try {\n          const [p1, p2, p3] = this.calibrationPoints\n\n          // 将三个点转换为笛卡尔坐标\n          const cart1 = this.equatorialToCartesian(p1.ra, p1.dec)\n          const cart2 = this.equatorialToCartesian(p2.ra, p2.dec)\n          const cart3 = this.equatorialToCartesian(p3.ra, p3.dec)\n\n          // 计算两个向量\n          const v1 = {\n            x: cart2.x - cart1.x,\n            y: cart2.y - cart1.y,\n            z: cart2.z - cart1.z\n          }\n          const v2 = {\n            x: cart3.x - cart1.x,\n            y: cart3.y - cart1.y,\n            z: cart3.z - cart1.z\n          }\n\n          // 计算法向量（叉积）\n          const normal = this.crossProduct(v1, v2)\n\n          // 检查法向量是否为零向量\n          const normalLength = this.vectorLength(normal)\n          if (normalLength < 1e-10) {\n            this.addLog('三个校准点共线，无法计算假极轴位置', 'error')\n            return false\n          }\n\n          // 归一化法向量\n          const unitNormal = this.normalizeVector(normal)\n\n          // 计算与单位球面的交点（假极点）\n          const fakePolarPoint = {\n            x: unitNormal.x,\n            y: unitNormal.y,\n            z: unitNormal.z\n          }\n\n          // 选择正确的交点（z坐标为正的）\n          if (fakePolarPoint.z < 0) {\n            fakePolarPoint.x = -fakePolarPoint.x\n            fakePolarPoint.y = -fakePolarPoint.y\n            fakePolarPoint.z = -fakePolarPoint.z\n          }\n\n          // 将假极点转换为赤道坐标\n          const fakePolarEquatorial = this.cartesianToEquatorial(fakePolarPoint)\n\n          // 保存假极轴位置\n          this.fakePolarAxis.ra = fakePolarEquatorial.ra\n          this.fakePolarAxis.dec = fakePolarEquatorial.dec\n          this.fakePolarAxis.calculated = true\n\n          this.addLog(`假极轴位置计算完成: RA=${fakePolarEquatorial.ra.toFixed(4)}°, DEC=${fakePolarEquatorial.dec.toFixed(4)}°`, 'success')\n\n          return true\n        } catch (error) {\n          this.addLog(`计算假极轴位置时出错: ${error.message}`, 'error')\n          console.error('计算假极轴位置错误：', error)\n          return false\n        }\n      },\n\n      /**\n       * 将赤道坐标转换为笛卡尔坐标\n       */\n      equatorialToCartesian(ra, dec, radius = 1) {\n        const raRad = ra * Math.PI / 180.0\n        const decRad = dec * Math.PI / 180.0\n\n        return {\n          x: radius * Math.cos(decRad) * Math.cos(raRad),\n          y: radius * Math.cos(decRad) * Math.sin(raRad),\n          z: radius * Math.sin(decRad)\n        }\n      },\n\n      /**\n       * 将笛卡尔坐标转换为赤道坐标\n       */\n      cartesianToEquatorial(cart) {\n        const radius = Math.sqrt(cart.x * cart.x + cart.y * cart.y + cart.z * cart.z)\n\n        const dec = Math.asin(cart.z / radius) * 180.0 / Math.PI\n        let ra = Math.atan2(cart.y, cart.x) * 180.0 / Math.PI\n\n        // 确保RA在0-360度范围内\n        if (ra < 0) ra += 360.0\n\n        return { ra, dec }\n      },\n\n      /**\n       * 计算两个向量的叉积\n       */\n      crossProduct(v1, v2) {\n        return {\n          x: v1.y * v2.z - v1.z * v2.y,\n          y: v1.z * v2.x - v1.x * v2.z,\n          z: v1.x * v2.y - v1.y * v2.x\n        }\n      },\n\n      /**\n       * 计算向量长度\n       */\n      vectorLength(v) {\n        return Math.sqrt(v.x * v.x + v.y * v.y + v.z * v.z)\n      },\n\n      /**\n       * 归一化向量\n       */\n      normalizeVector(v) {\n        const length = this.vectorLength(v)\n        return {\n          x: v.x / length,\n          y: v.y / length,\n          z: v.z / length\n        }\n      },\n\n      /**\n       * 绘制假极轴位置\n       */\n      drawFakePolarAxis(fakePolarRA, fakePolarDEC) {\n        this.addLog(`绘制假极轴位置: RA=${fakePolarRA.toFixed(4)}°, DEC=${fakePolarDEC.toFixed(4)}°`, 'info')\n\n        try {\n          // 定义假极轴的颜色（紫色）\n          const fakePolarColor = {\n            stroke: \"#9C27B0\",        // 紫色边框\n            strokeOpacity: 1,         // 边框不透明度\n            fill: \"#9C27B0\",          // 紫色填充\n            fillOpacity: 0.3          // 填充不透明度（半透明）\n          }\n\n          // 使用专门的假极轴绘制事件，避免与目标点冲突\n          this.$bus.$emit('DrawFakePolarAxisCircle',\n            fakePolarRA,\n            fakePolarDEC,\n            fakePolarColor,\n            'FakePolarAxis',\n            '假极轴'\n          )\n\n          this.addLog(`假极轴位置已绘制: RA=${fakePolarRA.toFixed(4)}°, DEC=${fakePolarDEC.toFixed(4)}°`, 'info')\n\n        } catch (error) {\n          this.addLog(`绘制假极轴位置时出错: ${error.message}`, 'error')\n          console.error('绘制假极轴位置错误：', error)\n        }\n      },\n      // ========================================\n      // 单位换算方法\n      // ========================================\n      unitToArcmin(val, unit) {\n        if (!Number.isFinite(val)) return NaN\n        if (unit === 'deg') return val * 60\n        if (unit === 'arcsec') return val / 60\n        return val // 'arcmin'\n      },\n      arcminToUnit(valArcmin, unit) {\n        if (!Number.isFinite(valArcmin)) return NaN\n        if (unit === 'deg') return valArcmin / 60\n        if (unit === 'arcsec') return valArcmin * 60\n        return valArcmin\n      },\n      unitGlyph(unit) {\n        if (unit === 'deg') return '°'\n        if (unit === 'arcsec') return '″'\n        return '′' // arcmin\n      },\n\n      // ========================================\n      // 左右/上下映射（面向极点）方法\n      // ========================================\n      // 根据当前坐标计算朝向哪个极点\n      calculateFacingPole() {\n        if (!this.$store || !this.$store.state.currentLocation) {\n          return 'north' // 默认返回北极\n        }\n        \n        const lat = this.$store.state.currentLocation.lat\n        // 北半球（纬度 > 0）面向北极，南半球（纬度 < 0）面向南极\n        return lat >= 0 ? 'north' : 'south'\n      },\n\n      // azSign > 0 = 朝东；azSign < 0 = 朝西\n      azLabelBySign(azSign) {\n        // 动态计算朝向极点，而不是使用 props\n        const facingPole = this.calculateFacingPole()\n        // 面向北极点：东=→右，西=←左；面向南极点则相反\n        const east = (facingPole === 'north') ? this.$t('→ Right (East)') : this.$t('← Left (East)')\n        const west = (facingPole === 'north') ? this.$t('← Left (West)') : this.$t('→ Right (West)')\n        return azSign >= 0 ? east : west\n      },\n      // altSign > 0 = 抬高；altSign < 0 = 降低\n      altLabelBySign(altSign) {\n        return altSign >= 0 ? this.$t('↑ Up (Raise)') : this.$t('↓ Down (Lower)')\n      },\n\n      // ========================================\n      // 统一格式化\"数值 + 单位\"方法\n      // ========================================\n      formatWithUnit(valInArcmin, unit, digits = 1) {\n        const v = this.arcminToUnit(Math.abs(valInArcmin), unit)\n        const glyph = this.unitGlyph(unit)\n        return `${v.toFixed(digits)}${glyph}`\n      },\n\n      // ========================================\n      // 颜色工具方法\n      // ========================================\n      getCalibrationPointColor() {\n        return {\n          stroke: COLORS.WHITE,\n          strokeOpacity: 1,\n          fill: COLORS.WHITE,\n          fillOpacity: 0.2\n        }\n      },\n\n      getCurrentPositionColor() {\n        return {\n          stroke: \"#00BFFF\",\n          strokeOpacity: 1,\n          fill: \"#00BFFF\",\n          fillOpacity: 0.3\n        }\n      },\n\n      getTargetPointColor() {\n        return {\n          stroke: COLORS.SUCCESS,\n          strokeOpacity: 1,\n          fill: COLORS.SUCCESS,\n          fillOpacity: 0.3\n        }\n      },\n\n      getFakePolarAxisColor() {\n        return {\n          stroke: \"#9C27B0\",\n          strokeOpacity: 1,\n          fill: \"#9C27B0\",\n          fillOpacity: 0.3\n        }\n      },\n    },\n  }\n</script>\n\n<style scoped>\n/* === 轨迹覆盖层样式 === */\n.trajectory-overlay {\n  position: fixed;\n  inset: 0;\n  background: black;\n  z-index: 10002 !important;\n  pointer-events: auto;\n}\n.trajectory-overlay canvas {\n  position: absolute;\n  left: 0;\n  top: 0;\n  width: 100%;\n  height: 100%;\n}\n.overlay-panel {\n  position: absolute;\n  left: 16px;\n  top: 16px;\n  background: rgba(30, 30, 30, 0.7);\n  color: #fff;\n  border: 1px solid rgba(255,255,255,0.15);\n  border-radius: 8px;\n  padding: 10px 12px;\n  cursor: move;\n}\n.panel-row { display: flex; gap: 8px; margin-bottom: 6px; font-size: 12px; }\n.panel-label { opacity: 0.85; }\n.panel-value { opacity: 0.95; }\n.panel-actions { display: flex; gap: 8px; margin-top: 6px; flex-wrap: wrap; }\n.panel-btn { background: rgba(255,255,255,0.14); color: #fff; border: none; border-radius: 6px; padding: 6px 10px; cursor: pointer; }\n.panel-btn.small { padding: 4px 8px; font-size: 12px; }\n.panel-btn:hover { background: rgba(255,255,255,0.22); }\n\n.trajectory-window {\n  position: fixed;\n  z-index: 10002 !important;\n  background: rgba(18,18,18,0.95);\n  border: 1px solid rgba(255,255,255,0.12);\n  border-radius: 8px;\n  box-shadow: 0 6px 24px rgba(0,0,0,0.4);\n  overflow: hidden;\n  pointer-events: auto;\n}\n.window-header {\n  height: 32px;\n  display: flex;\n  align-items: center;\n  justify-content: space-between;\n  padding: 0 8px;\n  background: rgba(45,45,55,0.9);\n  color: #fff;\n  cursor: move;\n}\n.window-title { font-size: 13px; }\n.window-actions { display: flex; gap: 6px; }\n.window-content { width: 100%; height: calc(100% - 32px); position: relative; overflow: hidden; }\n.window-content canvas { position: absolute; left: 0; top: 0; width: 100%; height: 100%; }\n.overlay-close-btn {\n  position: absolute;\n  right: 16px;\n  top: 16px;\n  width: 36px;\n  height: 36px;\n  border: none;\n  background: rgba(255,255,255,0.12);\n  color: #fff;\n  border-radius: 6px;\n  cursor: pointer;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n}\n.overlay-close-btn:hover {\n  background: rgba(255,255,255,0.2);\n}\n.overlay-hint {\n  position: absolute;\n  left: 50%;\n  bottom: 20px;\n  transform: translateX(-50%);\n  color: rgba(255,255,255,0.85);\n  font-size: 12px;\n}\n/* === 最小化状态样式 === */\n.polar-alignment-minimized {\n  position: fixed;\n  width: 250px;\n  max-width: 80vw;\n  background: rgba(35, 35, 45, 0.95);\n  border: 1px solid rgba(255, 255, 255, 0.1);\n  border-radius: 8px;\n  backdrop-filter: blur(10px);\n  z-index: 1000;\n  cursor: move;\n  user-select: none;\n  box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);\n  transition: all 0.3s ease;\n  /* 添加背景隔离，防止操作映射到背景 */\n  isolation: isolate;\n  /* 移除contain属性，它可能阻止拖动事件 */\n  touch-action: none;\n  -webkit-tap-highlight-color: transparent;\n  -webkit-touch-callout: none;\n  -webkit-user-select: none;\n  -moz-user-select: none;\n  -ms-user-select: none;\n  user-select: none;\n}\n\n/* 拖动状态：移除过渡动画和复杂效果 */\n.polar-alignment-minimized.dragging {\n  transition: none !important;\n  backdrop-filter: none !important;\n  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2) !important;\n  touch-action: manipulation;\n}\n\n.polar-alignment-minimized:hover {\n  box-shadow: 0 6px 25px rgba(0, 0, 0, 0.4);\n}\n\n.polar-alignment-minimized.dragging:hover {\n  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2) !important;\n}\n\n.minimized-header {\n  display: flex;\n  align-items: center;\n  justify-content: space-between;\n  padding: 8px 12px;\n  background: rgba(60, 60, 70, 0.9);\n  border-radius: 8px 8px 0 0;\n  border-bottom: 1px solid rgba(255, 255, 255, 0.1);\n}\n\n.minimized-drag-area {\n  display: flex;\n  align-items: center;\n  flex: 1;\n  cursor: move;\n  /* 确保拖动区域有正确的交互 */\n  user-select: none;\n  -webkit-user-select: none;\n  -moz-user-select: none;\n  -ms-user-select: none;\n  touch-action: none;\n  -webkit-tap-highlight-color: transparent;\n}\n\n.minimized-icon {\n  color: #64b5f6;\n  font-size: 16px;\n  margin-right: 8px;\n}\n\n.minimized-title {\n  font-size: 12px;\n  font-weight: 600;\n  color: #ffffff;\n  flex: 1;\n}\n\n.minimized-controls {\n  display: flex;\n  gap: 4px;\n  /* 确保控制区域可以接收事件 */\n  position: relative;\n  z-index: 20;\n  pointer-events: auto;\n}\n\n.minimized-btn {\n  width: 24px;\n  height: 24px;\n  border: none;\n  background: rgba(255, 255, 255, 0.1);\n  border-radius: 4px;\n  color: #ffffff;\n  cursor: pointer;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  transition: all 0.2s ease;\n  /* 移动端触摸优化 */\n  touch-action: manipulation;\n  -webkit-tap-highlight-color: transparent;\n  /* 确保按钮可以正确点击 */\n  position: relative;\n  z-index: 10;\n  /* 确保按钮可以接收点击事件 */\n  pointer-events: auto;\n}\n\n.minimized-btn:hover {\n  background: rgba(255, 255, 255, 0.2);\n}\n\n.minimized-btn:active {\n  background: rgba(255, 255, 255, 0.3);\n  transform: scale(0.95);\n}\n\n.minimized-status {\n  display: flex;\n  align-items: center;\n  gap: 8px;\n  padding: 8px 12px;\n  font-size: 11px;\n}\n\n.status-indicator {\n  width: 6px;\n  height: 6px;\n  border-radius: 50%;\n  background: #f44336;\n  transition: all 0.3s ease;\n}\n\n.status-indicator.online {\n  background: #4caf50;\n  box-shadow: 0 0 4px rgba(76, 175, 80, 0.6);\n}\n\n.status-text {\n  color: rgba(255, 255, 255, 0.8);\n}\n\n/* === 完整控件样式 === */\n.polar-alignment-widget {\n  position: fixed;\n  width: 350px;\n  max-width: 90vw;\n  background: rgba(35, 35, 45, 0.95);\n  border: 1px solid rgba(255, 255, 255, 0.1);\n  border-radius: 8px;\n  backdrop-filter: blur(10px);\n  z-index: 1000;\n  cursor: move;\n  user-select: none;\n  box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);\n  transition: all 0.3s ease;\n  overflow: hidden;\n  /* 添加背景隔离，防止操作映射到背景 */\n  isolation: isolate;\n  /* 移除contain属性，它可能阻止拖动事件 */\n  touch-action: none;\n  -webkit-tap-highlight-color: transparent;\n  -webkit-touch-callout: none;\n  -webkit-user-select: none;\n  -moz-user-select: none;\n  -ms-user-select: none;\n  user-select: none;\n}\n\n/* 拖动状态：移除过渡动画和复杂效果 */\n.polar-alignment-widget.dragging {\n  transition: none !important;\n  backdrop-filter: none !important;\n  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2) !important;\n  touch-action: manipulation;\n}\n\n.polar-alignment-widget:hover {\n  box-shadow: 0 6px 25px rgba(0, 0, 0, 0.4);\n}\n\n.polar-alignment-widget.dragging:hover {\n  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2) !important;\n}\n\n.polar-alignment-widget.collapsed {\n  width: 300px;\n  max-width: 85vw;\n}\n\n/* === 控件头部样式 === */\n.widget-header {\n  display: flex;\n  align-items: center;\n  justify-content: space-between;\n  padding: 12px 16px;\n  background: rgba(60, 60, 70, 0.9);\n  border-bottom: 1px solid rgba(255, 255, 255, 0.1);\n}\n\n.header-drag-area {\n  display: flex;\n  align-items: center;\n  flex: 1;\n  cursor: move;\n  /* 确保拖动区域有正确的交互 */\n  user-select: none;\n  -webkit-user-select: none;\n  -moz-user-select: none;\n  -ms-user-select: none;\n  /* 添加拖动时的视觉反馈 */\n  transition: background-color 0.2s ease;\n  /* 确保拖动区域有正确的指针事件 */\n  pointer-events: auto;\n  touch-action: none;\n  -webkit-tap-highlight-color: transparent;\n}\n\n.widget-header:hover {\n  background: rgba(60, 60, 70, 0.95);\n}\n\n.header-left {\n  display: flex;\n  align-items: center;\n  gap: 8px;\n  flex: 1;\n}\n\n.header-icon {\n  color: #64b5f6;\n  font-size: 18px;\n}\n\n.header-title {\n  font-size: 14px;\n  font-weight: 600;\n  color: #ffffff;\n}\n\n.connection-indicator {\n  display: flex;\n  align-items: center;\n}\n\n.status-dot {\n  width: 8px;\n  height: 8px;\n  border-radius: 50%;\n  background: #f44336;\n  transition: all 0.3s ease;\n}\n\n.status-dot.online {\n  background: #4caf50;\n  box-shadow: 0 0 6px rgba(76, 175, 80, 0.6);\n}\n\n.header-controls {\n  display: flex;\n  gap: 4px;\n  /* 确保控制区域可以接收事件 */\n  position: relative;\n  z-index: 20;\n  pointer-events: auto;\n}\n\n.header-btn {\n  width: 28px;\n  height: 28px;\n  border: none;\n  background: rgba(255, 255, 255, 0.1);\n  border-radius: 4px;\n  color: #ffffff;\n  cursor: pointer;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  transition: all 0.2s ease;\n  /* 移动端触摸优化 */\n  touch-action: manipulation;\n  -webkit-tap-highlight-color: transparent;\n  /* 确保按钮可以正确点击 */\n  position: relative;\n  z-index: 10;\n  /* 确保按钮可以接收点击事件 */\n  pointer-events: auto;\n}\n\n.header-btn:hover {\n  background: rgba(255, 255, 255, 0.2);\n}\n\n.header-btn:active {\n  background: rgba(255, 255, 255, 0.3);\n  transform: scale(0.95);\n}\n\n.header-btn.close-btn:hover {\n  background: #f44336;\n}\n\n/* === 控件内容样式 === */\n.widget-content {\n  transition: all 0.3s ease;\n  /* 确保内容区域有适当的背景隔离 */\n  background: rgba(35, 35, 45, 0.95);\n  position: relative;\n  z-index: 1;\n  /* 确保内容区域不会阻止拖动事件 */\n  pointer-events: auto;\n}\n\n/* 拖动状态：移除过渡动画 */\n.widget-content.dragging {\n  transition: none !important;\n}\n\n.widget-content.collapsed {\n  padding: 12px;\n}\n\n.widget-content.expanded {\n  padding: 16px;\n  max-height: 80vh;\n  overflow-y: auto;\n  /* 优化内容布局，充分利用空间 */\n  display: flex;\n  flex-direction: column;\n  gap: 16px;\n  /* 确保内容充分利用可用空间 */\n  min-height: 0;\n  flex: 1;\n  /* 自适应高度 */\n  height: auto;\n}\n\n/* === 收缩状态样式 === */\n.collapsed-info {\n  display: flex;\n  align-items: center;\n  gap: 16px;\n}\n\n.collapsed-progress {\n  flex-shrink: 0;\n}\n\n.progress-circle {\n  width: 60px;\n  height: 60px;\n  border-radius: 50%;\n  background: conic-gradient(#64b5f6 0deg var(--progress, 0deg),\n      rgba(255, 255, 255, 0.1) var(--progress, 0deg) 360deg);\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  position: relative;\n}\n\n.progress-circle::before {\n  content: '';\n  position: absolute;\n  width: 50px;\n  height: 50px;\n  border-radius: 50%;\n  background: rgba(35, 35, 45, 0.95);\n}\n\n.progress-text {\n  position: relative;\n  z-index: 1;\n  font-size: 12px;\n  font-weight: 600;\n  color: #ffffff;\n}\n\n.collapsed-status {\n  flex: 1;\n  display: flex;\n  flex-direction: column;\n  gap: 4px;\n}\n\n.status-item {\n  display: flex;\n  justify-content: space-between;\n  align-items: center;\n  font-size: 11px;\n}\n\n.status-label {\n  color: rgba(255, 255, 255, 0.7);\n}\n\n.status-value {\n  color: #ffffff;\n  font-weight: 600;\n  font-family: monospace;\n}\n\n.status-value.needs-adjustment {\n  color: #ff9800;\n}\n\n/* === 展开状态样式 === */\n.content-sections {\n  display: flex;\n  flex-direction: column;\n  gap: 16px;\n  /* 优化布局，充分利用可用空间 */\n  width: 100%;\n  min-height: 0;\n}\n\n/* === 校准步骤进度条样式 === */\n.calibration-progress {\n  margin-bottom: 16px;\n}\n\n.progress-header {\n  display: flex;\n  justify-content: space-between;\n  align-items: center;\n  margin-bottom: 8px;\n}\n\n.progress-title {\n  font-size: 12px;\n  font-weight: 600;\n  color: #ffffff;\n}\n\n.calibration-loop-info {\n  font-size: 10px;\n  color: #ff9800;\n  font-weight: 500;\n  padding: 2px 6px;\n  background: rgba(255, 152, 0, 0.2);\n  border-radius: 4px;\n  animation: loop-pulse 2s infinite;\n}\n\n@keyframes loop-pulse {\n\n  0%,\n  100% {\n    opacity: 1;\n  }\n\n  50% {\n    opacity: 0.7;\n  }\n}\n\n.progress-bar {\n  position: relative;\n  width: 100%;\n  height: 8px;\n  background: rgba(255, 255, 255, 0.1);\n  border-radius: 4px;\n  overflow: visible;\n}\n\n.progress-fill {\n  height: 100%;\n  background: linear-gradient(90deg, #64b5f6, #4caf50);\n  border-radius: 4px;\n  transition: width 0.1s ease;\n}\n\n.progress-nodes {\n  position: absolute;\n  top: 50%;\n  left: 0;\n  right: 0;\n  transform: translateY(-50%);\n  display: flex;\n  justify-content: space-between;\n  align-items: center;\n}\n\n.progress-node {\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  z-index: 2;\n}\n\n.node-circle {\n  width: 20px;\n  height: 20px;\n  border-radius: 50%;\n  background: rgba(255, 255, 255, 0.2);\n  border: 2px solid rgba(255, 255, 255, 0.3);\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  font-size: 10px;\n  font-weight: bold;\n  color: #ffffff;\n  transition: all 0.3s ease;\n}\n\n.progress-node.completed .node-circle {\n  background: #4caf50;\n  border-color: #4caf50;\n  box-shadow: 0 0 8px rgba(76, 175, 80, 0.4);\n}\n\n.progress-node.current .node-circle {\n  background: #64b5f6;\n  border-color: #64b5f6;\n  box-shadow: 0 0 8px rgba(100, 181, 246, 0.4);\n}\n\n.progress-node.adjustment-node .node-circle {\n  background: rgba(255, 152, 0, 0.3);\n  border-color: rgba(255, 152, 0, 0.5);\n}\n\n.progress-node.adjustment-node.active .node-circle {\n  background: #ff9800;\n  border-color: #ff9800;\n  box-shadow: 0 0 8px rgba(255, 152, 0, 0.4);\n}\n\n.progress-node.calibration-node .node-circle {\n  background: rgba(255, 152, 0, 0.3);\n  border-color: rgba(255, 152, 0, 0.5);\n}\n\n.progress-node.calibration-node.active .node-circle {\n  background: #ff9800;\n  border-color: #ff9800;\n  box-shadow: 0 0 8px rgba(255, 152, 0, 0.4);\n}\n\n.progress-node.calibration-node.looping .node-circle {\n  animation: calibration-pulse 2s infinite;\n}\n\n@keyframes calibration-pulse {\n  0% {\n    background: #ff9800;\n    box-shadow: 0 0 8px rgba(255, 152, 0, 0.4);\n  }\n\n  50% {\n    background: #ff5722;\n    box-shadow: 0 0 12px rgba(255, 152, 0, 0.6);\n  }\n\n  100% {\n    background: #ff9800;\n    box-shadow: 0 0 8px rgba(255, 152, 0, 0.4);\n  }\n}\n\n.progress-node.calibration-node.looping .node-circle i {\n  animation: calibration-rotate 2s linear infinite;\n}\n\n@keyframes calibration-rotate {\n  from {\n    transform: rotate(0deg);\n  }\n\n  to {\n    transform: rotate(360deg);\n  }\n}\n\n.progress-node.verification-node .node-circle {\n  background: rgba(76, 175, 80, 0.3);\n  border-color: rgba(76, 175, 80, 0.5);\n}\n\n.progress-node.verification-node.active .node-circle {\n  background: #4caf50;\n  border-color: #4caf50;\n  box-shadow: 0 0 8px rgba(76, 175, 80, 0.4);\n}\n\n.node-label {\n  position: absolute;\n  top: 100%;\n  left: 50%;\n  transform: translateX(-50%);\n  font-size: 9px;\n  color: rgba(255, 255, 255, 0.7);\n  font-weight: 500;\n  margin-top: 4px;\n  white-space: nowrap;\n  text-align: center;\n}\n\n.progress-node {\n  position: relative;\n}\n\n/* === 位置信息样式 === */\n.position-section {\n  margin-top: 16px;\n  padding-top: 16px;\n  border-top: 1px solid rgba(255, 255, 255, 0.1);\n}\n\n.position-grid {\n  display: grid;\n  grid-template-columns: 1fr 1fr;\n  grid-template-rows: 1fr 1fr;\n  gap: 8px;\n  background: rgba(255, 255, 255, 0.05);\n  border-radius: 6px;\n  padding: 12px;\n}\n\n.position-cell {\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n  gap: 4px;\n  padding: 8px;\n  border-radius: 4px;\n  transition: all 0.3s ease;\n}\n\n.position-cell.current {\n  background: rgba(100, 181, 246, 0.1);\n  border: 1px solid rgba(100, 181, 246, 0.2);\n}\n\n.position-cell.target {\n  background: rgba(255, 152, 0, 0.1);\n  border: 1px solid rgba(255, 152, 0, 0.2);\n}\n\n.cell-label {\n  font-size: 10px;\n  color: rgba(255, 255, 255, 0.7);\n  font-weight: 500;\n  text-transform: uppercase;\n  letter-spacing: 0.5px;\n}\n\n.cell-value {\n  font-size: 11px;\n  color: #ffffff;\n  font-family: monospace;\n  font-weight: 600;\n}\n\n/* === 调整指导样式 === */\n.adjustment-section {\n  margin-top: 16px;\n  padding-top: 16px;\n  border-top: 1px solid rgba(255, 255, 255, 0.1);\n}\n\n.adjustment-instructions {\n  display: flex;\n  flex-direction: column;\n  gap: 8px;\n}\n\n.adjustment-item {\n  display: flex;\n  align-items: center;\n  gap: 12px;\n  padding: 12px;\n  background: rgba(255, 255, 255, 0.05);\n  border-radius: 6px;\n  transition: all 0.3s ease;\n  border: 1px solid transparent;\n}\n\n.adjustment-item.active {\n  background: rgba(255, 152, 0, 0.15);\n  border-color: #ff9800;\n}\n\n.adjustment-icon {\n  width: 28px;\n  height: 28px;\n  border-radius: 50%;\n  background: rgba(255, 255, 255, 0.1);\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  font-size: 14px;\n  color: #ffffff;\n  flex-shrink: 0;\n}\n\n.adjustment-item.active .adjustment-icon {\n  background: #ff9800;\n}\n\n.adjustment-details {\n  flex: 1;\n  display: flex;\n  flex-direction: column;\n  gap: 4px;\n}\n\n.adjustment-header {\n  display: flex;\n  justify-content: space-between;\n  align-items: center;\n}\n\n.adjustment-type {\n  font-size: 12px;\n  color: #ffffff;\n  font-weight: 500;\n}\n\n.adjustment-value {\n  font-size: 18px;\n  color: #ffffff;\n  font-family: monospace;\n  font-weight: 700;\n  text-shadow: 0 0 4px rgba(255, 255, 255, 0.3);\n  letter-spacing: 1px;\n}\n\n.adjustment-action {\n  font-size: 10px;\n  color: rgba(255, 255, 255, 0.7);\n  font-weight: 500;\n}\n\n.adjustment-item.active .adjustment-action {\n  color: #ff9800;\n}\n\n/* === 操作按钮样式 === */\n.control-section {\n  margin-top: 16px;\n  padding-top: 16px;\n  border-top: 1px solid rgba(255, 255, 255, 0.1);\n}\n\n.action-buttons {\n  display: flex;\n  flex-direction: row;\n  gap: 10px;\n}\n\n.action-btn {\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  gap: 8px;\n  padding: 12px 16px;\n  border: none;\n  border-radius: 6px;\n  cursor: pointer;\n  font-size: 13px;\n  font-weight: 500;\n  transition: all 0.3s ease;\n  pointer-events: auto;\n  min-height: 40px;\n  touch-action: manipulation;\n  position: relative;\n  flex: 1;\n}\n\n.action-btn.primary {\n  background: linear-gradient(135deg, #64b5f6, #42a5f5);\n  color: #ffffff;\n  box-shadow: 0 2px 6px rgba(100, 181, 246, 0.3);\n}\n\n.action-btn.primary:hover:not(:disabled) {\n  background: linear-gradient(135deg, #42a5f5, #2196f3);\n  transform: translateY(-1px);\n  box-shadow: 0 4px 12px rgba(100, 181, 246, 0.4);\n}\n\n.action-btn.secondary {\n  background: rgba(255, 255, 255, 0.1);\n  color: #ffffff;\n  border: 1px solid rgba(255, 255, 255, 0.2);\n}\n\n.action-btn.secondary:hover:not(:disabled) {\n  background: rgba(255, 255, 255, 0.2);\n  transform: translateY(-1px);\n}\n\n.action-btn.success {\n  background: linear-gradient(135deg, #4caf50, #43a047);\n  color: #ffffff;\n  box-shadow: 0 2px 6px rgba(76, 175, 80, 0.3);\n}\n\n.action-btn.success:hover:not(:disabled) {\n  background: linear-gradient(135deg, #43a047, #388e3c);\n  transform: translateY(-1px);\n  box-shadow: 0 4px 12px rgba(76, 175, 80, 0.4);\n}\n\n.action-btn.restore {\n  background: linear-gradient(135deg, #ff9800, #f57c00);\n  color: #ffffff;\n  box-shadow: 0 2px 6px rgba(255, 152, 0, 0.3);\n}\n\n.action-btn.restore:hover:not(:disabled) {\n  background: linear-gradient(135deg, #f57c00, #ef6c00);\n  transform: translateY(-1px);\n  box-shadow: 0 4px 12px rgba(255, 152, 0, 0.4);\n}\n\n.action-btn:disabled {\n  opacity: 0.5;\n  cursor: not-allowed;\n  transform: none !important;\n  box-shadow: none !important;\n}\n\n/* === 日志显示样式 === */\n.log-section {\n  margin-top: 16px;\n  padding-top: 16px;\n  border-top: 1px solid rgba(255, 255, 255, 0.1);\n}\n\n.log-display {\n  background: rgba(255, 255, 255, 0.05);\n  border-radius: 6px;\n  padding: 10px;\n}\n\n.latest-log {\n  display: flex;\n  align-items: center;\n  gap: 8px;\n  padding: 8px 10px;\n  border-radius: 4px;\n  font-size: 11px;\n  background: rgba(255, 255, 255, 0.05);\n  border-left: 3px solid transparent;\n}\n\n.latest-log.info {\n  border-left-color: #64b5f6;\n}\n\n.latest-log.warning {\n  border-left-color: #ff9800;\n}\n\n.latest-log.success {\n  border-left-color: #4caf50;\n}\n\n.latest-log.error {\n  border-left-color: #f44336;\n}\n\n.log-timestamp {\n  color: rgba(255, 255, 255, 0.6);\n  font-family: monospace;\n  font-size: 10px;\n  min-width: 65px;\n  flex-shrink: 0;\n}\n\n.log-message {\n  color: rgba(255, 255, 255, 0.9);\n  flex: 1;\n  line-height: 1.4;\n}\n\n.log-empty {\n  text-align: center;\n  color: rgba(255, 255, 255, 0.5);\n  font-size: 11px;\n  padding: 20px;\n  font-style: italic;\n}\n\n/* === 响应式设计 === */\n@media (max-width: 768px) {\n  .polar-alignment-widget {\n    width: 320px;\n    max-width: 95vw;\n  }\n\n  .polar-alignment-widget.collapsed {\n    width: 280px;\n    max-width: 90vw;\n  }\n\n  .polar-alignment-minimized {\n    width: 240px;\n  }\n\n  .widget-header {\n    padding: 10px 12px;\n  }\n\n  .header-title {\n    font-size: 12px;\n  }\n\n  .widget-content.expanded {\n    padding: 12px;\n    max-height: 500px;\n  }\n\n  .widget-content.collapsed {\n    padding: 8px;\n  }\n\n  .action-btn {\n    padding: 10px 12px;\n    font-size: 12px;\n    min-height: 36px;\n  }\n\n  .adjustment-value {\n    font-size: 16px;\n  }\n\n  .progress-circle {\n    width: 50px;\n    height: 50px;\n  }\n\n  .progress-text {\n    font-size: 10px;\n  }\n\n  .node-label {\n    font-size: 8px;\n    margin-top: 2px;\n  }\n\n  .node-circle {\n    width: 16px;\n    height: 16px;\n    font-size: 8px;\n  }\n\n  .progress-header {\n    margin-bottom: 6px;\n  }\n\n  .progress-title {\n    font-size: 11px;\n  }\n\n  .calibration-loop-info {\n    font-size: 9px;\n    padding: 1px 4px;\n  }\n}\n\n/* 移动端触摸优化 */\n@media (hover: none) and (pointer: coarse) {\n  .action-btn {\n    min-height: 48px;\n    padding: 14px 18px;\n    font-size: 14px;\n  }\n\n  .widget-header {\n    padding: 16px 20px;\n  }\n\n  .minimized-header {\n    padding: 12px 16px;\n  }\n\n  .header-btn {\n    width: 32px;\n    height: 32px;\n  }\n\n  .minimized-btn {\n    width: 28px;\n    height: 28px;\n  }\n}\n\n@media (max-width: 480px) {\n  .polar-alignment-widget {\n    width: 280px;\n    max-width: 98vw;\n  }\n\n  .polar-alignment-widget.collapsed {\n    width: 240px;\n    max-width: 95vw;\n  }\n\n  .polar-alignment-minimized {\n    width: 200px;\n  }\n\n  .widget-header {\n    padding: 8px 10px;\n  }\n\n  .header-title {\n    font-size: 11px;\n  }\n\n  .header-btn {\n    width: 20px;\n    height: 20px;\n  }\n\n  .widget-content.expanded {\n    padding: 10px;\n    max-height: 400px;\n  }\n\n  .widget-content.collapsed {\n    padding: 6px;\n  }\n\n  .action-btn {\n    padding: 8px 10px;\n    font-size: 11px;\n    min-height: 32px;\n  }\n\n  .adjustment-value {\n    font-size: 14px;\n  }\n\n  .progress-circle {\n    width: 40px;\n    height: 40px;\n  }\n\n  .progress-text {\n    font-size: 9px;\n  }\n\n  .minimized-header {\n    padding: 6px 8px;\n  }\n\n  .minimized-title {\n    font-size: 10px;\n  }\n\n  .minimized-btn {\n    width: 16px;\n    height: 16px;\n  }\n\n  .node-label {\n    font-size: 7px;\n    margin-top: 1px;\n  }\n\n  .node-circle {\n    width: 14px;\n    height: 14px;\n    font-size: 7px;\n  }\n\n  .progress-nodes {\n    gap: 2px;\n  }\n\n  .progress-header {\n    margin-bottom: 4px;\n  }\n\n  .progress-title {\n    font-size: 10px;\n  }\n\n  .calibration-loop-info {\n    font-size: 8px;\n    padding: 1px 3px;\n  }\n}\n\n/* 面板标题 */\n.panel-header {\n  margin-bottom: 16px;\n  padding-bottom: 8px;\n  border-bottom: 1px solid rgba(255, 255, 255, 0.1);\n  display: flex;\n  justify-content: space-between;\n  align-items: center;\n  pointer-events: auto;\n}\n\n.panel-header h3 {\n  margin: 0;\n  font-size: 18px;\n  font-weight: 600;\n  color: #ffffff;\n}\n\n.panel-indicator {\n  width: 8px;\n  height: 8px;\n  border-radius: 50%;\n  background: #64b5f6;\n}\n\n.panel-indicator.live {\n  animation: pulse 2s infinite;\n}\n\n.panel-indicator.control {\n  background: #ff9800;\n}\n\n@keyframes pulse {\n  0% {\n    opacity: 1;\n  }\n\n  50% {\n    opacity: 0.5;\n  }\n\n  100% {\n    opacity: 1;\n  }\n}\n\n\n\n.card-header {\n  background: rgba(60, 60, 70, 0.8);\n  padding: 12px 16px;\n  display: flex;\n  align-items: center;\n  justify-content: space-between;\n  border-bottom: 1px solid rgba(255, 255, 255, 0.1);\n  pointer-events: auto;\n}\n\n.card-header span {\n  font-size: 14px;\n  font-weight: 500;\n  color: #ffffff;\n}\n\n.card-icon {\n  color: #64b5f6;\n  font-size: 18px;\n}\n\n.card-icon.warning {\n  color: #ff9800;\n}\n\n.card-icon.success {\n  color: #4caf50;\n}\n\n\n\n\n\n\n/* === 响应式设计 === */\n@media (max-width: 1200px) {\n  .info-panel {\n    flex: 0 0 350px;\n  }\n}\n\n@media (max-width: 768px) {\n  .polar-alignment-interface {\n    font-size: 12px;\n  }\n\n  .main-layout {\n    flex-direction: column;\n    gap: 8px;\n    padding: 8px;\n  }\n\n  .display-panel {\n    flex: 1;\n    min-height: 300px;\n    padding: 12px;\n  }\n\n  .info-panel {\n    flex: 0 0 auto;\n    max-height: 50vh;\n    overflow-y: auto;\n    padding: 12px;\n  }\n\n  /* 状态相关样式已删除 */\n\n  .calibration-progress {\n    margin-bottom: 12px;\n  }\n\n  .progress-bar {\n    height: 6px;\n  }\n\n  .node-circle {\n    width: 16px;\n    height: 16px;\n    font-size: 8px;\n  }\n\n  .position-section {\n    margin-top: 12px;\n    padding-top: 12px;\n  }\n\n  .position-grid {\n    gap: 6px;\n    padding: 8px;\n  }\n\n  .position-cell {\n    padding: 6px;\n  }\n\n  .adjustment-section {\n    margin-top: 12px;\n    padding-top: 12px;\n  }\n\n  .adjustment-item {\n    padding: 8px;\n  }\n\n  .adjustment-icon {\n    width: 24px;\n    height: 24px;\n  }\n\n  .control-section {\n    margin-top: 12px;\n    padding-top: 12px;\n  }\n\n  .action-btn {\n    padding: 10px 12px;\n    font-size: 12px;\n    min-height: 36px;\n    flex: 1;\n  }\n\n  .log-section {\n    margin-top: 12px;\n    padding-top: 12px;\n  }\n\n  .log-display {\n    padding: 8px;\n  }\n\n  .panel-header {\n    margin-bottom: 8px;\n    padding-bottom: 8px;\n  }\n\n  .interface-title {\n    font-size: 14px;\n  }\n\n  .connection-status {\n    font-size: 10px;\n  }\n\n  .card-header {\n    padding: 8px 12px;\n  }\n\n  .card-header span {\n    font-size: 12px;\n  }\n\n  .card-content {\n    padding: 12px;\n  }\n\n\n\n  .node-circle {\n    width: 14px;\n    height: 14px;\n    font-size: 7px;\n  }\n\n  .log-display {\n    padding: 6px;\n  }\n\n  .latest-log {\n    font-size: 10px;\n  }\n\n  .log-timestamp {\n    min-width: 50px;\n  }\n}\n\n@media (max-width: 480px) {\n  .polar-alignment-interface {\n    font-size: 10px;\n  }\n\n  .main-layout {\n    flex-direction: column;\n    gap: 6px;\n    padding: 6px;\n  }\n\n  .display-panel {\n    flex: 1;\n    min-height: 250px;\n    padding: 8px;\n  }\n\n  .info-panel {\n    flex: 0 0 auto;\n    max-height: 45vh;\n    overflow-y: auto;\n    padding: 8px;\n  }\n\n  .card-header {\n    padding: 8px 12px;\n  }\n\n  .card-header span {\n    font-size: 11px;\n  }\n\n  .card-content {\n    padding: 12px;\n  }\n\n  /* 状态相关样式已删除 */\n\n  .calibration-progress {\n    margin-bottom: 8px;\n  }\n\n  .progress-bar {\n    height: 4px;\n  }\n\n  .node-circle {\n    width: 14px;\n    height: 14px;\n    font-size: 7px;\n  }\n\n  .position-section {\n    margin-top: 8px;\n    padding-top: 8px;\n  }\n\n  .position-grid {\n    gap: 4px;\n    padding: 6px;\n  }\n\n  .position-cell {\n    padding: 4px;\n  }\n\n  .cell-label {\n    font-size: 8px;\n  }\n\n  .cell-value {\n    font-size: 9px;\n  }\n\n  .adjustment-section {\n    margin-top: 8px;\n    padding-top: 8px;\n  }\n\n  .adjustment-item {\n    padding: 6px;\n  }\n\n  .adjustment-icon {\n    width: 20px;\n    height: 20px;\n  }\n\n  .adjustment-type {\n    font-size: 10px;\n  }\n\n  .adjustment-value {\n    font-size: 10px;\n  }\n\n  .adjustment-action {\n    font-size: 8px;\n  }\n\n  .control-section {\n    margin-top: 8px;\n    padding-top: 8px;\n  }\n\n  .action-btn {\n    padding: 8px 10px;\n    font-size: 10px;\n    min-height: 32px;\n    flex: 1;\n  }\n\n  .log-section {\n    margin-top: 8px;\n    padding-top: 8px;\n  }\n\n  .log-display {\n    padding: 6px;\n  }\n\n  .latest-log {\n    font-size: 9px;\n  }\n\n  .log-timestamp {\n    font-size: 8px;\n    min-width: 45px;\n  }\n\n  .panel-header {\n    margin-bottom: 6px;\n    padding-bottom: 6px;\n  }\n\n}\n\n/* === 触摸优化 === */\n.polar-alignment-widget,\n.polar-alignment-minimized {\n  /* 触摸优化 */\n  touch-action: none;\n  -webkit-tap-highlight-color: transparent;\n  -webkit-touch-callout: none;\n  -webkit-user-select: none;\n  -moz-user-select: none;\n  -ms-user-select: none;\n  user-select: none;\n}\n\n.header-drag-area,\n.minimized-drag-area {\n  /* 触摸优化 */\n  touch-action: none;\n  -webkit-tap-highlight-color: transparent;\n}\n\n/* 拖动状态：移除触摸优化，允许正常触摸 */\n.polar-alignment-widget.dragging,\n.polar-alignment-minimized.dragging {\n  touch-action: manipulation;\n}\n\n/* === 性能优化 === */\n/* 拖动时禁用不必要的动画和效果 */\n.dragging * {\n  animation: none !important;\n  transition: none !important;\n}\n\n/* 拖动时简化阴影和模糊效果 */\n.dragging .progress-circle::before,\n.dragging .node-circle,\n.dragging .status-indicator {\n  box-shadow: none !important;\n  filter: none !important;\n}\n</style>"]}]}