{"remainingRequest":"/home/quarcs/workspace/QUARCS/QUARCS_stellarium-web-engine/apps/web-frontend/node_modules/vue-loader/lib/index.js??vue-loader-options!/home/quarcs/workspace/QUARCS/QUARCS_stellarium-web-engine/apps/web-frontend/src/components/Chart-Focus.vue?vue&type=script&lang=js&","dependencies":[{"path":"/home/quarcs/workspace/QUARCS/QUARCS_stellarium-web-engine/apps/web-frontend/src/components/Chart-Focus.vue","mtime":1760075098000},{"path":"/home/quarcs/workspace/QUARCS/QUARCS_stellarium-web-engine/apps/web-frontend/node_modules/cache-loader/dist/cjs.js","mtime":1707125360000},{"path":"/home/quarcs/workspace/QUARCS/QUARCS_stellarium-web-engine/apps/web-frontend/node_modules/thread-loader/dist/cjs.js","mtime":1707125360000},{"path":"/home/quarcs/workspace/QUARCS/QUARCS_stellarium-web-engine/apps/web-frontend/node_modules/babel-loader/lib/index.js","mtime":1707125360000},{"path":"/home/quarcs/workspace/QUARCS/QUARCS_stellarium-web-engine/apps/web-frontend/node_modules/cache-loader/dist/cjs.js","mtime":1707125360000},{"path":"/home/quarcs/workspace/QUARCS/QUARCS_stellarium-web-engine/apps/web-frontend/node_modules/vue-loader/lib/index.js","mtime":1707125450000}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:Ly8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KCmltcG9ydCAqIGFzIGVjaGFydHMgZnJvbSAnZWNoYXJ0cyc7CgpleHBvcnQgZGVmYXVsdCB7CiAgbmFtZTogJ0xpbmVDaGFydCcsCiAgcHJvcHM6IHsKICAgIC8vIOaYr+WQpuS9v+eUqOaXtumXtOi9tOaooeW8j++8iOS5n+WPr+mAmui/h+aAu+e6vyBzZXRGb2N1c0NoYXJ0VGltZU1vZGUg5YiH5o2i77yJCiAgICB1c2VUaW1lQXhpczogewogICAgICB0eXBlOiBCb29sZWFuLAogICAgICBkZWZhdWx0OiBmYWxzZQogICAgfSwKICAgIC8vIOaXtumXtOeql+WPo+mVv+W6pu+8iOenku+8ie+8jOS7heWcqOaXtumXtOi9tOaooeW8j+S4i+eUn+aViAogICAgdGltZVdpbmRvd1NlYzogewogICAgICB0eXBlOiBOdW1iZXIsCiAgICAgIGRlZmF1bHQ6IDYwCiAgICB9CiAgfSwKICBkYXRhKCkgewogICAgcmV0dXJuIHsKICAgICAgY29udGFpbmVyTWF4V2lkdGg6IDE1MCwKICAgICAgLy8g6Z2e5pe26Ze06L2077ya5pWj54K55pWw5o2u77yIeCDkuLrnlLXosIPkvY3nva7vvIkKICAgICAgY2hhcnREYXRhMV9wb3M6IFtdLAogICAgICAvLyDml7bpl7TovbTvvJrmlaPngrnmlbDmja7vvIh4IOS4uuaXtumXtOaIs++8iQogICAgICBjaGFydERhdGExX3RpbWU6IFtdLAogICAgICBjaGFydERhdGEyOiBbXSwKICAgICAgY2hhcnREYXRhMzogW10sCiAgICAgIHhBeGlzX21pbjogMCwKICAgICAgeEF4aXNfbWF4OiA2MDAwLAogICAgICB5QXhpc19taW46IDAsCiAgICAgIHlBeGlzX21heDogMzAsCiAgICAgIHJhbmdlOiA0LAogICAgICBjdXJyZW50WDogMCwKICAgICAgRldITU1heDogMCwKICAgICAgaXNEcmFnZ2luZzogZmFsc2UsCiAgICAgIHN0YXJ0WDogMCwKICAgICAgZGVsdGFYOiAwLAogICAgICB4X21pbjogLTYwMDAwLAogICAgICB4X21heDogNjAwMDAsCiAgICAgIC8vIOaXtumXtOi9tOaooeW8jwogICAgICBpc1RpbWVNb2RlOiBmYWxzZSwKICAgICAgdGltZVRpY2tlcjogbnVsbCwKICAgICAgLy8g5Y+v6KeB5oCn5o6n5Yi2CiAgICAgIGlzVmlzaWJsZTogZmFsc2UsCiAgICAgIGlvT2JzZXJ2ZXI6IG51bGwsCiAgICAgIC8vIOa4suafk+iwg+W6pgogICAgICByZW5kZXJSYWZJZDogbnVsbCwKICAgICAgcmVuZGVyU2NoZWR1bGVkOiBmYWxzZSwKICAgICAgcGVuZGluZ0xvd2VyQm91bmQ6IG51bGwsCiAgICAgIHBlbmRpbmdVcHBlckJvdW5kOiBudWxsLAogICAgICAvLyDosIPor5Xml6Xlv5flvIDlhbMKICAgICAgZGVidWdSZW5kZXJMb2dzOiBmYWxzZSwKICAgICAgLy8g57q/5p2h5pWw5o2u5p2l5rqQ77ya6Iul5Li6IG51bGwg5YiZ5L2/55SoIHF1YWRyYXRpY1BhcmFtcyDliqjmgIHph4fmoLcKICAgICAgbGluZURhdGFGcm9tUG9pbnRzOiBudWxsLAogICAgICBxdWFkcmF0aWNQYXJhbXM6IG51bGwgLy8geyBhLGIsYyx4MD8gfQogICAgfTsKICB9LAogIG1vdW50ZWQoKSB7CiAgICAvLyDmoLnmja7lj6/op4HmgKflkK/liqgv5YGc5q2i5pe26Ze05o6o6L+bCiAgICBjb25zdCBlbCA9IHRoaXMuJHJlZnMubGluZWNoYXJ0OwogICAgaWYgKHdpbmRvdyAmJiAnSW50ZXJzZWN0aW9uT2JzZXJ2ZXInIGluIHdpbmRvdyAmJiBlbCkgewogICAgICB0aGlzLmlvT2JzZXJ2ZXIgPSBuZXcgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIoKGVudHJpZXMpID0+IHsKICAgICAgICBjb25zdCBlID0gZW50cmllc1swXTsKICAgICAgICB0aGlzLmlzVmlzaWJsZSA9ICEhKGUgJiYgZS5pc0ludGVyc2VjdGluZyk7CiAgICAgICAgdGhpcy51cGRhdGVUaWNrZXJCeVZpc2liaWxpdHkoKTsKICAgICAgfSwgeyB0aHJlc2hvbGQ6IDAuMDEgfSk7CiAgICAgIHRoaXMuaW9PYnNlcnZlci5vYnNlcnZlKGVsKTsKICAgIH0gZWxzZSB7CiAgICAgIC8vIOWbnumAgO+8muS4jeWPr+ingeaAp+acquefpeaXtuinhuS4uuWPr+ingQogICAgICB0aGlzLmlzVmlzaWJsZSA9IHRydWU7CiAgICB9CiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCd2aXNpYmlsaXR5Y2hhbmdlJywgdGhpcy51cGRhdGVUaWNrZXJCeVZpc2liaWxpdHkpOwoKICAgIC8vIOWIneWni+WMluaXtumXtOi9tOaooeW8j++8iOeUsSBwcm9wIOaOp+WItu+8iQogICAgdGhpcy5pc1RpbWVNb2RlID0gISF0aGlzLnVzZVRpbWVBeGlzOwogICAgdGhpcy51cGRhdGVUaWNrZXJCeVZpc2liaWxpdHkoKTsKICB9LAogIGNyZWF0ZWQoKSB7CiAgICB0aGlzLiRidXMuJG9uKCdGb2N1c1Bvc2l0aW9uJywgdGhpcy5jaGFuZ2VSYW5nZV94KTsKICAgIC8vIHRoaXMuJGJ1cy4kb24oJ1VwZGF0ZUZXSE0nLCB0aGlzLlVwZGF0ZUZXSE0pOwogICAgLy8gdGhpcy4kYnVzLiRvbignZml0UXVhZHJhdGljQ3VydmUnLCB0aGlzLmZpdFF1YWRyYXRpY0N1cnZlKTsKICAgIC8vIHRoaXMuJGJ1cy4kb24oJ2ZpdFF1YWRyYXRpY0N1cnZlX21pblBvaW50JywgdGhpcy5maXRRdWFkcmF0aWNDdXJ2ZV9taW5Qb2ludCk7CgogICAgdGhpcy4kYnVzLiRvbignQ2xlYXJmaXRRdWFkcmF0aWNDdXJ2ZScsIHRoaXMuY2xlYXJDaGFydERhdGEyKTsKICAgIHRoaXMuJGJ1cy4kb24oJ0NsZWFyQWxsRGF0YScsIHRoaXMuQ2xlYXJBbGxEYXRhKTsKICAgIHRoaXMuJGJ1cy4kb24oJ3VwZGF0ZUZvY3VzQ2hhcnRXaWR0aCcsIHRoaXMuaW5pdENoYXJ0KTsKICAgIHRoaXMuJGJ1cy4kb24oJ2FkZERhdGFfUG9pbnQnLCB0aGlzLmFkZERhdGFfUG9pbnQpOwogICAgdGhpcy4kYnVzLiRvbignYWRkTWluUG9pbnREYXRhX1BvaW50JywgdGhpcy5hZGRNaW5Qb2ludERhdGFfUG9pbnQpOwogICAgdGhpcy4kYnVzLiRvbignYWRkTGluZURhdGFfUG9pbnQnLCB0aGlzLmFkZExpbmVEYXRhX1BvaW50KTsKICAgIHRoaXMuJGJ1cy4kb24oJ3NldEZvY3VzQ2hhcnRSYW5nZScsIHRoaXMuc2V0Rm9jdXNDaGFydFJhbmdlKTsKICAgIC8vIOaWsOWinu+8muaXtumXtOi9tOaooeW8j+aOp+WItuS4jueCuei/veWKoAogICAgdGhpcy4kYnVzLiRvbignc2V0Rm9jdXNDaGFydFRpbWVNb2RlJywgdGhpcy5zZXRUaW1lTW9kZSk7CiAgICB0aGlzLiRidXMuJG9uKCdhZGRGd2htTm93JywgdGhpcy5hZGRGd2htUG9pbnROb3cpOwoKICB9LAogIGJlZm9yZURlc3Ryb3koKSB7CiAgICB0aGlzLnRlYXJkb3duQnVzQW5kVGltZXJzKCk7CiAgfSwKICBkZXN0cm95ZWQoKSB7CiAgICB0aGlzLnRlYXJkb3duQnVzQW5kVGltZXJzKCk7CiAgfSwKICBtZXRob2RzOiB7CiAgICB0ZWFyZG93bkJ1c0FuZFRpbWVycygpIHsKICAgICAgdGhpcy4kYnVzLiRvZmYoJ0ZvY3VzUG9zaXRpb24nLCB0aGlzLmNoYW5nZVJhbmdlX3gpOwogICAgICB0aGlzLiRidXMuJG9mZignQ2xlYXJmaXRRdWFkcmF0aWNDdXJ2ZScsIHRoaXMuY2xlYXJDaGFydERhdGEyKTsKICAgICAgdGhpcy4kYnVzLiRvZmYoJ0NsZWFyQWxsRGF0YScsIHRoaXMuQ2xlYXJBbGxEYXRhKTsKICAgICAgdGhpcy4kYnVzLiRvZmYoJ3VwZGF0ZUZvY3VzQ2hhcnRXaWR0aCcsIHRoaXMuaW5pdENoYXJ0KTsKICAgICAgdGhpcy4kYnVzLiRvZmYoJ2FkZERhdGFfUG9pbnQnLCB0aGlzLmFkZERhdGFfUG9pbnQpOwogICAgICB0aGlzLiRidXMuJG9mZignYWRkTWluUG9pbnREYXRhX1BvaW50JywgdGhpcy5hZGRNaW5Qb2ludERhdGFfUG9pbnQpOwogICAgICB0aGlzLiRidXMuJG9mZignYWRkTGluZURhdGFfUG9pbnQnLCB0aGlzLmFkZExpbmVEYXRhX1BvaW50KTsKICAgICAgdGhpcy4kYnVzLiRvZmYoJ2FkZFF1YWRyYXRpY0N1cnZlJywgdGhpcy5hZGRMaW5lRGF0YV9Qb2ludCk7CiAgICAgIHRoaXMuJGJ1cy4kb2ZmKCdzZXRGb2N1c0NoYXJ0UmFuZ2UnLCB0aGlzLnNldEZvY3VzQ2hhcnRSYW5nZSk7CiAgICAgIHRoaXMuJGJ1cy4kb2ZmKCdzZXRGb2N1c0NoYXJ0VGltZU1vZGUnLCB0aGlzLnNldFRpbWVNb2RlKTsKICAgICAgdGhpcy4kYnVzLiRvZmYoJ2FkZEZ3aG1Ob3cnLCB0aGlzLmFkZEZ3aG1Qb2ludE5vdyk7CiAgICAgIGlmICh0aGlzLnRpbWVUaWNrZXIpIHsKICAgICAgICBjbGVhckludGVydmFsKHRoaXMudGltZVRpY2tlcik7CiAgICAgICAgdGhpcy50aW1lVGlja2VyID0gbnVsbDsKICAgICAgfQogICAgICBpZiAodGhpcy5pb09ic2VydmVyKSB7CiAgICAgICAgdHJ5IHsgdGhpcy5pb09ic2VydmVyLmRpc2Nvbm5lY3QoKTsgfSBjYXRjaCAoZSkge30KICAgICAgICB0aGlzLmlvT2JzZXJ2ZXIgPSBudWxsOwogICAgICB9CiAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Zpc2liaWxpdHljaGFuZ2UnLCB0aGlzLnVwZGF0ZVRpY2tlckJ5VmlzaWJpbGl0eSk7CiAgICB9LAogICAgaW5pdENoYXJ0KFdpZHRoKSB7CiAgICAgIHRoaXMuY29udGFpbmVyTWF4V2lkdGggPSBXaWR0aCAtIDk1OwogICAgICBjb25zdCBjaGFydERvbSA9IHRoaXMuJHJlZnMubGluZWNoYXJ0OwogICAgICBjaGFydERvbS5zdHlsZS53aWR0aCA9IHRoaXMuY29udGFpbmVyTWF4V2lkdGggKyAncHgnOwogICAgICB0aGlzLm15Q2hhcnQgPSBlY2hhcnRzLmluaXQoY2hhcnREb20pOwogICAgICB0aGlzLnJlbmRlckNoYXJ0KHRoaXMueEF4aXNfbWluLCB0aGlzLnhBeGlzX21heCk7CiAgICB9LAogICAgc3RhcnREcmFnKGV2ZW50KSB7CiAgICAgIGlmICh0aGlzLmlzVGltZU1vZGUpIHJldHVybjsgLy8g5pe26Ze06L205qih5byP5LiL56aB55So5ouW5ou9CiAgICAgIHRoaXMuaXNEcmFnZ2luZyA9IHRydWU7CiAgICAgIGNvbnN0IHggPSB0aGlzLmdldENsaWVudFgoZXZlbnQpOwogICAgICBpZiAodHlwZW9mIHggPT09ICdudW1iZXInKSB0aGlzLnN0YXJ0WCA9IHg7CiAgICB9LAogICAgZHJhZ2dpbmcoZXZlbnQpIHsKICAgICAgaWYgKHRoaXMuaXNEcmFnZ2luZyAmJiAhdGhpcy5pc1RpbWVNb2RlKSB7CiAgICAgICAgY29uc3QgeCA9IHRoaXMuZ2V0Q2xpZW50WChldmVudCk7CiAgICAgICAgaWYgKHR5cGVvZiB4ICE9PSAnbnVtYmVyJykgcmV0dXJuOwogICAgICAgIHRoaXMuZGVsdGFYID0gKHggLSB0aGlzLnN0YXJ0WCkgKiAxMDsKICAgICAgICB0aGlzLnN0YXJ0WCA9IHg7CiAgICAgICAgY29uc3Qgd2luZG93V2lkdGggPSB0aGlzLnhBeGlzX21heCAtIHRoaXMueEF4aXNfbWluOwogICAgICAgIC8vIOiuoeeul+aWsOeahOiMg+WbtOW5tuWBmui+ueeVjOijgeWJqgogICAgICAgIGxldCBuZXdNaW4gPSB0aGlzLnhBeGlzX21pbiAtIHRoaXMuZGVsdGFYOwogICAgICAgIGNvbnN0IG1pbkFsbG93ZWQgPSB0aGlzLnhfbWluOwogICAgICAgIGNvbnN0IG1heEFsbG93ZWQgPSB0aGlzLnhfbWF4IC0gd2luZG93V2lkdGg7CiAgICAgICAgaWYgKG1heEFsbG93ZWQgPCBtaW5BbGxvd2VkKSB7CiAgICAgICAgICAvLyDlronlhajlpITnkIbvvJroi6Xorr7nva7kuI3lkIjnkIbvvIzlm57pgIDliLDkuI3np7vliqgKICAgICAgICAgIG5ld01pbiA9IHRoaXMueF9taW47CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIG5ld01pbiA9IE1hdGgubWF4KG1pbkFsbG93ZWQsIE1hdGgubWluKG1heEFsbG93ZWQsIG5ld01pbikpOwogICAgICAgIH0KICAgICAgICB0aGlzLnhBeGlzX21pbiA9IG5ld01pbjsKICAgICAgICB0aGlzLnhBeGlzX21heCA9IG5ld01pbiArIHdpbmRvd1dpZHRoOwogICAgICAgIHRoaXMuc2NoZWR1bGVSZW5kZXIodGhpcy54QXhpc19taW4sIHRoaXMueEF4aXNfbWF4KTsKICAgICAgfQogICAgfSwKICAgIGdldENsaWVudFgoZSkgewogICAgICBpZiAoZSAmJiBlLnRvdWNoZXMgJiYgZS50b3VjaGVzLmxlbmd0aCkgcmV0dXJuIGUudG91Y2hlc1swXS5jbGllbnRYOwogICAgICBpZiAoZSAmJiBlLmNoYW5nZWRUb3VjaGVzICYmIGUuY2hhbmdlZFRvdWNoZXMubGVuZ3RoKSByZXR1cm4gZS5jaGFuZ2VkVG91Y2hlc1swXS5jbGllbnRYOwogICAgICBpZiAodHlwZW9mIGUuY2xpZW50WCA9PT0gJ251bWJlcicpIHJldHVybiBlLmNsaWVudFg7CiAgICAgIHJldHVybiB1bmRlZmluZWQ7CiAgICB9LAogICAgZW5kRHJhZygpIHsKICAgICAgdGhpcy5pc0RyYWdnaW5nID0gZmFsc2U7CiAgICAgIHRoaXMuZGVsdGFYID0gMDsKICAgICAgLy8gdGhpcy4kYnVzLiRlbWl0KCdzZXRUYXJnZXRQb3NpdGlvbicsICh0aGlzLnhBeGlzX21pbiArIHRoaXMueEF4aXNfbWF4KSAvIDIpOwogICAgfSwKICAgIHNjaGVkdWxlUmVuZGVyKGxvd2VyQm91bmQsIHVwcGVyQm91bmQpIHsKICAgICAgdGhpcy5wZW5kaW5nTG93ZXJCb3VuZCA9IGxvd2VyQm91bmQ7CiAgICAgIHRoaXMucGVuZGluZ1VwcGVyQm91bmQgPSB1cHBlckJvdW5kOwogICAgICBpZiAodGhpcy5yZW5kZXJTY2hlZHVsZWQpIHJldHVybjsKICAgICAgdGhpcy5yZW5kZXJTY2hlZHVsZWQgPSB0cnVlOwogICAgICBjb25zdCBjYiA9ICgpID0+IHsKICAgICAgICB0aGlzLnJlbmRlclJhZklkID0gbnVsbDsKICAgICAgICB0aGlzLnJlbmRlclNjaGVkdWxlZCA9IGZhbHNlOwogICAgICAgIHRoaXMucmVuZGVyQ2hhcnQodGhpcy5wZW5kaW5nTG93ZXJCb3VuZCwgdGhpcy5wZW5kaW5nVXBwZXJCb3VuZCk7CiAgICAgIH07CiAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKSB7CiAgICAgICAgdGhpcy5yZW5kZXJSYWZJZCA9IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoY2IpOwogICAgICB9IGVsc2UgewogICAgICAgIC8vIOWbnumAgO+8muaXoCByQUYg5pe277yM5L2/55So5b6u5Lu75Yqh6ZmN5L2O6Zi75aGeCiAgICAgICAgUHJvbWlzZS5yZXNvbHZlKCkudGhlbihjYik7CiAgICAgIH0KICAgIH0sCiAgICByZW5kZXJDaGFydChsb3dlckJvdW5kLCB1cHBlckJvdW5kKSB7CiAgICAgIGNvbnN0IGRhdGExID0gdGhpcy5pc1RpbWVNb2RlID8gdGhpcy5jaGFydERhdGExX3RpbWUgOiB0aGlzLmNoYXJ0RGF0YTFfcG9zOwogICAgICBjb25zdCB5X21heCA9IGRhdGExLmxlbmd0aCA+IDAgPyBNYXRoLm1heCguLi5kYXRhMS5tYXAoaXRlbSA9PiBpdGVtWzFdKSkgKiAyIDogdGhpcy55QXhpc19tYXg7CiAgICAgIC8vIOe6v+aVsOaNru+8muiLpeS8oOWFpeezu+aVsO+8jOWImeagueaNruW9k+WJjeinhuWbvuiMg+WbtOWKqOaAgemHh+agt++8jOmBv+WFjeaLluWKqOWQjuaWreijguaIlua2iOWksQogICAgICBsZXQgZGVjRGF0YSA9IFtdOwogICAgICBpZiAoIXRoaXMuaXNUaW1lTW9kZSkgewogICAgICAgIGlmICh0aGlzLmxpbmVEYXRhRnJvbVBvaW50cyAmJiBBcnJheS5pc0FycmF5KHRoaXMubGluZURhdGFGcm9tUG9pbnRzKSkgewogICAgICAgICAgZGVjRGF0YSA9IHRoaXMubGluZURhdGFGcm9tUG9pbnRzOwogICAgICAgIH0gZWxzZSBpZiAodGhpcy5xdWFkcmF0aWNQYXJhbXMpIHsKICAgICAgICAgIGNvbnN0IHsgYSwgYiwgYywgeDAgfSA9IHRoaXMucXVhZHJhdGljUGFyYW1zOwogICAgICAgICAgaWYgKGlzRmluaXRlKGEpICYmIGlzRmluaXRlKGIpICYmIGlzRmluaXRlKGMpKSB7CiAgICAgICAgICAgIGRlY0RhdGEgPSB0aGlzLmdlbmVyYXRlUXVhZHJhdGljRGF0YShhLCBiLCBjLCBsb3dlckJvdW5kLCB1cHBlckJvdW5kLCBpc0Zpbml0ZSh4MCkgPyB4MCA6IDApOwogICAgICAgICAgfQogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICBkZWNEYXRhID0gdGhpcy5jaGFydERhdGEyOyAvLyDlhbzlrrnml6fpgLvovpEKICAgICAgICB9CiAgICAgIH0KICAgICAgCiAgICAgIC8vIOiwg+ivleaXpeW/lwogICAgICBpZiAodGhpcy5kZWJ1Z1JlbmRlckxvZ3MgJiYgdGhpcy5pc1RpbWVNb2RlICYmIGRhdGExLmxlbmd0aCA+IDApIHsKICAgICAgICBjb25zb2xlLmxvZygnQ2hhcnQtRm9jdXM6IHJlbmRlckNoYXJ0ICh0aW1lIG1vZGUpJywgewogICAgICAgICAgZGF0YVBvaW50czogZGF0YTEubGVuZ3RoLAogICAgICAgICAgbGF0ZXN0UG9pbnQ6IGRhdGExW2RhdGExLmxlbmd0aCAtIDFdLAogICAgICAgICAgeV9tYXg6IHlfbWF4CiAgICAgICAgfSk7CiAgICAgIH0KICAgICAgY29uc3Qgb3B0aW9uWEF4aXMgPSB0aGlzLmlzVGltZU1vZGUKICAgICAgICA/IHsKICAgICAgICAgICAgdHlwZTogJ3RpbWUnLAogICAgICAgICAgICBtaW46IERhdGUubm93KCkgLSB0aGlzLnRpbWVXaW5kb3dTZWMgKiAxMDAwLAogICAgICAgICAgICBtYXg6IERhdGUubm93KCksCiAgICAgICAgICAgIGF4aXNMYWJlbDogewogICAgICAgICAgICAgIGNvbG9yOiAnd2hpdGUnLAogICAgICAgICAgICAgIGZvbnRTaXplOiA1LAogICAgICAgICAgICAgIGZvcm1hdHRlcjogZnVuY3Rpb24gKHZhbHVlKSB7CiAgICAgICAgICAgICAgICBjb25zdCBkID0gbmV3IERhdGUodmFsdWUpOwogICAgICAgICAgICAgICAgY29uc3QgcGFkID0gKG4pID0+IChuIDwgMTAgPyAnMCcgKyBuIDogJycgKyBuKTsKICAgICAgICAgICAgICAgIHJldHVybiBwYWQoZC5nZXRIb3VycygpKSArICc6JyArIHBhZChkLmdldE1pbnV0ZXMoKSkgKyAnOicgKyBwYWQoZC5nZXRTZWNvbmRzKCkpOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgfSwKICAgICAgICAgICAgYXhpc0xpbmU6IHsgbGluZVN0eWxlOiB7IGNvbG9yOiAncmdiYSgyMDAsIDIwMCwgMjAwLCAwLjUpJyB9IH0sCiAgICAgICAgICAgIHNwbGl0TGluZTogewogICAgICAgICAgICAgIHNob3c6IHRydWUsCiAgICAgICAgICAgICAgbGluZVN0eWxlOiB7IGNvbG9yOiAncmdiYSgxMjgsIDEyOCwgMTI4LCAwLjUpJywgd2lkdGg6IDEsIHR5cGU6ICdzb2xpZCcgfQogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgOiB7CiAgICAgICAgICAgIHR5cGU6ICd2YWx1ZScsCiAgICAgICAgICAgIG1pbjogbG93ZXJCb3VuZCwKICAgICAgICAgICAgbWF4OiB1cHBlckJvdW5kLAogICAgICAgICAgICBheGlzTGluZTogeyBsaW5lU3R5bGU6IHsgY29sb3I6ICdyZ2JhKDIwMCwgMjAwLCAyMDAsIDAuNSknIH0gfSwKICAgICAgICAgICAgYXhpc0xhYmVsOiB7IGNvbG9yOiAnd2hpdGUnLCBmb250U2l6ZTogNSB9LAogICAgICAgICAgICBzcGxpdExpbmU6IHsgc2hvdzogdHJ1ZSwgbGluZVN0eWxlOiB7IGNvbG9yOiAncmdiYSgxMjgsIDEyOCwgMTI4LCAwLjUpJywgd2lkdGg6IDEsIHR5cGU6ICdzb2xpZCcgfSB9CiAgICAgICAgICB9OwogICAgICBjb25zdCBvcHRpb24gPSB7CiAgICAgICAgZ3JpZDogewogICAgICAgICAgbGVmdDogJzAlJywKICAgICAgICAgIHJpZ2h0OiAnMiUnLAogICAgICAgICAgYm90dG9tOiAnMCUnLAogICAgICAgICAgdG9wOiAnMTAlJywKICAgICAgICAgIGNvbnRhaW5MYWJlbDogdHJ1ZQogICAgICAgIH0sCiAgICAgICAgeEF4aXM6IG9wdGlvblhBeGlzLAogICAgICAgIHlBeGlzOiB7CiAgICAgICAgICBtaW46IHRoaXMueUF4aXNfbWluLAogICAgICAgICAgbWF4OiB5X21heCwKICAgICAgICAgIGF4aXNMaW5lOiB7CiAgICAgICAgICAgIGxpbmVTdHlsZTogewogICAgICAgICAgICAgIGNvbG9yOiAncmdiYSgyMDAsIDIwMCwgMjAwLCAwLjUpJyAgLy8geei9tOe6v+minOiJsgogICAgICAgICAgICB9CiAgICAgICAgICB9LAogICAgICAgICAgYXhpc0xhYmVsOiB7CiAgICAgICAgICAgIGNvbG9yOiAnd2hpdGUnLAogICAgICAgICAgICBmb250U2l6ZTogNQogICAgICAgICAgfSwKICAgICAgICAgIHNwbGl0TnVtYmVyOiAzLAogICAgICAgICAgc3BsaXRMaW5lOiB7CiAgICAgICAgICAgIHNob3c6IHRydWUsCiAgICAgICAgICAgIGxpbmVTdHlsZTogewogICAgICAgICAgICAgIGNvbG9yOiAncmdiYSgxMjgsIDEyOCwgMTI4LCAwLjUpJywKICAgICAgICAgICAgICB3aWR0aDogMSwKICAgICAgICAgICAgICB0eXBlOiAnc29saWQnCiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICB9LAogICAgICAgIHNlcmllczogWwogICAgICAgICAgewogICAgICAgICAgICBuYW1lOiAnRldITScsCiAgICAgICAgICAgIHR5cGU6ICdzY2F0dGVyJywKICAgICAgICAgICAgZGF0YTogZGF0YTEsCiAgICAgICAgICAgIGl0ZW1TdHlsZTogewogICAgICAgICAgICAgIGNvbG9yOiAncmVkJwogICAgICAgICAgICB9LAogICAgICAgICAgICBzeW1ib2xTaXplOiA0CiAgICAgICAgICB9LAogICAgICAgICAgIXRoaXMuaXNUaW1lTW9kZSA/IHsKICAgICAgICAgICAgbmFtZTogJ0RlYycsCiAgICAgICAgICAgIHR5cGU6ICdsaW5lJywKICAgICAgICAgICAgZGF0YTogZGVjRGF0YSwKICAgICAgICAgICAgaXRlbVN0eWxlOiB7CiAgICAgICAgICAgICAgY29sb3I6ICdncmVlbicKICAgICAgICAgICAgfSwKICAgICAgICAgICAgbGluZVN0eWxlOiB7CiAgICAgICAgICAgICAgd2lkdGg6IDEKICAgICAgICAgICAgfSwKICAgICAgICAgICAgc3ltYm9sU2l6ZTogMAogICAgICAgICAgfSA6IG51bGwsCiAgICAgICAgICAhdGhpcy5pc1RpbWVNb2RlID8gewogICAgICAgICAgICBuYW1lOiAnbWluUG9pbnQnLAogICAgICAgICAgICB0eXBlOiAnc2NhdHRlcicsCiAgICAgICAgICAgIGRhdGE6IHRoaXMuY2hhcnREYXRhMywKICAgICAgICAgICAgaXRlbVN0eWxlOiB7CiAgICAgICAgICAgICAgY29sb3I6ICdyZ2JhKDc1LCAxNTUsIDI1MCwgMC43KScKICAgICAgICAgICAgfSwKICAgICAgICAgICAgc3ltYm9sU2l6ZTogNAogICAgICAgICAgfSA6IG51bGwsCiAgICAgICAgICAhdGhpcy5pc1RpbWVNb2RlID8gewogICAgICAgICAgICBuYW1lOiAneE1pbkxpbmUnLAogICAgICAgICAgICB0eXBlOiAnbGluZScsCiAgICAgICAgICAgIGRhdGE6IFsKICAgICAgICAgICAgICBbdGhpcy54X21pbiwgdGhpcy55QXhpc19taW5dLAogICAgICAgICAgICAgIFt0aGlzLnhfbWluLCB5X21heF0KICAgICAgICAgICAgXSwKICAgICAgICAgICAgbGluZVN0eWxlOiB7CiAgICAgICAgICAgICAgY29sb3I6ICdyZWQnLAogICAgICAgICAgICAgIHdpZHRoOiAxCiAgICAgICAgICAgIH0sCiAgICAgICAgICAgIHN5bWJvbDogJ25vbmUnCiAgICAgICAgICB9IDogbnVsbCwKICAgICAgICAgICF0aGlzLmlzVGltZU1vZGUgPyB7CiAgICAgICAgICAgIG5hbWU6ICd4TWF4TGluZScsCiAgICAgICAgICAgIHR5cGU6ICdsaW5lJywKICAgICAgICAgICAgZGF0YTogWwogICAgICAgICAgICAgIFt0aGlzLnhfbWF4LCB0aGlzLnlBeGlzX21pbl0sCiAgICAgICAgICAgICAgW3RoaXMueF9tYXgsIHlfbWF4XQogICAgICAgICAgICBdLAogICAgICAgICAgICBsaW5lU3R5bGU6IHsKICAgICAgICAgICAgICBjb2xvcjogJ3JlZCcsCiAgICAgICAgICAgICAgd2lkdGg6IDEKICAgICAgICAgICAgfSwKICAgICAgICAgICAgc3ltYm9sOiAnbm9uZScKICAgICAgICAgIH0gOiBudWxsLAogICAgICAgICAgIXRoaXMuaXNUaW1lTW9kZSA/IHsKICAgICAgICAgICAgbmFtZTogJ2N1cnJlbnRQb3NpdGlvbicsCiAgICAgICAgICAgIHR5cGU6ICdsaW5lJywKICAgICAgICAgICAgZGF0YTogWwogICAgICAgICAgICAgIFt0aGlzLmN1cnJlbnRYLCB0aGlzLnlBeGlzX21pbl0sCiAgICAgICAgICAgICAgW3RoaXMuY3VycmVudFgsIHlfbWF4XQogICAgICAgICAgICBdLAogICAgICAgICAgICBsaW5lU3R5bGU6IHsKICAgICAgICAgICAgICBjb2xvcjogJ2dyZWVuJywKICAgICAgICAgICAgICB3aWR0aDogMQogICAgICAgICAgICB9LAogICAgICAgICAgICBzeW1ib2w6ICdub25lJwogICAgICAgICAgfSA6IG51bGwKICAgICAgICBdCiAgICAgIH07CiAgICAgIC8vIOi/h+a7pOaOieS4uiBudWxsIOeahCBzZXJpZXMg6aG5CiAgICAgIG9wdGlvbi5zZXJpZXMgPSBvcHRpb24uc2VyaWVzLmZpbHRlcihCb29sZWFuKTsKICAgICAgLy8g5L2/55SoIGxhenlVcGRhdGUg6ZmN5L2O5ZCM5q2l5byA6ZSACiAgICAgIHRoaXMubXlDaGFydC5zZXRPcHRpb24ob3B0aW9uLCBmYWxzZSwgdHJ1ZSk7CiAgICB9LAogICAgLy8g6L+95Yqg5LiA5Liq5LulIuW9k+WJjeaXtumXtCLkuLogeCDnmoQgRldITSDngrnvvIjml7bpl7TovbTmqKHlvI/vvIkKICAgIGFkZEZ3aG1Qb2ludE5vdyhmd2htKSB7CiAgICAgIC8vIOehruS/nSBmd2htIOaYr+aVsOWtlwogICAgICBjb25zdCBmd2htTnVtID0gdHlwZW9mIGZ3aG0gPT09ICdudW1iZXInID8gZndobSA6IHBhcnNlRmxvYXQoZndobSk7CiAgICAgIGlmIChpc05hTihmd2htTnVtKSB8fCBmd2htTnVtIDw9IDApIHsKICAgICAgICBjb25zb2xlLndhcm4oJ0NoYXJ0LUZvY3VzOiBJbnZhbGlkIEZXSE0gdmFsdWU6JywgZndobSk7CiAgICAgICAgcmV0dXJuOwogICAgICB9CiAgICAgIAogICAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpOwogICAgICBjb25zdCBwb2ludCA9IFtub3csIGZ3aG1OdW1dOwogICAgICB0aGlzLmNoYXJ0RGF0YTFfdGltZS5wdXNoKHBvaW50KTsKICAgICAgCiAgICAgIGNvbnNvbGUubG9nKCdDaGFydC1Gb2N1czogYWRkRndobVBvaW50Tm93JywgewogICAgICAgIGZ3aG06IGZ3aG1OdW0sCiAgICAgICAgdGltZTogbmV3IERhdGUobm93KS50b0xvY2FsZVRpbWVTdHJpbmcoKSwKICAgICAgICBpc1RpbWVNb2RlOiB0aGlzLmlzVGltZU1vZGUsCiAgICAgICAgZGF0YUxlbmd0aDogdGhpcy5jaGFydERhdGExX3RpbWUubGVuZ3RoLAogICAgICAgIGNoYXJ0SW5pdGlhbGl6ZWQ6ICEhdGhpcy5teUNoYXJ0CiAgICAgIH0pOwogICAgICAKICAgICAgLy8g5LuF5L+d55WZ56qX5Y+j5pyf5YaF55qE5pWw5o2uCiAgICAgIGNvbnN0IG1pblRzID0gbm93IC0gdGhpcy50aW1lV2luZG93U2VjICogMTAwMDsKICAgICAgdGhpcy5jaGFydERhdGExX3RpbWUgPSB0aGlzLmNoYXJ0RGF0YTFfdGltZS5maWx0ZXIocCA9PiBwWzBdID49IG1pblRzKTsKICAgICAgCiAgICAgIC8vIOW8uuWItumHjeaWsOa4suafkwogICAgICBpZiAodGhpcy5teUNoYXJ0KSB7CiAgICAgICAgdGhpcy5zY2hlZHVsZVJlbmRlcih0aGlzLnhBeGlzX21pbiwgdGhpcy54QXhpc19tYXgpOwogICAgICB9IGVsc2UgewogICAgICAgIGNvbnNvbGUud2FybignQ2hhcnQtRm9jdXM6IG15Q2hhcnQgbm90IGluaXRpYWxpemVkIHlldCcpOwogICAgICB9CiAgICB9LAogICAgLy8g5byA5ZCvL+WFs+mXreaXtumXtOi9tOaooeW8jwogICAgc2V0VGltZU1vZGUoZmxhZykgewogICAgICBjb25zdCBlbmFibGUgPSAhIWZsYWc7CiAgICAgIGlmIChlbmFibGUgPT09IHRoaXMuaXNUaW1lTW9kZSkgcmV0dXJuOwogICAgICB0aGlzLmlzVGltZU1vZGUgPSBlbmFibGU7CiAgICAgIHRoaXMudXBkYXRlVGlja2VyQnlWaXNpYmlsaXR5KCk7CiAgICAgIGlmICh0aGlzLm15Q2hhcnQpIHsgdGhpcy5teUNoYXJ0LmNsZWFyKCk7IH0KICAgICAgdGhpcy5zY2hlZHVsZVJlbmRlcih0aGlzLnhBeGlzX21pbiwgdGhpcy54QXhpc19tYXgpOwogICAgfSwKICAgIHN0b3BUaW1lVGlja2VyKCkgewogICAgICBpZiAodGhpcy50aW1lVGlja2VyKSB7CiAgICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLnRpbWVUaWNrZXIpOwogICAgICAgIHRoaXMudGltZVRpY2tlciA9IG51bGw7CiAgICAgIH0KICAgIH0sCiAgICBzdGFydFRpbWVUaWNrZXIoKSB7CiAgICAgIGlmICh0aGlzLnRpbWVUaWNrZXIpIHJldHVybjsKICAgICAgdGhpcy50aW1lVGlja2VyID0gc2V0SW50ZXJ2YWwoKCkgPT4gewogICAgICAgIC8vIOayoeacieaWsOeCueaXtuS5n+aOqOWKqOaXtumXtOi9tOWJjei/mwogICAgICAgIGlmICh0aGlzLm15Q2hhcnQpIHsKICAgICAgICAgIHRoaXMuc2NoZWR1bGVSZW5kZXIodGhpcy54QXhpc19taW4sIHRoaXMueEF4aXNfbWF4KTsKICAgICAgICB9CiAgICAgIH0sIDEwMDApOwogICAgfSwKICAgIHVwZGF0ZVRpY2tlckJ5VmlzaWJpbGl0eSgpIHsKICAgICAgY29uc3QgZG9jVmlzaWJsZSA9IHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgPyAhZG9jdW1lbnQuaGlkZGVuIDogdHJ1ZTsKICAgICAgY29uc3Qgc2hvdWxkUnVuID0gdGhpcy5pc1RpbWVNb2RlICYmIHRoaXMuaXNWaXNpYmxlICYmIGRvY1Zpc2libGU7CiAgICAgIGlmIChzaG91bGRSdW4pIHRoaXMuc3RhcnRUaW1lVGlja2VyKCk7IGVsc2UgdGhpcy5zdG9wVGltZVRpY2tlcigpOwogICAgfSwKICAgIGFkZERhdGFfUG9pbnQoeCx5KSB7CiAgICAgIGNvbnN0IG5ld0RhdGFQb2ludCA9IFt4LCB5XTsKICAgICAgY29uc3QgZXhpc3RpbmdQb2ludEluZGV4ID0gdGhpcy5jaGFydERhdGExX3Bvcy5maW5kSW5kZXgocG9pbnQgPT4gcG9pbnRbMF0gPT09IG5ld0RhdGFQb2ludFswXSk7CiAgICAgIGlmIChleGlzdGluZ1BvaW50SW5kZXggIT09IC0xKSB7CiAgICAgICAgLy8gSWYgdGhlIHggdmFsdWUgYWxyZWFkeSBleGlzdHMsIHVwZGF0ZSB0aGUgeSB2YWx1ZQogICAgICAgIGlmIChuZXdEYXRhUG9pbnRbMV0gPT0gMCB8fCBuZXdEYXRhUG9pbnRbMV0gPT0gdGhpcy5jaGFydERhdGExX3Bvc1tleGlzdGluZ1BvaW50SW5kZXhdWzFdKSByZXR1cm47CiAgICAgICAgdGhpcy5jaGFydERhdGExX3Bvc1tleGlzdGluZ1BvaW50SW5kZXhdID0gbmV3RGF0YVBvaW50OwogICAgICB9IGVsc2UgewogICAgICAgIC8vIElmIHRoZSB4IHZhbHVlIGRvZXMgbm90IGV4aXN0LCBhZGQgdGhlIG5ldyBkYXRhIHBvaW50CiAgICAgICAgdGhpcy5jaGFydERhdGExX3Bvcy5wdXNoKG5ld0RhdGFQb2ludCk7CiAgICAgIH0KICAgICAgdGhpcy5zY2hlZHVsZVJlbmRlcih0aGlzLnhBeGlzX21pbiwgdGhpcy54QXhpc19tYXgpOwogICAgfSwKICAgIC8vIOe7mOWItuaKmOe6vy/kuozmrKHmm7Lnur8KICAgIGFkZExpbmVEYXRhX1BvaW50KGRhdGFPckEsIGIsIGMpIHsKICAgICAgLy8g5YW85a6577ya5aaC5p6c5Lyg5YWl55qE5piv54K55pWw57uE77yM55u05o6l5L2/55SoCiAgICAgIGlmIChBcnJheS5pc0FycmF5KGRhdGFPckEpKSB7CiAgICAgICAgdGhpcy5saW5lRGF0YUZyb21Qb2ludHMgPSBkYXRhT3JBOwogICAgICAgIHRoaXMucXVhZHJhdGljUGFyYW1zID0gbnVsbDsKICAgICAgICB0aGlzLnNjaGVkdWxlUmVuZGVyKHRoaXMueEF4aXNfbWluLCB0aGlzLnhBeGlzX21heCk7CiAgICAgICAgcmV0dXJuOwogICAgICB9CgogICAgICAvLyDoi6XkvKDlhaXnmoTmmK/ns7vmlbDlr7nosaEgeyBhLCBiLCBjIH0KICAgICAgaWYgKGRhdGFPckEgJiYgdHlwZW9mIGRhdGFPckEgPT09ICdvYmplY3QnICYmCiAgICAgICAgICAodHlwZW9mIGRhdGFPckEuYSA9PT0gJ251bWJlcicgfHwgdHlwZW9mIGRhdGFPckEuYSA9PT0gJ3N0cmluZycpICYmCiAgICAgICAgICAodHlwZW9mIGRhdGFPckEuYiA9PT0gJ251bWJlcicgfHwgdHlwZW9mIGRhdGFPckEuYiA9PT0gJ3N0cmluZycpICYmCiAgICAgICAgICAodHlwZW9mIGRhdGFPckEuYyA9PT0gJ251bWJlcicgfHwgdHlwZW9mIGRhdGFPckEuYyA9PT0gJ3N0cmluZycpKSB7CiAgICAgICAgY29uc3QgYU51bSA9IHR5cGVvZiBkYXRhT3JBLmEgPT09ICdudW1iZXInID8gZGF0YU9yQS5hIDogcGFyc2VGbG9hdChkYXRhT3JBLmEpOwogICAgICAgIGNvbnN0IGJOdW0gPSB0eXBlb2YgZGF0YU9yQS5iID09PSAnbnVtYmVyJyA/IGRhdGFPckEuYiA6IHBhcnNlRmxvYXQoZGF0YU9yQS5iKTsKICAgICAgICBjb25zdCBjTnVtID0gdHlwZW9mIGRhdGFPckEuYyA9PT0gJ251bWJlcicgPyBkYXRhT3JBLmMgOiBwYXJzZUZsb2F0KGRhdGFPckEuYyk7CiAgICAgICAgaWYgKCFpc0Zpbml0ZShhTnVtKSB8fCAhaXNGaW5pdGUoYk51bSkgfHwgIWlzRmluaXRlKGNOdW0pKSB7CiAgICAgICAgICB0aGlzLnNjaGVkdWxlUmVuZGVyKHRoaXMueEF4aXNfbWluLCB0aGlzLnhBeGlzX21heCk7CiAgICAgICAgICByZXR1cm47CiAgICAgICAgfQogICAgICAgIGNvbnN0IGNlbnRlclggPSB0eXBlb2YgZGF0YU9yQS54MCA9PT0gJ251bWJlcicgPyBkYXRhT3JBLngwIDogKHR5cGVvZiBkYXRhT3JBLngwID09PSAnc3RyaW5nJyA/IHBhcnNlRmxvYXQoZGF0YU9yQS54MCkgOiAwKTsKICAgICAgICB0aGlzLnF1YWRyYXRpY1BhcmFtcyA9IHsgYTogYU51bSwgYjogYk51bSwgYzogY051bSwgeDA6IGlzRmluaXRlKGNlbnRlclgpID8gY2VudGVyWCA6IDAgfTsKICAgICAgICB0aGlzLmxpbmVEYXRhRnJvbVBvaW50cyA9IG51bGw7CiAgICAgICAgdGhpcy5zY2hlZHVsZVJlbmRlcih0aGlzLnhBeGlzX21pbiwgdGhpcy54QXhpc19tYXgpOwogICAgICAgIHJldHVybjsKICAgICAgfQoKICAgICAgLy8g5oiW6ICF5Lul5LiJ5Liq54us56uL5Y+C5pWw5b2i5byP5Lyg5YWlIGEsIGIsIGMKICAgICAgaWYgKCh0eXBlb2YgZGF0YU9yQSA9PT0gJ251bWJlcicgfHwgdHlwZW9mIGRhdGFPckEgPT09ICdzdHJpbmcnKSAmJgogICAgICAgICAgKHR5cGVvZiBiID09PSAnbnVtYmVyJyB8fCB0eXBlb2YgYiA9PT0gJ3N0cmluZycpICYmCiAgICAgICAgICAodHlwZW9mIGMgPT09ICdudW1iZXInIHx8IHR5cGVvZiBjID09PSAnc3RyaW5nJykpIHsKICAgICAgICBjb25zdCBhTnVtID0gdHlwZW9mIGRhdGFPckEgPT09ICdudW1iZXInID8gZGF0YU9yQSA6IHBhcnNlRmxvYXQoZGF0YU9yQSk7CiAgICAgICAgY29uc3QgYk51bSA9IHR5cGVvZiBiID09PSAnbnVtYmVyJyA/IGIgOiBwYXJzZUZsb2F0KGIpOwogICAgICAgIGNvbnN0IGNOdW0gPSB0eXBlb2YgYyA9PT0gJ251bWJlcicgPyBjIDogcGFyc2VGbG9hdChjKTsKICAgICAgICBpZiAoIWlzRmluaXRlKGFOdW0pIHx8ICFpc0Zpbml0ZShiTnVtKSB8fCAhaXNGaW5pdGUoY051bSkpIHsKICAgICAgICAgIHRoaXMuc2NoZWR1bGVSZW5kZXIodGhpcy54QXhpc19taW4sIHRoaXMueEF4aXNfbWF4KTsKICAgICAgICAgIHJldHVybjsKICAgICAgICB9CiAgICAgICAgdGhpcy5xdWFkcmF0aWNQYXJhbXMgPSB7IGE6IGFOdW0sIGI6IGJOdW0sIGM6IGNOdW0gfTsKICAgICAgICB0aGlzLmxpbmVEYXRhRnJvbVBvaW50cyA9IG51bGw7CiAgICAgICAgdGhpcy5zY2hlZHVsZVJlbmRlcih0aGlzLnhBeGlzX21pbiwgdGhpcy54QXhpc19tYXgpOwogICAgICAgIHJldHVybjsKICAgICAgfQoKICAgICAgLy8g5YW25LuW6Z2e5rOV6L6T5YWl77ya5LiN5aSE55CG77yM5LuF5Yi35paw546w54q2CiAgICAgIHRoaXMuc2NoZWR1bGVSZW5kZXIodGhpcy54QXhpc19taW4sIHRoaXMueEF4aXNfbWF4KTsKICAgIH0sCiAgICAvLyDnlJ/miJDkuIDlhYPkuozmrKHmm7Lnur/ph4fmoLfngrkKICAgIGdlbmVyYXRlUXVhZHJhdGljRGF0YShhLCBiLCBjLCB4TWluLCB4TWF4LCBjZW50ZXJYID0gMCkgewogICAgICBjb25zdCBzdGFydCA9IE51bWJlci5pc0Zpbml0ZSh4TWluKSA/IHhNaW4gOiAwOwogICAgICBjb25zdCBlbmQgPSBOdW1iZXIuaXNGaW5pdGUoeE1heCkgPyB4TWF4IDogMTAwOwogICAgICBjb25zdCBzcGFuID0gZW5kIC0gc3RhcnQ7CiAgICAgIGNvbnN0IHNhbXBsZXMgPSBNYXRoLm1heCgyLCBNYXRoLm1pbig0MDAsIE1hdGguY2VpbChzcGFuIC8gNTApKSk7IC8vIOagueaNruiMg+WbtOiHqumAguW6lOmHh+agt+WvhuW6pgogICAgICBjb25zdCBzdGVwID0gc3BhbiAvIHNhbXBsZXMgfHwgMTsKICAgICAgY29uc3QgZGF0YSA9IFtdOwogICAgICBmb3IgKGxldCB4ID0gc3RhcnQ7IHggPD0gZW5kOyB4ICs9IHN0ZXApIHsKICAgICAgICBjb25zdCB0ID0geCAtIGNlbnRlclg7CiAgICAgICAgY29uc3QgeSA9IGEgKiB0ICogdCArIGIgKiB0ICsgYzsKICAgICAgICBkYXRhLnB1c2goW3gsIHldKTsKICAgICAgfQogICAgICAvLyDnoa7kv53ljIXlkKvlsL7ngrkKICAgICAgaWYgKGRhdGEubGVuZ3RoID09PSAwIHx8IGRhdGFbZGF0YS5sZW5ndGggLSAxXVswXSA8IGVuZCkgewogICAgICAgIGNvbnN0IHRFbmQgPSBlbmQgLSBjZW50ZXJYOwogICAgICAgIGNvbnN0IHlFbmQgPSBhICogdEVuZCAqIHRFbmQgKyBiICogdEVuZCArIGM7CiAgICAgICAgZGF0YS5wdXNoKFtlbmQsIHlFbmRdKTsKICAgICAgfQogICAgICByZXR1cm4gZGF0YTsKICAgIH0sCiAgICBhZGRNaW5Qb2ludERhdGFfUG9pbnQoeCx5KSB7CiAgICAgIGNvbnN0IG5ld0RhdGFQb2ludCA9IFt4LCB5XTsKICAgICAgdGhpcy5jaGFydERhdGEzLnB1c2gobmV3RGF0YVBvaW50KTsKICAgICAgdGhpcy5zY2hlZHVsZVJlbmRlcih0aGlzLnhBeGlzX21pbiwgdGhpcy54QXhpc19tYXgpOwogICAgfSwKICAgIC8vIOabtOaUueaYvuekuueahHjovbTojIPlm7QKICAgIGNoYW5nZVJhbmdlX3goY3VycmVudCwgdGFyZ2V0KSB7CiAgICAgIHRoaXMueEF4aXNfbWluID0gTnVtYmVyKGN1cnJlbnQpIC0gMzAwMDsKICAgICAgdGhpcy54QXhpc19tYXggPSBOdW1iZXIoY3VycmVudCkgKyAzMDAwOwogICAgICB0aGlzLmN1cnJlbnRYID0gY3VycmVudDsKICAgICAgY29uc29sZS5sb2coIlFIWUNDRCB8IGNoYW5nZVJhbmdlX3g6IiwgY3VycmVudCwgdGhpcy54QXhpc19taW4sIHRoaXMueEF4aXNfbWF4KTsKICAgICAgdGhpcy5zY2hlZHVsZVJlbmRlcih0aGlzLnhBeGlzX21pbiwgdGhpcy54QXhpc19tYXgpOwogICAgfSwKCiAgICAvLyDmuIXpmaTmlbDmja4KICAgIGNsZWFyQ2hhcnREYXRhMSgpIHsKICAgICAgdGhpcy5jaGFydERhdGExX3BvcyA9IFtdOwogICAgICB0aGlzLmNoYXJ0RGF0YTFfdGltZSA9IFtdOwogICAgICB0aGlzLnNjaGVkdWxlUmVuZGVyKHRoaXMueEF4aXNfbWluLCB0aGlzLnhBeGlzX21heCk7CiAgICB9LAogICAgY2xlYXJDaGFydERhdGEyKCkgewogICAgICB0aGlzLmNoYXJ0RGF0YTIgPSBbXTsKICAgICAgdGhpcy5zY2hlZHVsZVJlbmRlcih0aGlzLnhBeGlzX21pbiwgdGhpcy54QXhpc19tYXgpOwogICAgfSwKICAgIENsZWFyQWxsRGF0YSgpIHsKICAgICAgdGhpcy5jaGFydERhdGExX3BvcyA9IFtdOwogICAgICB0aGlzLmNoYXJ0RGF0YTFfdGltZSA9IFtdOwogICAgICB0aGlzLmNoYXJ0RGF0YTIgPSBbXTsKICAgICAgdGhpcy5jaGFydERhdGEzID0gW107CiAgICAgIHRoaXMueUF4aXNfbWF4ID0gMzA7CiAgICAgIHRoaXMuRldITU1heCA9IDE1OwogICAgICB0aGlzLnJlbmRlckNoYXJ0KHRoaXMueEF4aXNfbWluLCB0aGlzLnhBeGlzX21heCk7CiAgICB9LAogICAgLy8g5YiH5o2i5pi+56S66IyD5Zu0CiAgICBSYW5nZVN3aXRjaCgpIHsKICAgICAgaWYgKHRoaXMucmFuZ2UgPT09IDQpIHsKICAgICAgICB0aGlzLnJhbmdlID0gMjsKICAgICAgICB0aGlzLnlBeGlzX21pbiA9IC0yOwogICAgICAgIHRoaXMueUF4aXNfbWF4ID0gMjsKICAgICAgfSBlbHNlIGlmICh0aGlzLnJhbmdlID09PSAyKSB7CiAgICAgICAgdGhpcy5yYW5nZSA9IDE7CiAgICAgICAgdGhpcy55QXhpc19taW4gPSAtMTsKICAgICAgICB0aGlzLnlBeGlzX21heCA9IDE7CiAgICAgIH0gZWxzZSBpZiAodGhpcy5yYW5nZSA9PT0gMSkgewogICAgICAgIHRoaXMucmFuZ2UgPSA0OwogICAgICAgIHRoaXMueUF4aXNfbWluID0gLTQ7CiAgICAgICAgdGhpcy55QXhpc19tYXggPSA0OwogICAgICB9CiAgICAgIHRoaXMucmVuZGVyQ2hhcnQodGhpcy54QXhpc19taW4sIHRoaXMueEF4aXNfbWF4KTsKICAgIH0sCiAgICAvLyDmm7TmlrBGV0hNCiAgICAvLyBVcGRhdGVGV0hNKEZXSE0pIHsKICAgIC8vICAgY29uc3QgbmV3RGF0YVBvaW50ID0gW3RoaXMuY3VycmVudFgsIEZXSE1dOwogICAgLy8gICB0aGlzLmFkZERhdGFfUG9pbnQobmV3RGF0YVBvaW50KTsKICAgIC8vICAgLy8gY29uc29sZS5sb2coIlFIWUNDRCB8IFVwZGF0ZUZXSE06IiwgbmV3RGF0YVBvaW50KTsKICAgIC8vICAgLy8gdGhpcy4kYnVzLiRlbWl0KCdTZW5kQ29uc29sZUxvZ01zZycsICdVcGRhdGVGV0hNOicgKyBuZXdEYXRhUG9pbnQsICdpbmZvJyk7CiAgICAvLyAgIHRoaXMucmVuZGVyQ2hhcnQodGhpcy54QXhpc19taW4sIHRoaXMueEF4aXNfbWF4KTsKICAgIC8vIH0sCiAgICAvLyDmi5/lkIjkuozmrKHmm7Lnur8KICAgIC8vIGZpdFF1YWRyYXRpY0N1cnZlKHgsIHkpIHsKICAgIC8vICAgY29uc3QgbmV3RGF0YVBvaW50ID0gW3gsIHldOwogICAgLy8gICB0aGlzLmFkZERhdGFfTGluZShuZXdEYXRhUG9pbnQpOwogICAgLy8gfSwKICAgIC8vIOaLn+WQiOS6jOasoeabsue6v+acgOWwj+eCuQogICAgLy8gZml0UXVhZHJhdGljQ3VydmVfbWluUG9pbnQoeCwgeSkgewogICAgLy8gICBjb25zb2xlLmxvZygiUUhZQ0NEIHwgbWluUG9pbnQ6IiwgeCwgJywnLCB5KTsKICAgIC8vICAgdGhpcy4kYnVzLiRlbWl0KCdTZW5kQ29uc29sZUxvZ01zZycsICdtaW5Qb2ludDonICsgeCArICcsJyArIHksICdpbmZvJyk7CiAgICAvLyAgIHRoaXMuY2hhcnREYXRhMyA9IFtdOwogICAgLy8gICBjb25zdCBuZXdEYXRhUG9pbnQgPSBbeCwgeV07CiAgICAvLyAgIHRoaXMuY2hhcnREYXRhMy5wdXNoKG5ld0RhdGFQb2ludCk7CiAgICAvLyB9LAogICAgc2V0Rm9jdXNDaGFydFJhbmdlKGxvd2VyQm91bmQsIHVwcGVyQm91bmQpIHsKICAgICAgdGhpcy54X21pbiA9IGxvd2VyQm91bmQ7CiAgICAgIHRoaXMueF9tYXggPSB1cHBlckJvdW5kOwogICAgfQogIH0KfQo="},{"version":3,"sources":["Chart-Focus.vue"],"names":[],"mappings":";;;;;;;;;;;;;;;;;AAiBA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"Chart-Focus.vue","sourceRoot":"src/components","sourcesContent":["<template>\n  <div>\n    <div\n      ref=\"linechart\"\n      :style=\"{ width: containerMaxWidth + 'px', height: 80 + 'px' }\"\n      class=\"linechart-panel\"\n      @mousedown=\"startDrag\"\n      @mousemove=\"dragging\"\n      @mouseup=\"endDrag\"\n      @touchstart=\"startDrag\"\n      @touchmove=\"dragging\"\n      @touchend=\"endDrag\"\n    ></div>\n  </div>\n</template>\n\n<script>\nimport * as echarts from 'echarts';\n\nexport default {\n  name: 'LineChart',\n  props: {\n    // 是否使用时间轴模式（也可通过总线 setFocusChartTimeMode 切换）\n    useTimeAxis: {\n      type: Boolean,\n      default: false\n    },\n    // 时间窗口长度（秒），仅在时间轴模式下生效\n    timeWindowSec: {\n      type: Number,\n      default: 60\n    }\n  },\n  data() {\n    return {\n      containerMaxWidth: 150,\n      // 非时间轴：散点数据（x 为电调位置）\n      chartData1_pos: [],\n      // 时间轴：散点数据（x 为时间戳）\n      chartData1_time: [],\n      chartData2: [],\n      chartData3: [],\n      xAxis_min: 0,\n      xAxis_max: 6000,\n      yAxis_min: 0,\n      yAxis_max: 30,\n      range: 4,\n      currentX: 0,\n      FWHMMax: 0,\n      isDragging: false,\n      startX: 0,\n      deltaX: 0,\n      x_min: -60000,\n      x_max: 60000,\n      // 时间轴模式\n      isTimeMode: false,\n      timeTicker: null,\n      // 可见性控制\n      isVisible: false,\n      ioObserver: null,\n      // 渲染调度\n      renderRafId: null,\n      renderScheduled: false,\n      pendingLowerBound: null,\n      pendingUpperBound: null,\n      // 调试日志开关\n      debugRenderLogs: false,\n      // 线条数据来源：若为 null 则使用 quadraticParams 动态采样\n      lineDataFromPoints: null,\n      quadraticParams: null // { a,b,c,x0? }\n    };\n  },\n  mounted() {\n    // 根据可见性启动/停止时间推进\n    const el = this.$refs.linechart;\n    if (window && 'IntersectionObserver' in window && el) {\n      this.ioObserver = new IntersectionObserver((entries) => {\n        const e = entries[0];\n        this.isVisible = !!(e && e.isIntersecting);\n        this.updateTickerByVisibility();\n      }, { threshold: 0.01 });\n      this.ioObserver.observe(el);\n    } else {\n      // 回退：不可见性未知时视为可见\n      this.isVisible = true;\n    }\n    document.addEventListener('visibilitychange', this.updateTickerByVisibility);\n\n    // 初始化时间轴模式（由 prop 控制）\n    this.isTimeMode = !!this.useTimeAxis;\n    this.updateTickerByVisibility();\n  },\n  created() {\n    this.$bus.$on('FocusPosition', this.changeRange_x);\n    // this.$bus.$on('UpdateFWHM', this.UpdateFWHM);\n    // this.$bus.$on('fitQuadraticCurve', this.fitQuadraticCurve);\n    // this.$bus.$on('fitQuadraticCurve_minPoint', this.fitQuadraticCurve_minPoint);\n\n    this.$bus.$on('ClearfitQuadraticCurve', this.clearChartData2);\n    this.$bus.$on('ClearAllData', this.ClearAllData);\n    this.$bus.$on('updateFocusChartWidth', this.initChart);\n    this.$bus.$on('addData_Point', this.addData_Point);\n    this.$bus.$on('addMinPointData_Point', this.addMinPointData_Point);\n    this.$bus.$on('addLineData_Point', this.addLineData_Point);\n    this.$bus.$on('setFocusChartRange', this.setFocusChartRange);\n    // 新增：时间轴模式控制与点追加\n    this.$bus.$on('setFocusChartTimeMode', this.setTimeMode);\n    this.$bus.$on('addFwhmNow', this.addFwhmPointNow);\n\n  },\n  beforeDestroy() {\n    this.teardownBusAndTimers();\n  },\n  destroyed() {\n    this.teardownBusAndTimers();\n  },\n  methods: {\n    teardownBusAndTimers() {\n      this.$bus.$off('FocusPosition', this.changeRange_x);\n      this.$bus.$off('ClearfitQuadraticCurve', this.clearChartData2);\n      this.$bus.$off('ClearAllData', this.ClearAllData);\n      this.$bus.$off('updateFocusChartWidth', this.initChart);\n      this.$bus.$off('addData_Point', this.addData_Point);\n      this.$bus.$off('addMinPointData_Point', this.addMinPointData_Point);\n      this.$bus.$off('addLineData_Point', this.addLineData_Point);\n      this.$bus.$off('addQuadraticCurve', this.addLineData_Point);\n      this.$bus.$off('setFocusChartRange', this.setFocusChartRange);\n      this.$bus.$off('setFocusChartTimeMode', this.setTimeMode);\n      this.$bus.$off('addFwhmNow', this.addFwhmPointNow);\n      if (this.timeTicker) {\n        clearInterval(this.timeTicker);\n        this.timeTicker = null;\n      }\n      if (this.ioObserver) {\n        try { this.ioObserver.disconnect(); } catch (e) {}\n        this.ioObserver = null;\n      }\n      document.removeEventListener('visibilitychange', this.updateTickerByVisibility);\n    },\n    initChart(Width) {\n      this.containerMaxWidth = Width - 95;\n      const chartDom = this.$refs.linechart;\n      chartDom.style.width = this.containerMaxWidth + 'px';\n      this.myChart = echarts.init(chartDom);\n      this.renderChart(this.xAxis_min, this.xAxis_max);\n    },\n    startDrag(event) {\n      if (this.isTimeMode) return; // 时间轴模式下禁用拖拽\n      this.isDragging = true;\n      const x = this.getClientX(event);\n      if (typeof x === 'number') this.startX = x;\n    },\n    dragging(event) {\n      if (this.isDragging && !this.isTimeMode) {\n        const x = this.getClientX(event);\n        if (typeof x !== 'number') return;\n        this.deltaX = (x - this.startX) * 10;\n        this.startX = x;\n        const windowWidth = this.xAxis_max - this.xAxis_min;\n        // 计算新的范围并做边界裁剪\n        let newMin = this.xAxis_min - this.deltaX;\n        const minAllowed = this.x_min;\n        const maxAllowed = this.x_max - windowWidth;\n        if (maxAllowed < minAllowed) {\n          // 安全处理：若设置不合理，回退到不移动\n          newMin = this.x_min;\n        } else {\n          newMin = Math.max(minAllowed, Math.min(maxAllowed, newMin));\n        }\n        this.xAxis_min = newMin;\n        this.xAxis_max = newMin + windowWidth;\n        this.scheduleRender(this.xAxis_min, this.xAxis_max);\n      }\n    },\n    getClientX(e) {\n      if (e && e.touches && e.touches.length) return e.touches[0].clientX;\n      if (e && e.changedTouches && e.changedTouches.length) return e.changedTouches[0].clientX;\n      if (typeof e.clientX === 'number') return e.clientX;\n      return undefined;\n    },\n    endDrag() {\n      this.isDragging = false;\n      this.deltaX = 0;\n      // this.$bus.$emit('setTargetPosition', (this.xAxis_min + this.xAxis_max) / 2);\n    },\n    scheduleRender(lowerBound, upperBound) {\n      this.pendingLowerBound = lowerBound;\n      this.pendingUpperBound = upperBound;\n      if (this.renderScheduled) return;\n      this.renderScheduled = true;\n      const cb = () => {\n        this.renderRafId = null;\n        this.renderScheduled = false;\n        this.renderChart(this.pendingLowerBound, this.pendingUpperBound);\n      };\n      if (typeof window !== 'undefined' && window.requestAnimationFrame) {\n        this.renderRafId = window.requestAnimationFrame(cb);\n      } else {\n        // 回退：无 rAF 时，使用微任务降低阻塞\n        Promise.resolve().then(cb);\n      }\n    },\n    renderChart(lowerBound, upperBound) {\n      const data1 = this.isTimeMode ? this.chartData1_time : this.chartData1_pos;\n      const y_max = data1.length > 0 ? Math.max(...data1.map(item => item[1])) * 2 : this.yAxis_max;\n      // 线数据：若传入系数，则根据当前视图范围动态采样，避免拖动后断裂或消失\n      let decData = [];\n      if (!this.isTimeMode) {\n        if (this.lineDataFromPoints && Array.isArray(this.lineDataFromPoints)) {\n          decData = this.lineDataFromPoints;\n        } else if (this.quadraticParams) {\n          const { a, b, c, x0 } = this.quadraticParams;\n          if (isFinite(a) && isFinite(b) && isFinite(c)) {\n            decData = this.generateQuadraticData(a, b, c, lowerBound, upperBound, isFinite(x0) ? x0 : 0);\n          }\n        } else {\n          decData = this.chartData2; // 兼容旧逻辑\n        }\n      }\n      \n      // 调试日志\n      if (this.debugRenderLogs && this.isTimeMode && data1.length > 0) {\n        console.log('Chart-Focus: renderChart (time mode)', {\n          dataPoints: data1.length,\n          latestPoint: data1[data1.length - 1],\n          y_max: y_max\n        });\n      }\n      const optionXAxis = this.isTimeMode\n        ? {\n            type: 'time',\n            min: Date.now() - this.timeWindowSec * 1000,\n            max: Date.now(),\n            axisLabel: {\n              color: 'white',\n              fontSize: 5,\n              formatter: function (value) {\n                const d = new Date(value);\n                const pad = (n) => (n < 10 ? '0' + n : '' + n);\n                return pad(d.getHours()) + ':' + pad(d.getMinutes()) + ':' + pad(d.getSeconds());\n              }\n            },\n            axisLine: { lineStyle: { color: 'rgba(200, 200, 200, 0.5)' } },\n            splitLine: {\n              show: true,\n              lineStyle: { color: 'rgba(128, 128, 128, 0.5)', width: 1, type: 'solid' }\n            }\n          }\n        : {\n            type: 'value',\n            min: lowerBound,\n            max: upperBound,\n            axisLine: { lineStyle: { color: 'rgba(200, 200, 200, 0.5)' } },\n            axisLabel: { color: 'white', fontSize: 5 },\n            splitLine: { show: true, lineStyle: { color: 'rgba(128, 128, 128, 0.5)', width: 1, type: 'solid' } }\n          };\n      const option = {\n        grid: {\n          left: '0%',\n          right: '2%',\n          bottom: '0%',\n          top: '10%',\n          containLabel: true\n        },\n        xAxis: optionXAxis,\n        yAxis: {\n          min: this.yAxis_min,\n          max: y_max,\n          axisLine: {\n            lineStyle: {\n              color: 'rgba(200, 200, 200, 0.5)'  // y轴线颜色\n            }\n          },\n          axisLabel: {\n            color: 'white',\n            fontSize: 5\n          },\n          splitNumber: 3,\n          splitLine: {\n            show: true,\n            lineStyle: {\n              color: 'rgba(128, 128, 128, 0.5)',\n              width: 1,\n              type: 'solid'\n            }\n          }\n        },\n        series: [\n          {\n            name: 'FWHM',\n            type: 'scatter',\n            data: data1,\n            itemStyle: {\n              color: 'red'\n            },\n            symbolSize: 4\n          },\n          !this.isTimeMode ? {\n            name: 'Dec',\n            type: 'line',\n            data: decData,\n            itemStyle: {\n              color: 'green'\n            },\n            lineStyle: {\n              width: 1\n            },\n            symbolSize: 0\n          } : null,\n          !this.isTimeMode ? {\n            name: 'minPoint',\n            type: 'scatter',\n            data: this.chartData3,\n            itemStyle: {\n              color: 'rgba(75, 155, 250, 0.7)'\n            },\n            symbolSize: 4\n          } : null,\n          !this.isTimeMode ? {\n            name: 'xMinLine',\n            type: 'line',\n            data: [\n              [this.x_min, this.yAxis_min],\n              [this.x_min, y_max]\n            ],\n            lineStyle: {\n              color: 'red',\n              width: 1\n            },\n            symbol: 'none'\n          } : null,\n          !this.isTimeMode ? {\n            name: 'xMaxLine',\n            type: 'line',\n            data: [\n              [this.x_max, this.yAxis_min],\n              [this.x_max, y_max]\n            ],\n            lineStyle: {\n              color: 'red',\n              width: 1\n            },\n            symbol: 'none'\n          } : null,\n          !this.isTimeMode ? {\n            name: 'currentPosition',\n            type: 'line',\n            data: [\n              [this.currentX, this.yAxis_min],\n              [this.currentX, y_max]\n            ],\n            lineStyle: {\n              color: 'green',\n              width: 1\n            },\n            symbol: 'none'\n          } : null\n        ]\n      };\n      // 过滤掉为 null 的 series 项\n      option.series = option.series.filter(Boolean);\n      // 使用 lazyUpdate 降低同步开销\n      this.myChart.setOption(option, false, true);\n    },\n    // 追加一个以\"当前时间\"为 x 的 FWHM 点（时间轴模式）\n    addFwhmPointNow(fwhm) {\n      // 确保 fwhm 是数字\n      const fwhmNum = typeof fwhm === 'number' ? fwhm : parseFloat(fwhm);\n      if (isNaN(fwhmNum) || fwhmNum <= 0) {\n        console.warn('Chart-Focus: Invalid FWHM value:', fwhm);\n        return;\n      }\n      \n      const now = Date.now();\n      const point = [now, fwhmNum];\n      this.chartData1_time.push(point);\n      \n      console.log('Chart-Focus: addFwhmPointNow', {\n        fwhm: fwhmNum,\n        time: new Date(now).toLocaleTimeString(),\n        isTimeMode: this.isTimeMode,\n        dataLength: this.chartData1_time.length,\n        chartInitialized: !!this.myChart\n      });\n      \n      // 仅保留窗口期内的数据\n      const minTs = now - this.timeWindowSec * 1000;\n      this.chartData1_time = this.chartData1_time.filter(p => p[0] >= minTs);\n      \n      // 强制重新渲染\n      if (this.myChart) {\n        this.scheduleRender(this.xAxis_min, this.xAxis_max);\n      } else {\n        console.warn('Chart-Focus: myChart not initialized yet');\n      }\n    },\n    // 开启/关闭时间轴模式\n    setTimeMode(flag) {\n      const enable = !!flag;\n      if (enable === this.isTimeMode) return;\n      this.isTimeMode = enable;\n      this.updateTickerByVisibility();\n      if (this.myChart) { this.myChart.clear(); }\n      this.scheduleRender(this.xAxis_min, this.xAxis_max);\n    },\n    stopTimeTicker() {\n      if (this.timeTicker) {\n        clearInterval(this.timeTicker);\n        this.timeTicker = null;\n      }\n    },\n    startTimeTicker() {\n      if (this.timeTicker) return;\n      this.timeTicker = setInterval(() => {\n        // 没有新点时也推动时间轴前进\n        if (this.myChart) {\n          this.scheduleRender(this.xAxis_min, this.xAxis_max);\n        }\n      }, 1000);\n    },\n    updateTickerByVisibility() {\n      const docVisible = typeof document !== 'undefined' ? !document.hidden : true;\n      const shouldRun = this.isTimeMode && this.isVisible && docVisible;\n      if (shouldRun) this.startTimeTicker(); else this.stopTimeTicker();\n    },\n    addData_Point(x,y) {\n      const newDataPoint = [x, y];\n      const existingPointIndex = this.chartData1_pos.findIndex(point => point[0] === newDataPoint[0]);\n      if (existingPointIndex !== -1) {\n        // If the x value already exists, update the y value\n        if (newDataPoint[1] == 0 || newDataPoint[1] == this.chartData1_pos[existingPointIndex][1]) return;\n        this.chartData1_pos[existingPointIndex] = newDataPoint;\n      } else {\n        // If the x value does not exist, add the new data point\n        this.chartData1_pos.push(newDataPoint);\n      }\n      this.scheduleRender(this.xAxis_min, this.xAxis_max);\n    },\n    // 绘制折线/二次曲线\n    addLineData_Point(dataOrA, b, c) {\n      // 兼容：如果传入的是点数组，直接使用\n      if (Array.isArray(dataOrA)) {\n        this.lineDataFromPoints = dataOrA;\n        this.quadraticParams = null;\n        this.scheduleRender(this.xAxis_min, this.xAxis_max);\n        return;\n      }\n\n      // 若传入的是系数对象 { a, b, c }\n      if (dataOrA && typeof dataOrA === 'object' &&\n          (typeof dataOrA.a === 'number' || typeof dataOrA.a === 'string') &&\n          (typeof dataOrA.b === 'number' || typeof dataOrA.b === 'string') &&\n          (typeof dataOrA.c === 'number' || typeof dataOrA.c === 'string')) {\n        const aNum = typeof dataOrA.a === 'number' ? dataOrA.a : parseFloat(dataOrA.a);\n        const bNum = typeof dataOrA.b === 'number' ? dataOrA.b : parseFloat(dataOrA.b);\n        const cNum = typeof dataOrA.c === 'number' ? dataOrA.c : parseFloat(dataOrA.c);\n        if (!isFinite(aNum) || !isFinite(bNum) || !isFinite(cNum)) {\n          this.scheduleRender(this.xAxis_min, this.xAxis_max);\n          return;\n        }\n        const centerX = typeof dataOrA.x0 === 'number' ? dataOrA.x0 : (typeof dataOrA.x0 === 'string' ? parseFloat(dataOrA.x0) : 0);\n        this.quadraticParams = { a: aNum, b: bNum, c: cNum, x0: isFinite(centerX) ? centerX : 0 };\n        this.lineDataFromPoints = null;\n        this.scheduleRender(this.xAxis_min, this.xAxis_max);\n        return;\n      }\n\n      // 或者以三个独立参数形式传入 a, b, c\n      if ((typeof dataOrA === 'number' || typeof dataOrA === 'string') &&\n          (typeof b === 'number' || typeof b === 'string') &&\n          (typeof c === 'number' || typeof c === 'string')) {\n        const aNum = typeof dataOrA === 'number' ? dataOrA : parseFloat(dataOrA);\n        const bNum = typeof b === 'number' ? b : parseFloat(b);\n        const cNum = typeof c === 'number' ? c : parseFloat(c);\n        if (!isFinite(aNum) || !isFinite(bNum) || !isFinite(cNum)) {\n          this.scheduleRender(this.xAxis_min, this.xAxis_max);\n          return;\n        }\n        this.quadraticParams = { a: aNum, b: bNum, c: cNum };\n        this.lineDataFromPoints = null;\n        this.scheduleRender(this.xAxis_min, this.xAxis_max);\n        return;\n      }\n\n      // 其他非法输入：不处理，仅刷新现状\n      this.scheduleRender(this.xAxis_min, this.xAxis_max);\n    },\n    // 生成一元二次曲线采样点\n    generateQuadraticData(a, b, c, xMin, xMax, centerX = 0) {\n      const start = Number.isFinite(xMin) ? xMin : 0;\n      const end = Number.isFinite(xMax) ? xMax : 100;\n      const span = end - start;\n      const samples = Math.max(2, Math.min(400, Math.ceil(span / 50))); // 根据范围自适应采样密度\n      const step = span / samples || 1;\n      const data = [];\n      for (let x = start; x <= end; x += step) {\n        const t = x - centerX;\n        const y = a * t * t + b * t + c;\n        data.push([x, y]);\n      }\n      // 确保包含尾点\n      if (data.length === 0 || data[data.length - 1][0] < end) {\n        const tEnd = end - centerX;\n        const yEnd = a * tEnd * tEnd + b * tEnd + c;\n        data.push([end, yEnd]);\n      }\n      return data;\n    },\n    addMinPointData_Point(x,y) {\n      const newDataPoint = [x, y];\n      this.chartData3.push(newDataPoint);\n      this.scheduleRender(this.xAxis_min, this.xAxis_max);\n    },\n    // 更改显示的x轴范围\n    changeRange_x(current, target) {\n      this.xAxis_min = Number(current) - 3000;\n      this.xAxis_max = Number(current) + 3000;\n      this.currentX = current;\n      console.log(\"QHYCCD | changeRange_x:\", current, this.xAxis_min, this.xAxis_max);\n      this.scheduleRender(this.xAxis_min, this.xAxis_max);\n    },\n\n    // 清除数据\n    clearChartData1() {\n      this.chartData1_pos = [];\n      this.chartData1_time = [];\n      this.scheduleRender(this.xAxis_min, this.xAxis_max);\n    },\n    clearChartData2() {\n      this.chartData2 = [];\n      this.scheduleRender(this.xAxis_min, this.xAxis_max);\n    },\n    ClearAllData() {\n      this.chartData1_pos = [];\n      this.chartData1_time = [];\n      this.chartData2 = [];\n      this.chartData3 = [];\n      this.yAxis_max = 30;\n      this.FWHMMax = 15;\n      this.renderChart(this.xAxis_min, this.xAxis_max);\n    },\n    // 切换显示范围\n    RangeSwitch() {\n      if (this.range === 4) {\n        this.range = 2;\n        this.yAxis_min = -2;\n        this.yAxis_max = 2;\n      } else if (this.range === 2) {\n        this.range = 1;\n        this.yAxis_min = -1;\n        this.yAxis_max = 1;\n      } else if (this.range === 1) {\n        this.range = 4;\n        this.yAxis_min = -4;\n        this.yAxis_max = 4;\n      }\n      this.renderChart(this.xAxis_min, this.xAxis_max);\n    },\n    // 更新FWHM\n    // UpdateFWHM(FWHM) {\n    //   const newDataPoint = [this.currentX, FWHM];\n    //   this.addData_Point(newDataPoint);\n    //   // console.log(\"QHYCCD | UpdateFWHM:\", newDataPoint);\n    //   // this.$bus.$emit('SendConsoleLogMsg', 'UpdateFWHM:' + newDataPoint, 'info');\n    //   this.renderChart(this.xAxis_min, this.xAxis_max);\n    // },\n    // 拟合二次曲线\n    // fitQuadraticCurve(x, y) {\n    //   const newDataPoint = [x, y];\n    //   this.addData_Line(newDataPoint);\n    // },\n    // 拟合二次曲线最小点\n    // fitQuadraticCurve_minPoint(x, y) {\n    //   console.log(\"QHYCCD | minPoint:\", x, ',', y);\n    //   this.$bus.$emit('SendConsoleLogMsg', 'minPoint:' + x + ',' + y, 'info');\n    //   this.chartData3 = [];\n    //   const newDataPoint = [x, y];\n    //   this.chartData3.push(newDataPoint);\n    // },\n    setFocusChartRange(lowerBound, upperBound) {\n      this.x_min = lowerBound;\n      this.x_max = upperBound;\n    }\n  }\n}\n</script>\n\n<style scoped>\n.linechart-panel {\n  background-color: rgba(0, 0, 0, 0.0);\n  /* backdrop-filter: blur(5px); */\n  border-radius: 5px;\n  box-sizing: border-box;\n}\n</style>\n"]}]}