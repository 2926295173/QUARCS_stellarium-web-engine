{"remainingRequest":"/home/quarcs/workspace/QUARCS/QUARCS_stellarium-web-engine/apps/web-frontend/node_modules/vue-loader/lib/index.js??vue-loader-options!/home/quarcs/workspace/QUARCS/QUARCS_stellarium-web-engine/apps/web-frontend/src/components/Chart-Focus.vue?vue&type=script&lang=js&","dependencies":[{"path":"/home/quarcs/workspace/QUARCS/QUARCS_stellarium-web-engine/apps/web-frontend/src/components/Chart-Focus.vue","mtime":1760160652007},{"path":"/home/quarcs/workspace/QUARCS/QUARCS_stellarium-web-engine/apps/web-frontend/node_modules/cache-loader/dist/cjs.js","mtime":1756885033541},{"path":"/home/quarcs/workspace/QUARCS/QUARCS_stellarium-web-engine/apps/web-frontend/node_modules/thread-loader/dist/cjs.js","mtime":1756885034172},{"path":"/home/quarcs/workspace/QUARCS/QUARCS_stellarium-web-engine/apps/web-frontend/node_modules/babel-loader/lib/index.js","mtime":1756885033526},{"path":"/home/quarcs/workspace/QUARCS/QUARCS_stellarium-web-engine/apps/web-frontend/node_modules/cache-loader/dist/cjs.js","mtime":1756885033541},{"path":"/home/quarcs/workspace/QUARCS/QUARCS_stellarium-web-engine/apps/web-frontend/node_modules/vue-loader/lib/index.js","mtime":1756885034208}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:Ly8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KCmltcG9ydCAqIGFzIGVjaGFydHMgZnJvbSAnZWNoYXJ0cyc7CgpleHBvcnQgZGVmYXVsdCB7CiAgbmFtZTogJ0xpbmVDaGFydCcsCiAgcHJvcHM6IHsKICAgIC8vIOaYr+WQpuS9v+eUqOaXtumXtOi9tOaooeW8j++8iOS5n+WPr+mAmui/h+aAu+e6vyBzZXRGb2N1c0NoYXJ0VGltZU1vZGUg5YiH5o2i77yJCiAgICB1c2VUaW1lQXhpczogewogICAgICB0eXBlOiBCb29sZWFuLAogICAgICBkZWZhdWx0OiBmYWxzZQogICAgfSwKICAgIC8vIOaXtumXtOeql+WPo+mVv+W6pu+8iOenku+8ie+8jOS7heWcqOaXtumXtOi9tOaooeW8j+S4i+eUn+aViAogICAgdGltZVdpbmRvd1NlYzogewogICAgICB0eXBlOiBOdW1iZXIsCiAgICAgIGRlZmF1bHQ6IDYwCiAgICB9CiAgfSwKICBkYXRhKCkgewogICAgcmV0dXJuIHsKICAgICAgY29udGFpbmVyTWF4V2lkdGg6IDE1MCwKICAgICAgLy8g6Z2e5pe26Ze06L2077ya5pWj54K55pWw5o2u77yIeCDkuLrnlLXosIPkvY3nva7vvIkKICAgICAgY2hhcnREYXRhMV9wb3M6IFtdLAogICAgICAvLyDml7bpl7TovbTvvJrmlaPngrnmlbDmja7vvIh4IOS4uuaXtumXtOaIs++8iQogICAgICBjaGFydERhdGExX3RpbWU6IFtdLAogICAgICBjaGFydERhdGEyOiBbXSwKICAgICAgY2hhcnREYXRhMzogW10sCiAgICAgIGNoYXJ0RGF0YTQ6IFtdLCAvLyDlvILluLjngrnmlbDmja4KICAgICAgeEF4aXNfbWluOiAwLAogICAgICB4QXhpc19tYXg6IDYwMDAsCiAgICAgIHlBeGlzX21pbjogMCwKICAgICAgeUF4aXNfbWF4OiAzMCwKICAgICAgcmFuZ2U6IDQsCiAgICAgIGN1cnJlbnRYOiAwLAogICAgICBIRlJNYXg6IDAsCiAgICAgIGlzRHJhZ2dpbmc6IGZhbHNlLAogICAgICBzdGFydFg6IDAsCiAgICAgIGRlbHRhWDogMCwKICAgICAgeF9taW46IC02MDAwMCwKICAgICAgeF9tYXg6IDYwMDAwLAogICAgICAvLyDml7bpl7TovbTmqKHlvI8KICAgICAgaXNUaW1lTW9kZTogZmFsc2UsCiAgICAgIHRpbWVUaWNrZXI6IG51bGwsCiAgICAgIC8vIOWPr+ingeaAp+aOp+WItgogICAgICBpc1Zpc2libGU6IGZhbHNlLAogICAgICBpb09ic2VydmVyOiBudWxsLAogICAgICAvLyDmuLLmn5PosIPluqYKICAgICAgcmVuZGVyUmFmSWQ6IG51bGwsCiAgICAgIHJlbmRlclNjaGVkdWxlZDogZmFsc2UsCiAgICAgIHBlbmRpbmdMb3dlckJvdW5kOiBudWxsLAogICAgICBwZW5kaW5nVXBwZXJCb3VuZDogbnVsbCwKICAgICAgLy8g6LCD6K+V5pel5b+X5byA5YWzCiAgICAgIGRlYnVnUmVuZGVyTG9nczogZmFsc2UsCiAgICAgIC8vIOe6v+adoeaVsOaNruadpea6kO+8muiLpeS4uiBudWxsIOWImeS9v+eUqCBxdWFkcmF0aWNQYXJhbXMg5Yqo5oCB6YeH5qC3CiAgICAgIGxpbmVEYXRhRnJvbVBvaW50czogbnVsbCwKICAgICAgcXVhZHJhdGljUGFyYW1zOiBudWxsLCAvLyB7IGEsYixjLHgwPyB9CiAgICAgIC8vIOS6jOasoeaLn+WQiOe7k+aenOaYvuekugogICAgICBxdWFkcmF0aWNSZXN1bHQ6IHsKICAgICAgICBzaG93OiBmYWxzZSwKICAgICAgICBhOiAnMC4wMDAwMDAnLAogICAgICAgIGI6ICcwLjAwMDAwMCcsCiAgICAgICAgYzogJzAuMDAwMDAwJywKICAgICAgICBiZXN0UG9zaXRpb246ICcwLjAwJywKICAgICAgICBtaW5IRlI6ICcwLjAwMCcKICAgICAgfSwKICAgICAgLy8g5pel5b+X6K6w5b2V5ZmoCiAgICAgIGxvZ2dlcjogewogICAgICAgIGluZm86IChtc2csIGRhdGEpID0+IGNvbnNvbGUubG9nKG1zZywgZGF0YSB8fCAnJyksCiAgICAgICAgd2FybjogKG1zZywgZGF0YSkgPT4gY29uc29sZS53YXJuKG1zZywgZGF0YSB8fCAnJyksCiAgICAgICAgZXJyb3I6IChtc2csIGRhdGEpID0+IGNvbnNvbGUuZXJyb3IobXNnLCBkYXRhIHx8ICcnKSwKICAgICAgICBkZWJ1ZzogKG1zZywgZGF0YSkgPT4gY29uc29sZS5kZWJ1Zyhtc2csIGRhdGEgfHwgJycpCiAgICAgIH0KICAgIH07CiAgfSwKICBjb21wdXRlZDogewogICAgLy8g6K6h566X5pyJ5pWI5pWw5o2u54K55pWw6YePCiAgICB2YWxpZERhdGFQb2ludENvdW50KCkgewogICAgICBjb25zdCBjdXJyZW50RGF0YSA9IHRoaXMuaXNUaW1lTW9kZSA/IHRoaXMuY2hhcnREYXRhMV90aW1lIDogdGhpcy5jaGFydERhdGExX3BvczsKICAgICAgcmV0dXJuIGN1cnJlbnREYXRhLmxlbmd0aDsKICAgIH0sCiAgICAvLyDorqHnrpflvILluLjngrnmlbDmja4KICAgIG91dGxpZXJEYXRhUG9pbnRzKCkgewogICAgICBjb25zdCBjdXJyZW50RGF0YSA9IHRoaXMuaXNUaW1lTW9kZSA/IHRoaXMuY2hhcnREYXRhMV90aW1lIDogdGhpcy5jaGFydERhdGExX3BvczsKICAgICAgaWYgKGN1cnJlbnREYXRhLmxlbmd0aCA8IDQpIHJldHVybiBbXTsKICAgICAgLy8g6L+Z6YeM5Y+v5Lul5re75Yqg5byC5bi454K55qOA5rWL6YC76L6R77yM5pqC5pe26L+U5Zue56m65pWw57uECiAgICAgIHJldHVybiBbXTsKICAgIH0KICB9LAogIG1vdW50ZWQoKSB7CiAgICAvLyDmoLnmja7lj6/op4HmgKflkK/liqgv5YGc5q2i5pe26Ze05o6o6L+bCiAgICBjb25zdCBlbCA9IHRoaXMuJHJlZnMubGluZWNoYXJ0OwogICAgaWYgKHdpbmRvdyAmJiAnSW50ZXJzZWN0aW9uT2JzZXJ2ZXInIGluIHdpbmRvdyAmJiBlbCkgewogICAgICB0aGlzLmlvT2JzZXJ2ZXIgPSBuZXcgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIoKGVudHJpZXMpID0+IHsKICAgICAgICBjb25zdCBlID0gZW50cmllc1swXTsKICAgICAgICB0aGlzLmlzVmlzaWJsZSA9ICEhKGUgJiYgZS5pc0ludGVyc2VjdGluZyk7CiAgICAgICAgdGhpcy51cGRhdGVUaWNrZXJCeVZpc2liaWxpdHkoKTsKICAgICAgfSwgeyB0aHJlc2hvbGQ6IDAuMDEgfSk7CiAgICAgIHRoaXMuaW9PYnNlcnZlci5vYnNlcnZlKGVsKTsKICAgIH0gZWxzZSB7CiAgICAgIC8vIOWbnumAgO+8muS4jeWPr+ingeaAp+acquefpeaXtuinhuS4uuWPr+ingQogICAgICB0aGlzLmlzVmlzaWJsZSA9IHRydWU7CiAgICB9CiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCd2aXNpYmlsaXR5Y2hhbmdlJywgdGhpcy51cGRhdGVUaWNrZXJCeVZpc2liaWxpdHkpOwoKICAgIC8vIOWIneWni+WMluaXtumXtOi9tOaooeW8j++8iOeUsSBwcm9wIOaOp+WItu+8iQogICAgdGhpcy5pc1RpbWVNb2RlID0gISF0aGlzLnVzZVRpbWVBeGlzOwogICAgdGhpcy51cGRhdGVUaWNrZXJCeVZpc2liaWxpdHkoKTsKICB9LAogIGNyZWF0ZWQoKSB7CiAgICB0aGlzLiRidXMuJG9uKCdGb2N1c1Bvc2l0aW9uJywgdGhpcy5jaGFuZ2VSYW5nZV94KTsKICAgIC8vIHRoaXMuJGJ1cy4kb24oJ1VwZGF0ZUhGUicsIHRoaXMuVXBkYXRlSEZSKTsKICAgIHRoaXMuJGJ1cy4kb24oJ2ZpdFF1YWRyYXRpY0N1cnZlJywgdGhpcy5maXRRdWFkcmF0aWNDdXJ2ZSk7CiAgICB0aGlzLiRidXMuJG9uKCdmaXRRdWFkcmF0aWNDdXJ2ZV9taW5Qb2ludCcsIHRoaXMuZml0UXVhZHJhdGljQ3VydmVfbWluUG9pbnQpOwoKICAgIHRoaXMuJGJ1cy4kb24oJ0NsZWFyZml0UXVhZHJhdGljQ3VydmUnLCB0aGlzLmNsZWFyQ2hhcnREYXRhMik7CiAgICB0aGlzLiRidXMuJG9uKCdDbGVhckFsbERhdGEnLCB0aGlzLkNsZWFyQWxsRGF0YSk7CiAgICB0aGlzLiRidXMuJG9uKCdDbGVhckZpbmVEYXRhJywgdGhpcy5DbGVhckZpbmVEYXRhKTsKICAgIHRoaXMuJGJ1cy4kb24oJ3VwZGF0ZUZvY3VzQ2hhcnRXaWR0aCcsIHRoaXMuaW5pdENoYXJ0KTsKICAgIHRoaXMuJGJ1cy4kb24oJ2FkZERhdGFfUG9pbnQnLCB0aGlzLmFkZERhdGFfUG9pbnQpOwogICAgdGhpcy4kYnVzLiRvbignYWRkTWluUG9pbnREYXRhX1BvaW50JywgdGhpcy5hZGRNaW5Qb2ludERhdGFfUG9pbnQpOwogICAgdGhpcy4kYnVzLiRvbignYWRkTGluZURhdGFfUG9pbnQnLCB0aGlzLmFkZExpbmVEYXRhX1BvaW50KTsKICAgIHRoaXMuJGJ1cy4kb24oJ3NldEZvY3VzQ2hhcnRSYW5nZScsIHRoaXMuc2V0Rm9jdXNDaGFydFJhbmdlKTsKICAgIC8vIOaWsOWinu+8muaXtumXtOi9tOaooeW8j+aOp+WItuS4jueCuei/veWKoAogICAgdGhpcy4kYnVzLiRvbignc2V0Rm9jdXNDaGFydFRpbWVNb2RlJywgdGhpcy5zZXRUaW1lTW9kZSk7CiAgICB0aGlzLiRidXMuJG9uKCdhZGRGd2htTm93JywgdGhpcy5hZGRGd2htUG9pbnROb3cpOwoKICB9LAogIGJlZm9yZURlc3Ryb3koKSB7CiAgICB0aGlzLnRlYXJkb3duQnVzQW5kVGltZXJzKCk7CiAgfSwKICBkZXN0cm95ZWQoKSB7CiAgICB0aGlzLnRlYXJkb3duQnVzQW5kVGltZXJzKCk7CiAgfSwKICBtZXRob2RzOiB7CiAgICAvLyDmo4Dmn6XmmK/lkKbkuLrmsLTlubPmi5/lkIjvvIjnur/mgKfmi5/lkIjvvIkKICAgIGlzSG9yaXpvbnRhbEZpdCgpIHsKICAgICAgcmV0dXJuIHRoaXMucXVhZHJhdGljUmVzdWx0LmEgPT09ICIwLjAwMDAwMCIgfHwgTWF0aC5hYnMocGFyc2VGbG9hdCh0aGlzLnF1YWRyYXRpY1Jlc3VsdC5hKSkgPCAxZS0xMDsKICAgIH0sCiAgICAvLyDojrflj5bmnIDkvbPkvY3nva7mmL7npLrmlofmnKwKICAgIGdldEJlc3RQb3NpdGlvbkRpc3BsYXkoKSB7CiAgICAgIGlmICh0aGlzLmlzSG9yaXpvbnRhbEZpdCgpKSB7CiAgICAgICAgcmV0dXJuICLnur/mgKfmi5/lkIgiOwogICAgICB9CiAgICAgIHJldHVybiB0aGlzLnF1YWRyYXRpY1Jlc3VsdC5iZXN0UG9zaXRpb247CiAgICB9LAogICAgLy8g5YWz6Zet6Z2i5p2/CiAgICBjbG9zZVBhbmVsKCkgewogICAgICB0aGlzLnF1YWRyYXRpY1Jlc3VsdC5zaG93ID0gZmFsc2U7CiAgICB9LAogICAgLy8g6aqM6K+B5ouf5ZCI57O75pWw55qE5pyJ5pWI5oCnCiAgICB2YWxpZGF0ZUZpdENvZWZmaWNpZW50cyhhLCBiLCBjKSB7CiAgICAgIC8vIOajgOafpeezu+aVsOaYr+WQpuS4uuacieaViOaVsOWtlwogICAgICBpZiAoIWlzRmluaXRlKGEpIHx8ICFpc0Zpbml0ZShiKSB8fCAhaXNGaW5pdGUoYykpIHsKICAgICAgICByZXR1cm4gZmFsc2U7CiAgICAgIH0KICAgICAgLy8g5qOA5p+l5piv5ZCm5Li65rC05bmz57q/5ouf5ZCI77yIYeaOpei/kTDvvIkKICAgICAgaWYgKE1hdGguYWJzKGEpIDwgMWUtMTApIHsKICAgICAgICByZXR1cm4gZmFsc2U7IC8vIOawtOW5s+e6v+aLn+WQiAogICAgICB9CiAgICAgIHJldHVybiB0cnVlOwogICAgfSwKICAgIHRlYXJkb3duQnVzQW5kVGltZXJzKCkgewogICAgICB0aGlzLiRidXMuJG9mZignRm9jdXNQb3NpdGlvbicsIHRoaXMuY2hhbmdlUmFuZ2VfeCk7CiAgICAgIHRoaXMuJGJ1cy4kb2ZmKCdDbGVhcmZpdFF1YWRyYXRpY0N1cnZlJywgdGhpcy5jbGVhckNoYXJ0RGF0YTIpOwogICAgICB0aGlzLiRidXMuJG9mZignQ2xlYXJBbGxEYXRhJywgdGhpcy5DbGVhckFsbERhdGEpOwogICAgICB0aGlzLiRidXMuJG9mZigndXBkYXRlRm9jdXNDaGFydFdpZHRoJywgdGhpcy5pbml0Q2hhcnQpOwogICAgICB0aGlzLiRidXMuJG9mZignYWRkRGF0YV9Qb2ludCcsIHRoaXMuYWRkRGF0YV9Qb2ludCk7CiAgICAgIHRoaXMuJGJ1cy4kb2ZmKCdhZGRNaW5Qb2ludERhdGFfUG9pbnQnLCB0aGlzLmFkZE1pblBvaW50RGF0YV9Qb2ludCk7CiAgICAgIHRoaXMuJGJ1cy4kb2ZmKCdhZGRMaW5lRGF0YV9Qb2ludCcsIHRoaXMuYWRkTGluZURhdGFfUG9pbnQpOwogICAgICB0aGlzLiRidXMuJG9mZignYWRkUXVhZHJhdGljQ3VydmUnLCB0aGlzLmFkZExpbmVEYXRhX1BvaW50KTsKICAgICAgdGhpcy4kYnVzLiRvZmYoJ3NldEZvY3VzQ2hhcnRSYW5nZScsIHRoaXMuc2V0Rm9jdXNDaGFydFJhbmdlKTsKICAgICAgdGhpcy4kYnVzLiRvZmYoJ3NldEZvY3VzQ2hhcnRUaW1lTW9kZScsIHRoaXMuc2V0VGltZU1vZGUpOwogICAgICB0aGlzLiRidXMuJG9mZignYWRkRndobU5vdycsIHRoaXMuYWRkRndobVBvaW50Tm93KTsKICAgICAgaWYgKHRoaXMudGltZVRpY2tlcikgewogICAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy50aW1lVGlja2VyKTsKICAgICAgICB0aGlzLnRpbWVUaWNrZXIgPSBudWxsOwogICAgICB9CiAgICAgIGlmICh0aGlzLmlvT2JzZXJ2ZXIpIHsKICAgICAgICB0cnkgeyB0aGlzLmlvT2JzZXJ2ZXIuZGlzY29ubmVjdCgpOyB9IGNhdGNoIChlKSB7fQogICAgICAgIHRoaXMuaW9PYnNlcnZlciA9IG51bGw7CiAgICAgIH0KICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigndmlzaWJpbGl0eWNoYW5nZScsIHRoaXMudXBkYXRlVGlja2VyQnlWaXNpYmlsaXR5KTsKICAgIH0sCiAgICBpbml0Q2hhcnQoV2lkdGgpIHsKICAgICAgdGhpcy5jb250YWluZXJNYXhXaWR0aCA9IFdpZHRoIC0gOTU7CiAgICAgIGNvbnN0IGNoYXJ0RG9tID0gdGhpcy4kcmVmcy5saW5lY2hhcnQ7CiAgICAgIGNoYXJ0RG9tLnN0eWxlLndpZHRoID0gdGhpcy5jb250YWluZXJNYXhXaWR0aCArICdweCc7CiAgICAgIHRoaXMubXlDaGFydCA9IGVjaGFydHMuaW5pdChjaGFydERvbSk7CiAgICAgIHRoaXMucmVuZGVyQ2hhcnQodGhpcy54QXhpc19taW4sIHRoaXMueEF4aXNfbWF4KTsKICAgIH0sCiAgICBzdGFydERyYWcoZXZlbnQpIHsKICAgICAgaWYgKHRoaXMuaXNUaW1lTW9kZSkgcmV0dXJuOyAvLyDml7bpl7TovbTmqKHlvI/kuIvnpoHnlKjmi5bmi70KICAgICAgdGhpcy5pc0RyYWdnaW5nID0gdHJ1ZTsKICAgICAgY29uc3QgeCA9IHRoaXMuZ2V0Q2xpZW50WChldmVudCk7CiAgICAgIGlmICh0eXBlb2YgeCA9PT0gJ251bWJlcicpIHRoaXMuc3RhcnRYID0geDsKICAgIH0sCiAgICBkcmFnZ2luZyhldmVudCkgewogICAgICBpZiAodGhpcy5pc0RyYWdnaW5nICYmICF0aGlzLmlzVGltZU1vZGUpIHsKICAgICAgICBjb25zdCB4ID0gdGhpcy5nZXRDbGllbnRYKGV2ZW50KTsKICAgICAgICBpZiAodHlwZW9mIHggIT09ICdudW1iZXInKSByZXR1cm47CiAgICAgICAgdGhpcy5kZWx0YVggPSAoeCAtIHRoaXMuc3RhcnRYKSAqIDEwOwogICAgICAgIHRoaXMuc3RhcnRYID0geDsKICAgICAgICBjb25zdCB3aW5kb3dXaWR0aCA9IHRoaXMueEF4aXNfbWF4IC0gdGhpcy54QXhpc19taW47CiAgICAgICAgLy8g6K6h566X5paw55qE6IyD5Zu05bm25YGa6L6555WM6KOB5YmqCiAgICAgICAgbGV0IG5ld01pbiA9IHRoaXMueEF4aXNfbWluIC0gdGhpcy5kZWx0YVg7CiAgICAgICAgY29uc3QgbWluQWxsb3dlZCA9IHRoaXMueF9taW47CiAgICAgICAgY29uc3QgbWF4QWxsb3dlZCA9IHRoaXMueF9tYXggLSB3aW5kb3dXaWR0aDsKICAgICAgICBpZiAobWF4QWxsb3dlZCA8IG1pbkFsbG93ZWQpIHsKICAgICAgICAgIC8vIOWuieWFqOWkhOeQhu+8muiLpeiuvue9ruS4jeWQiOeQhu+8jOWbnumAgOWIsOS4jeenu+WKqAogICAgICAgICAgbmV3TWluID0gdGhpcy54X21pbjsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgbmV3TWluID0gTWF0aC5tYXgobWluQWxsb3dlZCwgTWF0aC5taW4obWF4QWxsb3dlZCwgbmV3TWluKSk7CiAgICAgICAgfQogICAgICAgIHRoaXMueEF4aXNfbWluID0gbmV3TWluOwogICAgICAgIHRoaXMueEF4aXNfbWF4ID0gbmV3TWluICsgd2luZG93V2lkdGg7CiAgICAgICAgdGhpcy5zY2hlZHVsZVJlbmRlcih0aGlzLnhBeGlzX21pbiwgdGhpcy54QXhpc19tYXgpOwogICAgICB9CiAgICB9LAogICAgZ2V0Q2xpZW50WChlKSB7CiAgICAgIGlmIChlICYmIGUudG91Y2hlcyAmJiBlLnRvdWNoZXMubGVuZ3RoKSByZXR1cm4gZS50b3VjaGVzWzBdLmNsaWVudFg7CiAgICAgIGlmIChlICYmIGUuY2hhbmdlZFRvdWNoZXMgJiYgZS5jaGFuZ2VkVG91Y2hlcy5sZW5ndGgpIHJldHVybiBlLmNoYW5nZWRUb3VjaGVzWzBdLmNsaWVudFg7CiAgICAgIGlmICh0eXBlb2YgZS5jbGllbnRYID09PSAnbnVtYmVyJykgcmV0dXJuIGUuY2xpZW50WDsKICAgICAgcmV0dXJuIHVuZGVmaW5lZDsKICAgIH0sCiAgICBlbmREcmFnKCkgewogICAgICB0aGlzLmlzRHJhZ2dpbmcgPSBmYWxzZTsKICAgICAgdGhpcy5kZWx0YVggPSAwOwogICAgICAvLyB0aGlzLiRidXMuJGVtaXQoJ3NldFRhcmdldFBvc2l0aW9uJywgKHRoaXMueEF4aXNfbWluICsgdGhpcy54QXhpc19tYXgpIC8gMik7CiAgICB9LAogICAgc2NoZWR1bGVSZW5kZXIobG93ZXJCb3VuZCwgdXBwZXJCb3VuZCkgewogICAgICB0aGlzLnBlbmRpbmdMb3dlckJvdW5kID0gbG93ZXJCb3VuZDsKICAgICAgdGhpcy5wZW5kaW5nVXBwZXJCb3VuZCA9IHVwcGVyQm91bmQ7CiAgICAgIGlmICh0aGlzLnJlbmRlclNjaGVkdWxlZCkgcmV0dXJuOwogICAgICB0aGlzLnJlbmRlclNjaGVkdWxlZCA9IHRydWU7CiAgICAgIGNvbnN0IGNiID0gKCkgPT4gewogICAgICAgIHRoaXMucmVuZGVyUmFmSWQgPSBudWxsOwogICAgICAgIHRoaXMucmVuZGVyU2NoZWR1bGVkID0gZmFsc2U7CiAgICAgICAgdGhpcy5yZW5kZXJDaGFydCh0aGlzLnBlbmRpbmdMb3dlckJvdW5kLCB0aGlzLnBlbmRpbmdVcHBlckJvdW5kKTsKICAgICAgfTsKICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUpIHsKICAgICAgICB0aGlzLnJlbmRlclJhZklkID0gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZShjYik7CiAgICAgIH0gZWxzZSB7CiAgICAgICAgLy8g5Zue6YCA77ya5pegIHJBRiDml7bvvIzkvb/nlKjlvq7ku7vliqHpmY3kvY7pmLvloZ4KICAgICAgICBQcm9taXNlLnJlc29sdmUoKS50aGVuKGNiKTsKICAgICAgfQogICAgfSwKICAgIHJlbmRlckNoYXJ0KGxvd2VyQm91bmQsIHVwcGVyQm91bmQpIHsKICAgICAgY29uc3QgZGF0YTEgPSB0aGlzLmlzVGltZU1vZGUgPyB0aGlzLmNoYXJ0RGF0YTFfdGltZSA6IHRoaXMuY2hhcnREYXRhMV9wb3M7CiAgICAgIGNvbnN0IHlfbWF4ID0gZGF0YTEubGVuZ3RoID4gMCA/IE1hdGgubWF4KC4uLmRhdGExLm1hcChpdGVtID0+IGl0ZW1bMV0pKSAqIDIgOiB0aGlzLnlBeGlzX21heDsKICAgICAgLy8g57q/5pWw5o2u77ya6Iul5Lyg5YWl57O75pWw77yM5YiZ5qC55o2u5b2T5YmN6KeG5Zu+6IyD5Zu05Yqo5oCB6YeH5qC377yM6YG/5YWN5ouW5Yqo5ZCO5pat6KOC5oiW5raI5aSxCiAgICAgIGxldCBkZWNEYXRhID0gW107CiAgICAgIGlmICghdGhpcy5pc1RpbWVNb2RlKSB7CiAgICAgICAgaWYgKHRoaXMubGluZURhdGFGcm9tUG9pbnRzICYmIEFycmF5LmlzQXJyYXkodGhpcy5saW5lRGF0YUZyb21Qb2ludHMpKSB7CiAgICAgICAgICBkZWNEYXRhID0gdGhpcy5saW5lRGF0YUZyb21Qb2ludHM7CiAgICAgICAgfSBlbHNlIGlmICh0aGlzLnF1YWRyYXRpY1BhcmFtcykgewogICAgICAgICAgY29uc3QgeyBhLCBiLCBjLCB4MCB9ID0gdGhpcy5xdWFkcmF0aWNQYXJhbXM7CiAgICAgICAgICBpZiAoaXNGaW5pdGUoYSkgJiYgaXNGaW5pdGUoYikgJiYgaXNGaW5pdGUoYykpIHsKICAgICAgICAgICAgZGVjRGF0YSA9IHRoaXMuZ2VuZXJhdGVRdWFkcmF0aWNEYXRhKGEsIGIsIGMsIGxvd2VyQm91bmQsIHVwcGVyQm91bmQsIGlzRmluaXRlKHgwKSA/IHgwIDogMCk7CiAgICAgICAgICB9CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIGRlY0RhdGEgPSB0aGlzLmNoYXJ0RGF0YTI7IC8vIOWFvOWuueaXp+mAu+i+kQogICAgICAgIH0KICAgICAgfQogICAgICAKICAgICAgLy8g6LCD6K+V5pel5b+XCiAgICAgIGlmICh0aGlzLmRlYnVnUmVuZGVyTG9ncyAmJiB0aGlzLmlzVGltZU1vZGUgJiYgZGF0YTEubGVuZ3RoID4gMCkgewogICAgICAgIGNvbnNvbGUubG9nKCdDaGFydC1Gb2N1czogcmVuZGVyQ2hhcnQgKHRpbWUgbW9kZSknLCB7CiAgICAgICAgICBkYXRhUG9pbnRzOiBkYXRhMS5sZW5ndGgsCiAgICAgICAgICBsYXRlc3RQb2ludDogZGF0YTFbZGF0YTEubGVuZ3RoIC0gMV0sCiAgICAgICAgICB5X21heDogeV9tYXgKICAgICAgICB9KTsKICAgICAgfQogICAgICBjb25zdCBvcHRpb25YQXhpcyA9IHRoaXMuaXNUaW1lTW9kZQogICAgICAgID8gewogICAgICAgICAgICB0eXBlOiAndGltZScsCiAgICAgICAgICAgIG1pbjogRGF0ZS5ub3coKSAtIHRoaXMudGltZVdpbmRvd1NlYyAqIDEwMDAsCiAgICAgICAgICAgIG1heDogRGF0ZS5ub3coKSwKICAgICAgICAgICAgYXhpc0xhYmVsOiB7CiAgICAgICAgICAgICAgY29sb3I6ICd3aGl0ZScsCiAgICAgICAgICAgICAgZm9udFNpemU6IDUsCiAgICAgICAgICAgICAgZm9ybWF0dGVyOiBmdW5jdGlvbiAodmFsdWUpIHsKICAgICAgICAgICAgICAgIGNvbnN0IGQgPSBuZXcgRGF0ZSh2YWx1ZSk7CiAgICAgICAgICAgICAgICBjb25zdCBwYWQgPSAobikgPT4gKG4gPCAxMCA/ICcwJyArIG4gOiAnJyArIG4pOwogICAgICAgICAgICAgICAgcmV0dXJuIHBhZChkLmdldEhvdXJzKCkpICsgJzonICsgcGFkKGQuZ2V0TWludXRlcygpKSArICc6JyArIHBhZChkLmdldFNlY29uZHMoKSk7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICB9LAogICAgICAgICAgICBheGlzTGluZTogeyBsaW5lU3R5bGU6IHsgY29sb3I6ICdyZ2JhKDIwMCwgMjAwLCAyMDAsIDAuNSknIH0gfSwKICAgICAgICAgICAgc3BsaXRMaW5lOiB7CiAgICAgICAgICAgICAgc2hvdzogdHJ1ZSwKICAgICAgICAgICAgICBsaW5lU3R5bGU6IHsgY29sb3I6ICdyZ2JhKDEyOCwgMTI4LCAxMjgsIDAuNSknLCB3aWR0aDogMSwgdHlwZTogJ3NvbGlkJyB9CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICA6IHsKICAgICAgICAgICAgdHlwZTogJ3ZhbHVlJywKICAgICAgICAgICAgbWluOiBsb3dlckJvdW5kLAogICAgICAgICAgICBtYXg6IHVwcGVyQm91bmQsCiAgICAgICAgICAgIGF4aXNMaW5lOiB7IGxpbmVTdHlsZTogeyBjb2xvcjogJ3JnYmEoMjAwLCAyMDAsIDIwMCwgMC41KScgfSB9LAogICAgICAgICAgICBheGlzTGFiZWw6IHsgY29sb3I6ICd3aGl0ZScsIGZvbnRTaXplOiA1IH0sCiAgICAgICAgICAgIHNwbGl0TGluZTogeyBzaG93OiB0cnVlLCBsaW5lU3R5bGU6IHsgY29sb3I6ICdyZ2JhKDEyOCwgMTI4LCAxMjgsIDAuNSknLCB3aWR0aDogMSwgdHlwZTogJ3NvbGlkJyB9IH0KICAgICAgICAgIH07CiAgICAgIGNvbnN0IG9wdGlvbiA9IHsKICAgICAgICBncmlkOiB7CiAgICAgICAgICBsZWZ0OiAnMCUnLAogICAgICAgICAgcmlnaHQ6ICcyJScsCiAgICAgICAgICBib3R0b206ICcwJScsCiAgICAgICAgICB0b3A6ICcxMCUnLAogICAgICAgICAgY29udGFpbkxhYmVsOiB0cnVlCiAgICAgICAgfSwKICAgICAgICB4QXhpczogb3B0aW9uWEF4aXMsCiAgICAgICAgeUF4aXM6IHsKICAgICAgICAgIG1pbjogdGhpcy55QXhpc19taW4sCiAgICAgICAgICBtYXg6IHlfbWF4LAogICAgICAgICAgYXhpc0xpbmU6IHsKICAgICAgICAgICAgbGluZVN0eWxlOiB7CiAgICAgICAgICAgICAgY29sb3I6ICdyZ2JhKDIwMCwgMjAwLCAyMDAsIDAuNSknICAvLyB56L2057q/6aKc6ImyCiAgICAgICAgICAgIH0KICAgICAgICAgIH0sCiAgICAgICAgICBheGlzTGFiZWw6IHsKICAgICAgICAgICAgY29sb3I6ICd3aGl0ZScsCiAgICAgICAgICAgIGZvbnRTaXplOiA1CiAgICAgICAgICB9LAogICAgICAgICAgc3BsaXROdW1iZXI6IDMsCiAgICAgICAgICBzcGxpdExpbmU6IHsKICAgICAgICAgICAgc2hvdzogdHJ1ZSwKICAgICAgICAgICAgbGluZVN0eWxlOiB7CiAgICAgICAgICAgICAgY29sb3I6ICdyZ2JhKDEyOCwgMTI4LCAxMjgsIDAuNSknLAogICAgICAgICAgICAgIHdpZHRoOiAxLAogICAgICAgICAgICAgIHR5cGU6ICdzb2xpZCcKICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgIH0sCiAgICAgICAgc2VyaWVzOiBbCiAgICAgICAgICB7CiAgICAgICAgICAgIG5hbWU6ICdIRlInLAogICAgICAgICAgICB0eXBlOiAnc2NhdHRlcicsCiAgICAgICAgICAgIGRhdGE6IGRhdGExLAogICAgICAgICAgICBpdGVtU3R5bGU6IHsKICAgICAgICAgICAgICBjb2xvcjogJ3JlZCcsCiAgICAgICAgICAgICAgYm9yZGVyQ29sb3I6ICd3aGl0ZScsCiAgICAgICAgICAgICAgYm9yZGVyV2lkdGg6IDEKICAgICAgICAgICAgfSwKICAgICAgICAgICAgc3ltYm9sU2l6ZTogOAogICAgICAgICAgfSwKICAgICAgICAgICF0aGlzLmlzVGltZU1vZGUgPyB7CiAgICAgICAgICAgIG5hbWU6ICdEZWMnLAogICAgICAgICAgICB0eXBlOiAnbGluZScsCiAgICAgICAgICAgIGRhdGE6IGRlY0RhdGEsCiAgICAgICAgICAgIGl0ZW1TdHlsZTogewogICAgICAgICAgICAgIGNvbG9yOiAneWVsbG93JwogICAgICAgICAgICB9LAogICAgICAgICAgICBsaW5lU3R5bGU6IHsKICAgICAgICAgICAgICB3aWR0aDogMywKICAgICAgICAgICAgICB0eXBlOiAnc29saWQnCiAgICAgICAgICAgIH0sCiAgICAgICAgICAgIHN5bWJvbFNpemU6IDAKICAgICAgICAgIH0gOiBudWxsLAogICAgICAgICAgIXRoaXMuaXNUaW1lTW9kZSA/IHsKICAgICAgICAgICAgbmFtZTogJ21pblBvaW50JywKICAgICAgICAgICAgdHlwZTogJ3NjYXR0ZXInLAogICAgICAgICAgICBkYXRhOiB0aGlzLmNoYXJ0RGF0YTMsCiAgICAgICAgICAgIGl0ZW1TdHlsZTogewogICAgICAgICAgICAgIGNvbG9yOiAncmdiYSg3NSwgMTU1LCAyNTAsIDAuNyknCiAgICAgICAgICAgIH0sCiAgICAgICAgICAgIHN5bWJvbFNpemU6IDQKICAgICAgICAgIH0gOiBudWxsLAogICAgICAgICAgIXRoaXMuaXNUaW1lTW9kZSA/IHsKICAgICAgICAgICAgbmFtZTogJ3hNaW5MaW5lJywKICAgICAgICAgICAgdHlwZTogJ2xpbmUnLAogICAgICAgICAgICBkYXRhOiBbCiAgICAgICAgICAgICAgW3RoaXMueF9taW4sIHRoaXMueUF4aXNfbWluXSwKICAgICAgICAgICAgICBbdGhpcy54X21pbiwgeV9tYXhdCiAgICAgICAgICAgIF0sCiAgICAgICAgICAgIGxpbmVTdHlsZTogewogICAgICAgICAgICAgIGNvbG9yOiAncmVkJywKICAgICAgICAgICAgICB3aWR0aDogMQogICAgICAgICAgICB9LAogICAgICAgICAgICBzeW1ib2w6ICdub25lJwogICAgICAgICAgfSA6IG51bGwsCiAgICAgICAgICAhdGhpcy5pc1RpbWVNb2RlID8gewogICAgICAgICAgICBuYW1lOiAneE1heExpbmUnLAogICAgICAgICAgICB0eXBlOiAnbGluZScsCiAgICAgICAgICAgIGRhdGE6IFsKICAgICAgICAgICAgICBbdGhpcy54X21heCwgdGhpcy55QXhpc19taW5dLAogICAgICAgICAgICAgIFt0aGlzLnhfbWF4LCB5X21heF0KICAgICAgICAgICAgXSwKICAgICAgICAgICAgbGluZVN0eWxlOiB7CiAgICAgICAgICAgICAgY29sb3I6ICdyZWQnLAogICAgICAgICAgICAgIHdpZHRoOiAxCiAgICAgICAgICAgIH0sCiAgICAgICAgICAgIHN5bWJvbDogJ25vbmUnCiAgICAgICAgICB9IDogbnVsbCwKICAgICAgICAgICF0aGlzLmlzVGltZU1vZGUgPyB7CiAgICAgICAgICAgIG5hbWU6ICdjdXJyZW50UG9zaXRpb24nLAogICAgICAgICAgICB0eXBlOiAnbGluZScsCiAgICAgICAgICAgIGRhdGE6IFsKICAgICAgICAgICAgICBbdGhpcy5jdXJyZW50WCwgdGhpcy55QXhpc19taW5dLAogICAgICAgICAgICAgIFt0aGlzLmN1cnJlbnRYLCB5X21heF0KICAgICAgICAgICAgXSwKICAgICAgICAgICAgbGluZVN0eWxlOiB7CiAgICAgICAgICAgICAgY29sb3I6ICdncmVlbicsCiAgICAgICAgICAgICAgd2lkdGg6IDEKICAgICAgICAgICAgfSwKICAgICAgICAgICAgc3ltYm9sOiAnbm9uZScKICAgICAgICAgIH0gOiBudWxsCiAgICAgICAgXQogICAgICB9OwogICAgICAvLyDov4fmu6TmjonkuLogbnVsbCDnmoQgc2VyaWVzIOmhuQogICAgICBvcHRpb24uc2VyaWVzID0gb3B0aW9uLnNlcmllcy5maWx0ZXIoQm9vbGVhbik7CiAgICAgIC8vIOS9v+eUqCBsYXp5VXBkYXRlIOmZjeS9juWQjOatpeW8gOmUgAogICAgICB0aGlzLm15Q2hhcnQuc2V0T3B0aW9uKG9wdGlvbiwgZmFsc2UsIHRydWUpOwogICAgfSwKICAgIC8vIOi/veWKoOS4gOS4quS7pSLlvZPliY3ml7bpl7Qi5Li6IHgg55qEIEZXSE0g54K577yI5pe26Ze06L205qih5byP77yJCiAgICBhZGRGd2htUG9pbnROb3coZndobSkgewogICAgICAvLyDnoa7kv50gZndobSDmmK/mlbDlrZcKICAgICAgY29uc3QgZndobU51bSA9IHR5cGVvZiBmd2htID09PSAnbnVtYmVyJyA/IGZ3aG0gOiBwYXJzZUZsb2F0KGZ3aG0pOwogICAgICBpZiAoaXNOYU4oZndobU51bSkgfHwgZndobU51bSA8PSAwKSB7CiAgICAgICAgY29uc29sZS53YXJuKCdDaGFydC1Gb2N1czogSW52YWxpZCBGV0hNIHZhbHVlOicsIGZ3aG0pOwogICAgICAgIHJldHVybjsKICAgICAgfQogICAgICAKICAgICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTsKICAgICAgY29uc3QgcG9pbnQgPSBbbm93LCBmd2htTnVtXTsKICAgICAgdGhpcy5jaGFydERhdGExX3RpbWUucHVzaChwb2ludCk7CiAgICAgIAogICAgICBjb25zb2xlLmxvZygnQ2hhcnQtRm9jdXM6IGFkZEZ3aG1Qb2ludE5vdycsIHsKICAgICAgICBmd2htOiBmd2htTnVtLAogICAgICAgIHRpbWU6IG5ldyBEYXRlKG5vdykudG9Mb2NhbGVUaW1lU3RyaW5nKCksCiAgICAgICAgaXNUaW1lTW9kZTogdGhpcy5pc1RpbWVNb2RlLAogICAgICAgIGRhdGFMZW5ndGg6IHRoaXMuY2hhcnREYXRhMV90aW1lLmxlbmd0aCwKICAgICAgICBjaGFydEluaXRpYWxpemVkOiAhIXRoaXMubXlDaGFydAogICAgICB9KTsKICAgICAgCiAgICAgIC8vIOS7heS/neeVmeeql+WPo+acn+WGheeahOaVsOaNrgogICAgICBjb25zdCBtaW5UcyA9IG5vdyAtIHRoaXMudGltZVdpbmRvd1NlYyAqIDEwMDA7CiAgICAgIHRoaXMuY2hhcnREYXRhMV90aW1lID0gdGhpcy5jaGFydERhdGExX3RpbWUuZmlsdGVyKHAgPT4gcFswXSA+PSBtaW5Ucyk7CiAgICAgIAogICAgICAvLyDlvLrliLbph43mlrDmuLLmn5MKICAgICAgaWYgKHRoaXMubXlDaGFydCkgewogICAgICAgIHRoaXMuc2NoZWR1bGVSZW5kZXIodGhpcy54QXhpc19taW4sIHRoaXMueEF4aXNfbWF4KTsKICAgICAgfSBlbHNlIHsKICAgICAgICBjb25zb2xlLndhcm4oJ0NoYXJ0LUZvY3VzOiBteUNoYXJ0IG5vdCBpbml0aWFsaXplZCB5ZXQnKTsKICAgICAgfQogICAgfSwKICAgIC8vIOW8gOWQry/lhbPpl63ml7bpl7TovbTmqKHlvI8KICAgIHNldFRpbWVNb2RlKGZsYWcpIHsKICAgICAgY29uc3QgZW5hYmxlID0gISFmbGFnOwogICAgICBpZiAoZW5hYmxlID09PSB0aGlzLmlzVGltZU1vZGUpIHJldHVybjsKICAgICAgdGhpcy5pc1RpbWVNb2RlID0gZW5hYmxlOwogICAgICB0aGlzLnVwZGF0ZVRpY2tlckJ5VmlzaWJpbGl0eSgpOwogICAgICBpZiAodGhpcy5teUNoYXJ0KSB7IHRoaXMubXlDaGFydC5jbGVhcigpOyB9CiAgICAgIHRoaXMuc2NoZWR1bGVSZW5kZXIodGhpcy54QXhpc19taW4sIHRoaXMueEF4aXNfbWF4KTsKICAgIH0sCiAgICBzdG9wVGltZVRpY2tlcigpIHsKICAgICAgaWYgKHRoaXMudGltZVRpY2tlcikgewogICAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy50aW1lVGlja2VyKTsKICAgICAgICB0aGlzLnRpbWVUaWNrZXIgPSBudWxsOwogICAgICB9CiAgICB9LAogICAgc3RhcnRUaW1lVGlja2VyKCkgewogICAgICBpZiAodGhpcy50aW1lVGlja2VyKSByZXR1cm47CiAgICAgIHRoaXMudGltZVRpY2tlciA9IHNldEludGVydmFsKCgpID0+IHsKICAgICAgICAvLyDmsqHmnInmlrDngrnml7bkuZ/mjqjliqjml7bpl7TovbTliY3ov5sKICAgICAgICBpZiAodGhpcy5teUNoYXJ0KSB7CiAgICAgICAgICB0aGlzLnNjaGVkdWxlUmVuZGVyKHRoaXMueEF4aXNfbWluLCB0aGlzLnhBeGlzX21heCk7CiAgICAgICAgfQogICAgICB9LCAxMDAwKTsKICAgIH0sCiAgICB1cGRhdGVUaWNrZXJCeVZpc2liaWxpdHkoKSB7CiAgICAgIGNvbnN0IGRvY1Zpc2libGUgPSB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnID8gIWRvY3VtZW50LmhpZGRlbiA6IHRydWU7CiAgICAgIGNvbnN0IHNob3VsZFJ1biA9IHRoaXMuaXNUaW1lTW9kZSAmJiB0aGlzLmlzVmlzaWJsZSAmJiBkb2NWaXNpYmxlOwogICAgICBpZiAoc2hvdWxkUnVuKSB0aGlzLnN0YXJ0VGltZVRpY2tlcigpOyBlbHNlIHRoaXMuc3RvcFRpbWVUaWNrZXIoKTsKICAgIH0sCiAgICBhZGREYXRhX1BvaW50KHgseSkgewogICAgICB0aGlzLmxvZ2dlci5pbmZvKCdDaGFydC1Gb2N1cy52dWUgfCDmt7vliqDmlbDmja7ngrk6JywgeyB4LCB5IH0pOwogICAgICAKICAgICAgLy8g6L+H5rukSEZS5aSn5LqO562J5LqOMTAw55qE5pWw5o2u54K5CiAgICAgIGlmICh5ID49IDEwMCkgewogICAgICAgIHRoaXMubG9nZ2VyLndhcm4oJ0NoYXJ0LUZvY3VzLnZ1ZSB8IEhGUuWAvOi/h+Wkpyg+PTEwMCnvvIzlv73nlaXmraTmlbDmja7ngrk6JywgeyB4LCB5IH0pOwogICAgICAgIHJldHVybjsKICAgICAgfQogICAgICAKICAgICAgY29uc3QgbmV3RGF0YVBvaW50ID0gW3gsIHldOwogICAgICBjb25zdCBleGlzdGluZ1BvaW50SW5kZXggPSB0aGlzLmNoYXJ0RGF0YTFfcG9zLmZpbmRJbmRleChwb2ludCA9PiBwb2ludFswXSA9PT0gbmV3RGF0YVBvaW50WzBdKTsKICAgICAgaWYgKGV4aXN0aW5nUG9pbnRJbmRleCAhPT0gLTEpIHsKICAgICAgICAvLyBJZiB0aGUgeCB2YWx1ZSBhbHJlYWR5IGV4aXN0cywgdXBkYXRlIHRoZSB5IHZhbHVlCiAgICAgICAgaWYgKG5ld0RhdGFQb2ludFsxXSA9PSAwIHx8IG5ld0RhdGFQb2ludFsxXSA9PSB0aGlzLmNoYXJ0RGF0YTFfcG9zW2V4aXN0aW5nUG9pbnRJbmRleF1bMV0pIHJldHVybjsKICAgICAgICB0aGlzLmNoYXJ0RGF0YTFfcG9zW2V4aXN0aW5nUG9pbnRJbmRleF0gPSBuZXdEYXRhUG9pbnQ7CiAgICAgIH0gZWxzZSB7CiAgICAgICAgLy8gSWYgdGhlIHggdmFsdWUgZG9lcyBub3QgZXhpc3QsIGFkZCB0aGUgbmV3IGRhdGEgcG9pbnQKICAgICAgICB0aGlzLmNoYXJ0RGF0YTFfcG9zLnB1c2gobmV3RGF0YVBvaW50KTsKICAgICAgfQogICAgICB0aGlzLnNjaGVkdWxlUmVuZGVyKHRoaXMueEF4aXNfbWluLCB0aGlzLnhBeGlzX21heCk7CiAgICB9LAogICAgLy8g57uY5Yi25oqY57q/L+S6jOasoeabsue6vwogICAgYWRkTGluZURhdGFfUG9pbnQoZGF0YU9yQSwgYiwgYykgewogICAgICAvLyDlhbzlrrnvvJrlpoLmnpzkvKDlhaXnmoTmmK/ngrnmlbDnu4TvvIznm7TmjqXkvb/nlKgKICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZGF0YU9yQSkpIHsKICAgICAgICB0aGlzLmxpbmVEYXRhRnJvbVBvaW50cyA9IGRhdGFPckE7CiAgICAgICAgdGhpcy5xdWFkcmF0aWNQYXJhbXMgPSBudWxsOwogICAgICAgIHRoaXMuc2NoZWR1bGVSZW5kZXIodGhpcy54QXhpc19taW4sIHRoaXMueEF4aXNfbWF4KTsKICAgICAgICByZXR1cm47CiAgICAgIH0KCiAgICAgIC8vIOiLpeS8oOWFpeeahOaYr+ezu+aVsOWvueixoSB7IGEsIGIsIGMgfQogICAgICBpZiAoZGF0YU9yQSAmJiB0eXBlb2YgZGF0YU9yQSA9PT0gJ29iamVjdCcgJiYKICAgICAgICAgICh0eXBlb2YgZGF0YU9yQS5hID09PSAnbnVtYmVyJyB8fCB0eXBlb2YgZGF0YU9yQS5hID09PSAnc3RyaW5nJykgJiYKICAgICAgICAgICh0eXBlb2YgZGF0YU9yQS5iID09PSAnbnVtYmVyJyB8fCB0eXBlb2YgZGF0YU9yQS5iID09PSAnc3RyaW5nJykgJiYKICAgICAgICAgICh0eXBlb2YgZGF0YU9yQS5jID09PSAnbnVtYmVyJyB8fCB0eXBlb2YgZGF0YU9yQS5jID09PSAnc3RyaW5nJykpIHsKICAgICAgICBjb25zdCBhTnVtID0gdHlwZW9mIGRhdGFPckEuYSA9PT0gJ251bWJlcicgPyBkYXRhT3JBLmEgOiBwYXJzZUZsb2F0KGRhdGFPckEuYSk7CiAgICAgICAgY29uc3QgYk51bSA9IHR5cGVvZiBkYXRhT3JBLmIgPT09ICdudW1iZXInID8gZGF0YU9yQS5iIDogcGFyc2VGbG9hdChkYXRhT3JBLmIpOwogICAgICAgIGNvbnN0IGNOdW0gPSB0eXBlb2YgZGF0YU9yQS5jID09PSAnbnVtYmVyJyA/IGRhdGFPckEuYyA6IHBhcnNlRmxvYXQoZGF0YU9yQS5jKTsKICAgICAgICBpZiAoIWlzRmluaXRlKGFOdW0pIHx8ICFpc0Zpbml0ZShiTnVtKSB8fCAhaXNGaW5pdGUoY051bSkpIHsKICAgICAgICAgIHRoaXMuc2NoZWR1bGVSZW5kZXIodGhpcy54QXhpc19taW4sIHRoaXMueEF4aXNfbWF4KTsKICAgICAgICAgIHJldHVybjsKICAgICAgICB9CiAgICAgICAgY29uc3QgY2VudGVyWCA9IHR5cGVvZiBkYXRhT3JBLngwID09PSAnbnVtYmVyJyA/IGRhdGFPckEueDAgOiAodHlwZW9mIGRhdGFPckEueDAgPT09ICdzdHJpbmcnID8gcGFyc2VGbG9hdChkYXRhT3JBLngwKSA6IDApOwogICAgICAgIHRoaXMucXVhZHJhdGljUGFyYW1zID0geyBhOiBhTnVtLCBiOiBiTnVtLCBjOiBjTnVtLCB4MDogaXNGaW5pdGUoY2VudGVyWCkgPyBjZW50ZXJYIDogMCB9OwogICAgICAgIHRoaXMubGluZURhdGFGcm9tUG9pbnRzID0gbnVsbDsKICAgICAgICB0aGlzLnNjaGVkdWxlUmVuZGVyKHRoaXMueEF4aXNfbWluLCB0aGlzLnhBeGlzX21heCk7CiAgICAgICAgcmV0dXJuOwogICAgICB9CgogICAgICAvLyDmiJbogIXku6XkuInkuKrni6znq4vlj4LmlbDlvaLlvI/kvKDlhaUgYSwgYiwgYwogICAgICBpZiAoKHR5cGVvZiBkYXRhT3JBID09PSAnbnVtYmVyJyB8fCB0eXBlb2YgZGF0YU9yQSA9PT0gJ3N0cmluZycpICYmCiAgICAgICAgICAodHlwZW9mIGIgPT09ICdudW1iZXInIHx8IHR5cGVvZiBiID09PSAnc3RyaW5nJykgJiYKICAgICAgICAgICh0eXBlb2YgYyA9PT0gJ251bWJlcicgfHwgdHlwZW9mIGMgPT09ICdzdHJpbmcnKSkgewogICAgICAgIGNvbnN0IGFOdW0gPSB0eXBlb2YgZGF0YU9yQSA9PT0gJ251bWJlcicgPyBkYXRhT3JBIDogcGFyc2VGbG9hdChkYXRhT3JBKTsKICAgICAgICBjb25zdCBiTnVtID0gdHlwZW9mIGIgPT09ICdudW1iZXInID8gYiA6IHBhcnNlRmxvYXQoYik7CiAgICAgICAgY29uc3QgY051bSA9IHR5cGVvZiBjID09PSAnbnVtYmVyJyA/IGMgOiBwYXJzZUZsb2F0KGMpOwogICAgICAgIGlmICghaXNGaW5pdGUoYU51bSkgfHwgIWlzRmluaXRlKGJOdW0pIHx8ICFpc0Zpbml0ZShjTnVtKSkgewogICAgICAgICAgdGhpcy5zY2hlZHVsZVJlbmRlcih0aGlzLnhBeGlzX21pbiwgdGhpcy54QXhpc19tYXgpOwogICAgICAgICAgcmV0dXJuOwogICAgICAgIH0KICAgICAgICB0aGlzLnF1YWRyYXRpY1BhcmFtcyA9IHsgYTogYU51bSwgYjogYk51bSwgYzogY051bSB9OwogICAgICAgIHRoaXMubGluZURhdGFGcm9tUG9pbnRzID0gbnVsbDsKICAgICAgICB0aGlzLnNjaGVkdWxlUmVuZGVyKHRoaXMueEF4aXNfbWluLCB0aGlzLnhBeGlzX21heCk7CiAgICAgICAgcmV0dXJuOwogICAgICB9CgogICAgICAvLyDlhbbku5bpnZ7ms5XovpPlhaXvvJrkuI3lpITnkIbvvIzku4XliLfmlrDnjrDnirYKICAgICAgdGhpcy5zY2hlZHVsZVJlbmRlcih0aGlzLnhBeGlzX21pbiwgdGhpcy54QXhpc19tYXgpOwogICAgfSwKICAgIC8vIOeUn+aIkOS4gOWFg+S6jOasoeabsue6v+mHh+agt+eCuQogICAgZ2VuZXJhdGVRdWFkcmF0aWNEYXRhKGEsIGIsIGMsIHhNaW4sIHhNYXgsIGNlbnRlclggPSAwKSB7CiAgICAgIGNvbnN0IHN0YXJ0ID0gTnVtYmVyLmlzRmluaXRlKHhNaW4pID8geE1pbiA6IDA7CiAgICAgIGNvbnN0IGVuZCA9IE51bWJlci5pc0Zpbml0ZSh4TWF4KSA/IHhNYXggOiAxMDA7CiAgICAgIGNvbnN0IHNwYW4gPSBlbmQgLSBzdGFydDsKICAgICAgY29uc3Qgc2FtcGxlcyA9IE1hdGgubWF4KDIsIE1hdGgubWluKDQwMCwgTWF0aC5jZWlsKHNwYW4gLyA1MCkpKTsgLy8g5qC55o2u6IyD5Zu06Ieq6YCC5bqU6YeH5qC35a+G5bqmCiAgICAgIGNvbnN0IHN0ZXAgPSBzcGFuIC8gc2FtcGxlcyB8fCAxOwogICAgICBjb25zdCBkYXRhID0gW107CiAgICAgIGZvciAobGV0IHggPSBzdGFydDsgeCA8PSBlbmQ7IHggKz0gc3RlcCkgewogICAgICAgIGNvbnN0IHQgPSB4IC0gY2VudGVyWDsKICAgICAgICBjb25zdCB5ID0gYSAqIHQgKiB0ICsgYiAqIHQgKyBjOwogICAgICAgIGRhdGEucHVzaChbeCwgeV0pOwogICAgICB9CiAgICAgIC8vIOehruS/neWMheWQq+WwvueCuQogICAgICBpZiAoZGF0YS5sZW5ndGggPT09IDAgfHwgZGF0YVtkYXRhLmxlbmd0aCAtIDFdWzBdIDwgZW5kKSB7CiAgICAgICAgY29uc3QgdEVuZCA9IGVuZCAtIGNlbnRlclg7CiAgICAgICAgY29uc3QgeUVuZCA9IGEgKiB0RW5kICogdEVuZCArIGIgKiB0RW5kICsgYzsKICAgICAgICBkYXRhLnB1c2goW2VuZCwgeUVuZF0pOwogICAgICB9CiAgICAgIHJldHVybiBkYXRhOwogICAgfSwKICAgIGFkZE1pblBvaW50RGF0YV9Qb2ludCh4LHkpIHsKICAgICAgY29uc3QgbmV3RGF0YVBvaW50ID0gW3gsIHldOwogICAgICB0aGlzLmNoYXJ0RGF0YTMucHVzaChuZXdEYXRhUG9pbnQpOwogICAgICB0aGlzLnNjaGVkdWxlUmVuZGVyKHRoaXMueEF4aXNfbWluLCB0aGlzLnhBeGlzX21heCk7CiAgICB9LAogICAgLy8g5pu05pS55pi+56S655qEeOi9tOiMg+WbtAogICAgY2hhbmdlUmFuZ2VfeChjdXJyZW50LCB0YXJnZXQpIHsKICAgICAgdGhpcy54QXhpc19taW4gPSBOdW1iZXIoY3VycmVudCkgLSAzMDAwOwogICAgICB0aGlzLnhBeGlzX21heCA9IE51bWJlcihjdXJyZW50KSArIDMwMDA7CiAgICAgIHRoaXMuY3VycmVudFggPSBjdXJyZW50OwogICAgICBjb25zb2xlLmxvZygiUUhZQ0NEIHwgY2hhbmdlUmFuZ2VfeDoiLCBjdXJyZW50LCB0aGlzLnhBeGlzX21pbiwgdGhpcy54QXhpc19tYXgpOwogICAgICB0aGlzLnNjaGVkdWxlUmVuZGVyKHRoaXMueEF4aXNfbWluLCB0aGlzLnhBeGlzX21heCk7CiAgICB9LAoKICAgIC8vIOa4hemZpOaVsOaNrgogICAgY2xlYXJDaGFydERhdGExKCkgewogICAgICB0aGlzLmNoYXJ0RGF0YTFfcG9zID0gW107CiAgICAgIHRoaXMuY2hhcnREYXRhMV90aW1lID0gW107CiAgICAgIHRoaXMuc2NoZWR1bGVSZW5kZXIodGhpcy54QXhpc19taW4sIHRoaXMueEF4aXNfbWF4KTsKICAgIH0sCiAgICBjbGVhckNoYXJ0RGF0YTIoKSB7CiAgICAgIHRoaXMuY2hhcnREYXRhMiA9IFtdOwogICAgICB0aGlzLnNjaGVkdWxlUmVuZGVyKHRoaXMueEF4aXNfbWluLCB0aGlzLnhBeGlzX21heCk7CiAgICB9LAogICAgQ2xlYXJBbGxEYXRhKCkgewogICAgICB0aGlzLmNoYXJ0RGF0YTFfcG9zID0gW107CiAgICAgIHRoaXMuY2hhcnREYXRhMV90aW1lID0gW107CiAgICAgIHRoaXMuY2hhcnREYXRhMiA9IFtdOwogICAgICB0aGlzLmNoYXJ0RGF0YTMgPSBbXTsKICAgICAgdGhpcy5jaGFydERhdGE0ID0gW107CiAgICAgIHRoaXMucXVhZHJhdGljUmVzdWx0LnNob3cgPSBmYWxzZTsKICAgICAgdGhpcy55QXhpc19tYXggPSAzMDsKICAgICAgdGhpcy5IRlJNYXggPSAxNTsKICAgICAgdGhpcy5yZW5kZXJDaGFydCh0aGlzLnhBeGlzX21pbiwgdGhpcy54QXhpc19tYXgpOwogICAgfSwKICAgIAogICAgLy8g5riF56m657K+6LCD5pWw5o2u77yI5Zyo57K+6LCD5byA5aeL5pe26LCD55So77yJCiAgICBDbGVhckZpbmVEYXRhKCkgewogICAgICB0aGlzLmxvZ2dlci5pbmZvKCdDaGFydC1Gb2N1cy52dWUgfCDmuIXnqbrnsr7osIPmlbDmja4nKTsKICAgICAgdGhpcy5jaGFydERhdGExX3BvcyA9IFtdOwogICAgICB0aGlzLmNoYXJ0RGF0YTFfdGltZSA9IFtdOwogICAgICB0aGlzLmNoYXJ0RGF0YTIgPSBbXTsKICAgICAgdGhpcy5jaGFydERhdGEzID0gW107CiAgICAgIHRoaXMuY2hhcnREYXRhNCA9IFtdOwogICAgICB0aGlzLnF1YWRyYXRpY1Jlc3VsdC5zaG93ID0gZmFsc2U7CiAgICAgIHRoaXMucmVuZGVyQ2hhcnQodGhpcy54QXhpc19taW4sIHRoaXMueEF4aXNfbWF4KTsKICAgIH0sCiAgICAKICAgIC8vIOabtOaWsOW8guW4uOeCueaVsOaNrgogICAgdXBkYXRlT3V0bGllckRhdGEoKSB7CiAgICAgIGNvbnN0IGN1cnJlbnREYXRhID0gdGhpcy5pc1RpbWVNb2RlID8gdGhpcy5jaGFydERhdGExX3RpbWUgOiB0aGlzLmNoYXJ0RGF0YTFfcG9zOwogICAgICBpZiAoY3VycmVudERhdGEubGVuZ3RoID49IDQpIHsKICAgICAgICB0aGlzLmNoYXJ0RGF0YTQgPSB0aGlzLm91dGxpZXJEYXRhUG9pbnRzOwogICAgICAgIHRoaXMubG9nZ2VyLmRlYnVnKCdDaGFydC1Gb2N1cy52dWUgfCDmm7TmlrDlvILluLjngrnmlbDmja7vvIzlvILluLjngrnmlbDph486JywgdGhpcy5jaGFydERhdGE0Lmxlbmd0aCk7CiAgICAgIH0gZWxzZSB7CiAgICAgICAgdGhpcy5jaGFydERhdGE0ID0gW107CiAgICAgIH0KICAgIH0sCiAgICAvLyDliIfmjaLmmL7npLrojIPlm7QKICAgIFJhbmdlU3dpdGNoKCkgewogICAgICBpZiAodGhpcy5yYW5nZSA9PT0gNCkgewogICAgICAgIHRoaXMucmFuZ2UgPSAyOwogICAgICAgIHRoaXMueUF4aXNfbWluID0gLTI7CiAgICAgICAgdGhpcy55QXhpc19tYXggPSAyOwogICAgICB9IGVsc2UgaWYgKHRoaXMucmFuZ2UgPT09IDIpIHsKICAgICAgICB0aGlzLnJhbmdlID0gMTsKICAgICAgICB0aGlzLnlBeGlzX21pbiA9IC0xOwogICAgICAgIHRoaXMueUF4aXNfbWF4ID0gMTsKICAgICAgfSBlbHNlIGlmICh0aGlzLnJhbmdlID09PSAxKSB7CiAgICAgICAgdGhpcy5yYW5nZSA9IDQ7CiAgICAgICAgdGhpcy55QXhpc19taW4gPSAtNDsKICAgICAgICB0aGlzLnlBeGlzX21heCA9IDQ7CiAgICAgIH0KICAgICAgdGhpcy5yZW5kZXJDaGFydCh0aGlzLnhBeGlzX21pbiwgdGhpcy54QXhpc19tYXgpOwogICAgfSwKICAgIC8vIOabtOaWsEhGUgogICAgLy8gVXBkYXRlSEZSKEhGUikgewogICAgLy8gICBjb25zdCBuZXdEYXRhUG9pbnQgPSBbdGhpcy5jdXJyZW50WCwgSEZSXTsKICAgIC8vICAgdGhpcy5hZGREYXRhX1BvaW50KG5ld0RhdGFQb2ludCk7CiAgICAvLyAgIC8vIGNvbnNvbGUubG9nKCJRSFlDQ0QgfCBVcGRhdGVIRlI6IiwgbmV3RGF0YVBvaW50KTsKICAgIC8vICAgLy8gdGhpcy4kYnVzLiRlbWl0KCdTZW5kQ29uc29sZUxvZ01zZycsICdVcGRhdGVIRlI6JyArIG5ld0RhdGFQb2ludCwgJ2luZm8nKTsKICAgIC8vICAgdGhpcy5yZW5kZXJDaGFydCh0aGlzLnhBeGlzX21pbiwgdGhpcy54QXhpc19tYXgpOwogICAgLy8gfSwKICAgIC8vIOaLn+WQiOS6jOasoeabsue6vwogICAgZml0UXVhZHJhdGljQ3VydmUoZGF0YVN0cmluZykgewogICAgICB0aGlzLmxvZ2dlci5pbmZvKCdDaGFydC1Gb2N1cy52dWUgfCDmjqXmlLbkuozmrKHmm7Lnur/mlbDmja46JywgZGF0YVN0cmluZyk7CiAgICAgIGNvbnNvbGUubG9nKCdDaGFydC1Gb2N1cy52dWUgfCDmjqXmlLbkuozmrKHmm7Lnur/mlbDmja46JywgZGF0YVN0cmluZyk7CiAgICAgIAogICAgICBjb25zdCBwYXJ0cyA9IGRhdGFTdHJpbmcuc3BsaXQoJzonKTsKICAgICAgdGhpcy5sb2dnZXIuaW5mbygnQ2hhcnQtRm9jdXMudnVlIHwg6Kej5p6Q5ZCO55qE5pWw5o2u6YOo5YiGOicsIHBhcnRzKTsKICAgICAgY29uc29sZS5sb2coJ0NoYXJ0LUZvY3VzLnZ1ZSB8IOino+aekOWQjueahOaVsOaNrumDqOWIhjonLCBwYXJ0cyk7CiAgICAgIAogICAgICBpZiAocGFydHMubGVuZ3RoID49IDYpIHsKICAgICAgICBjb25zdCBhID0gcGFyc2VGbG9hdChwYXJ0c1sxXSk7CiAgICAgICAgY29uc3QgYiA9IHBhcnNlRmxvYXQocGFydHNbMl0pOwogICAgICAgIGNvbnN0IGMgPSBwYXJzZUZsb2F0KHBhcnRzWzNdKTsKICAgICAgICBjb25zdCBiZXN0UG9zaXRpb24gPSBwYXJzZUZsb2F0KHBhcnRzWzRdKTsKICAgICAgICBjb25zdCBtaW5IRlIgPSBwYXJzZUZsb2F0KHBhcnRzWzVdKTsKICAgICAgICAKICAgICAgICB0aGlzLmxvZ2dlci5pbmZvKCdDaGFydC1Gb2N1cy52dWUgfCDop6PmnpDnmoTmlbDlgLw6JywgeyBhLCBiLCBjLCBiZXN0UG9zaXRpb24sIG1pbkhGUiB9KTsKICAgICAgICBjb25zb2xlLmxvZygnQ2hhcnQtRm9jdXMudnVlIHwg6Kej5p6Q55qE5pWw5YC8OicsIHsgYSwgYiwgYywgYmVzdFBvc2l0aW9uLCBtaW5IRlIgfSk7CiAgICAgICAgY29uc29sZS5sb2coJ0NoYXJ0LUZvY3VzLnZ1ZSB8IOWOn+Wni+Wtl+espuS4sumDqOWIhjonLCBwYXJ0cyk7CiAgICAgICAgCiAgICAgICAgLy8g6aqM6K+B5ouf5ZCI57O75pWw55qE5pyJ5pWI5oCnCiAgICAgICAgaWYgKCF0aGlzLnZhbGlkYXRlRml0Q29lZmZpY2llbnRzKGEsIGIsIGMpKSB7CiAgICAgICAgICB0aGlzLmxvZ2dlci53YXJuKCdDaGFydC1Gb2N1cy52dWUgfCDmi5/lkIjns7vmlbDml6DmlYjvvIzlj6/og73mmK/msLTlubPnur/mi5/lkIgnKTsKICAgICAgICB9CiAgICAgICAgCiAgICAgICAgLy8g5LiN5YaN6L+b6KGM5YmN56uv5ouf5ZCI6K6h566X77yM5a6M5YWo5L6d6LWW5ZCO56uv5o+Q5L6b55qE5Y+C5pWwCiAgICAgICAgdGhpcy5sb2dnZXIuaW5mbygnQ2hhcnQtRm9jdXMudnVlIHwg5L2/55So5ZCO56uv5o+Q5L6b55qE5ouf5ZCI5Y+C5pWw77yM5LiN5YaN6L+b6KGM5YmN56uv5ouf5ZCI6K6h566XJyk7CiAgICAgICAgY29uc29sZS5sb2coJ0NoYXJ0LUZvY3VzLnZ1ZSB8IOS9v+eUqOWQjuerr+aPkOS+m+eahOaLn+WQiOWPguaVsO+8jOS4jeWGjei/m+ihjOWJjeerr+aLn+WQiOiuoeeulycpOwogICAgICAgIAogICAgICAgIC8vIOmqjOivgeWPguaVsOaYr+WQpuWQiOeQhgogICAgICAgIGlmIChNYXRoLmFicyhhKSA8IDFlLTEwKSB7CiAgICAgICAgICB0aGlzLmxvZ2dlci53YXJuKCdDaGFydC1Gb2N1cy52dWUgfCDorablkYrvvJph57O75pWw5o6l6L+RMO+8jOi/meaYr+e6v+aAp+aLn+WQiOiAjOS4jeaYr+S6jOasoeaLn+WQiCcpOwogICAgICAgICAgY29uc29sZS53YXJuKCdDaGFydC1Gb2N1cy52dWUgfCDorablkYrvvJph57O75pWw5o6l6L+RMO+8jOi/meaYr+e6v+aAp+aLn+WQiOiAjOS4jeaYr+S6jOasoeaLn+WQiCcpOwogICAgICAgICAgCiAgICAgICAgICAvLyDlr7nkuo7nur/mgKfmi5/lkIjvvIzmiJHku6zpnIDopoHnibnmrorlpITnkIYKICAgICAgICAgIHRoaXMuZ2VuZXJhdGVMaW5lYXJDdXJ2ZShiLCBjLCBiZXN0UG9zaXRpb24pOwogICAgICAgICAgCiAgICAgICAgICAvLyDmm7TmlrDmlofmnKzmoYbmmL7npLrvvIjnur/mgKfmi5/lkIjvvIkKICAgICAgICAgIHRoaXMucXVhZHJhdGljUmVzdWx0LmEgPSAiMC4wMDAwMDAiOyAvLyDmmL7npLrkuLowCiAgICAgICAgICB0aGlzLnF1YWRyYXRpY1Jlc3VsdC5iID0gYi50b0ZpeGVkKDYpOwogICAgICAgICAgdGhpcy5xdWFkcmF0aWNSZXN1bHQuYyA9IGMudG9GaXhlZCg2KTsKICAgICAgICAgIHRoaXMucXVhZHJhdGljUmVzdWx0LmJlc3RQb3NpdGlvbiA9ICLnur/mgKfmi5/lkIgiOwogICAgICAgICAgdGhpcy5xdWFkcmF0aWNSZXN1bHQubWluSEZSID0gbWluSEZSLnRvRml4ZWQoMyk7CiAgICAgICAgICB0aGlzLnF1YWRyYXRpY1Jlc3VsdC5zaG93ID0gdHJ1ZTsKICAgICAgICAgIAogICAgICAgICAgcmV0dXJuOyAvLyDnm7TmjqXov5Tlm57vvIzkuI3miafooYzkuozmrKHmm7Lnur/nlJ/miJAKICAgICAgICB9CiAgICAgICAgCiAgICAgICAgLy8g5pu05paw5paH5pys5qGG5pi+56S6CiAgICAgICAgdGhpcy5xdWFkcmF0aWNSZXN1bHQuYSA9IGEudG9GaXhlZCg2KTsKICAgICAgICB0aGlzLnF1YWRyYXRpY1Jlc3VsdC5iID0gYi50b0ZpeGVkKDYpOwogICAgICAgIHRoaXMucXVhZHJhdGljUmVzdWx0LmMgPSBjLnRvRml4ZWQoNik7CiAgICAgICAgdGhpcy5xdWFkcmF0aWNSZXN1bHQuYmVzdFBvc2l0aW9uID0gYmVzdFBvc2l0aW9uLnRvRml4ZWQoMik7CiAgICAgICAgdGhpcy5xdWFkcmF0aWNSZXN1bHQubWluSEZSID0gbWluSEZSLnRvRml4ZWQoMyk7CiAgICAgICAgdGhpcy5xdWFkcmF0aWNSZXN1bHQuc2hvdyA9IHRydWU7CiAgICAgICAgCiAgICAgICAgdGhpcy5sb2dnZXIuaW5mbygnQ2hhcnQtRm9jdXMudnVlIHwg5paH5pys5qGG5pWw5o2u5bey5pu05pawOicsIHRoaXMucXVhZHJhdGljUmVzdWx0KTsKICAgICAgICAKICAgICAgICAvLyDnlJ/miJDkuozmrKHmm7Lnur/mlbDmja7ngrkKICAgICAgICB0aGlzLmdlbmVyYXRlUXVhZHJhdGljQ3VydmUoYSwgYiwgYywgYmVzdFBvc2l0aW9uKTsKICAgICAgICAKICAgICAgICAvLyDmm7TmlrDlvILluLjngrnmlbDmja4KICAgICAgICB0aGlzLnVwZGF0ZU91dGxpZXJEYXRhKCk7CiAgICAgICAgCiAgICAgICAgdGhpcy5sb2dnZXIuaW5mbygnQ2hhcnQtRm9jdXMudnVlIHwg5LqM5qyh5ouf5ZCI5L+h5oGv5bey5pu05pawOicsIHRoaXMucXVhZHJhdGljUmVzdWx0KTsKICAgICAgfSBlbHNlIHsKICAgICAgICB0aGlzLmxvZ2dlci5lcnJvcignQ2hhcnQtRm9jdXMudnVlIHwg5pWw5o2u5qC85byP6ZSZ6K+v77yM6YOo5YiG5pWw6YeP5LiN6LazOicsIHBhcnRzLmxlbmd0aCk7CiAgICAgIH0KICAgIH0sCiAgICAKICAgIC8vIOeUn+aIkOS6jOasoeabsue6v+aVsOaNrueCuQogICAgZ2VuZXJhdGVRdWFkcmF0aWNDdXJ2ZShhLCBiLCBjLCBiZXN0UG9zaXRpb24pIHsKICAgICAgdGhpcy5sb2dnZXIuaW5mbygnQ2hhcnQtRm9jdXMudnVlIHwg5byA5aeL55Sf5oiQ5LqM5qyh5puy57q/5pWw5o2u54K5OicsIHsgYSwgYiwgYywgYmVzdFBvc2l0aW9uIH0pOwogICAgICAKICAgICAgLy8g5L+u5q2j77ya5ZCO56uv5Y+R6YCB55qEYeOAgWLjgIFj57O75pWw5piv5Z+65LqO55u45a+55Z2Q5qCH55qECiAgICAgIC8vIOmcgOimgeaJvuWIsOaVsOaNrueCueeahOacgOWwj+S9jee9ruS9nOS4uuWBj+enu+mHj++8jOehruS/neS4juWQjuerr+eul+azleS4gOiHtAogICAgICAKICAgICAgLy8g5LuO5pWw5o2u54K55Lit5om+5Yiw5pyA5bCP5L2N572u5L2c5Li65YGP56e76YeP77yI5L+u5q2j77ya5LiN5L2/55SoYmVzdFBvc2l0aW9u5L2c5Li6bWluUG9z77yJCiAgICAgIGxldCBtaW5Qb3MgPSAwOwogICAgICBpZiAodGhpcy5jaGFydERhdGExX3Bvcy5sZW5ndGggPiAwKSB7CiAgICAgICAgbWluUG9zID0gTWF0aC5taW4oLi4udGhpcy5jaGFydERhdGExX3Bvcy5tYXAocG9pbnQgPT4gcG9pbnRbMF0pKTsKICAgICAgfQogICAgICAKICAgICAgdGhpcy5sb2dnZXIuZGVidWcoJ0NoYXJ0LUZvY3VzLnZ1ZSB8IOWdkOagh+ezu+e7n+S/oeaBrzonKTsKICAgICAgdGhpcy5sb2dnZXIuZGVidWcoJ0NoYXJ0LUZvY3VzLnZ1ZSB8IC0g5pWw5o2u54K55pyA5bCP5L2N572uIChtaW5Qb3MpOicsIG1pblBvcyk7CiAgICAgIHRoaXMubG9nZ2VyLmRlYnVnKCdDaGFydC1Gb2N1cy52dWUgfCAtIOWQjuerr+WPkemAgeeahOacgOS9s+S9jee9riAoYmVzdFBvc2l0aW9uKTonLCBiZXN0UG9zaXRpb24pOwogICAgICB0aGlzLmxvZ2dlci5kZWJ1ZygnQ2hhcnQtRm9jdXMudnVlIHwgLSDmi5/lkIjns7vmlbAgYTonLCBhLCAnYjonLCBiLCAnYzonLCBjKTsKICAgICAgCiAgICAgIGNvbnNvbGUubG9nKCdDaGFydC1Gb2N1cy52dWUgfCDlnZDmoIfns7vnu5/kv6Hmga86Jyk7CiAgICAgIGNvbnNvbGUubG9nKCdDaGFydC1Gb2N1cy52dWUgfCAtIOaVsOaNrueCueacgOWwj+S9jee9riAobWluUG9zKTonLCBtaW5Qb3MpOwogICAgICBjb25zb2xlLmxvZygnQ2hhcnQtRm9jdXMudnVlIHwgLSDlkI7nq6/lj5HpgIHnmoTmnIDkvbPkvY3nva4gKGJlc3RQb3NpdGlvbik6JywgYmVzdFBvc2l0aW9uKTsKICAgICAgY29uc29sZS5sb2coJ0NoYXJ0LUZvY3VzLnZ1ZSB8IC0g5ouf5ZCI57O75pWwIGE6JywgYSwgJ2I6JywgYiwgJ2M6JywgYyk7CiAgICAgIGNvbnNvbGUubG9nKCdDaGFydC1Gb2N1cy52dWUgfCAtIOW9k+WJjeaVsOaNrueCuTonLCB0aGlzLmNoYXJ0RGF0YTFfcG9zKTsKICAgICAgCiAgICAgIC8vIOmqjOivgeacgOS9s+S9jee9rueahOiuoeeul+aYr+WQpuato+ehrgogICAgICBjb25zdCBleHBlY3RlZEJlc3RSZWxhdGl2ZVBvcyA9IC1iIC8gKDIgKiBhKTsKICAgICAgY29uc3QgZXhwZWN0ZWRCZXN0QWJzb2x1dGVQb3MgPSBleHBlY3RlZEJlc3RSZWxhdGl2ZVBvcyArIG1pblBvczsKICAgICAgdGhpcy5sb2dnZXIuZGVidWcoJ0NoYXJ0LUZvY3VzLnZ1ZSB8IC0g6K6h566X55qE5pyA5L2z55u45a+55L2N572uOicsIGV4cGVjdGVkQmVzdFJlbGF0aXZlUG9zKTsKICAgICAgdGhpcy5sb2dnZXIuZGVidWcoJ0NoYXJ0LUZvY3VzLnZ1ZSB8IC0g6K6h566X55qE5pyA5L2z57ud5a+55L2N572uOicsIGV4cGVjdGVkQmVzdEFic29sdXRlUG9zKTsKICAgICAgdGhpcy5sb2dnZXIuZGVidWcoJ0NoYXJ0LUZvY3VzLnZ1ZSB8IC0g5L2N572u5beu5byCOicsIE1hdGguYWJzKGV4cGVjdGVkQmVzdEFic29sdXRlUG9zIC0gYmVzdFBvc2l0aW9uKSk7CiAgICAgIAogICAgICBjb25zdCBjdXJ2ZURhdGEgPSBbXTsKICAgICAgCiAgICAgIC8vIOaZuuiDveehruWumuabsue6v+eUn+aIkOiMg+WbtAogICAgICBsZXQgc3RhcnRYLCBlbmRYLCBzdGVwU2l6ZTsKICAgICAgCiAgICAgIGlmICh0aGlzLmNoYXJ0RGF0YTFfcG9zLmxlbmd0aCA+IDApIHsKICAgICAgICAvLyDln7rkuo7mlbDmja7ngrnojIPlm7TnlJ/miJDmm7Lnur8KICAgICAgICBjb25zdCBkYXRhTWluWCA9IE1hdGgubWluKC4uLnRoaXMuY2hhcnREYXRhMV9wb3MubWFwKHBvaW50ID0+IHBvaW50WzBdKSk7CiAgICAgICAgY29uc3QgZGF0YU1heFggPSBNYXRoLm1heCguLi50aGlzLmNoYXJ0RGF0YTFfcG9zLm1hcChwb2ludCA9PiBwb2ludFswXSkpOwogICAgICAgIGNvbnN0IGRhdGFSYW5nZSA9IGRhdGFNYXhYIC0gZGF0YU1pblg7CiAgICAgICAgCiAgICAgICAgLy8g5omp5bGV6IyD5Zu05Lul56Gu5L+d5puy57q/6KaG55uW5a6M5pW0CiAgICAgICAgY29uc3QgZXh0ZW5zaW9uID0gTWF0aC5tYXgoZGF0YVJhbmdlICogMC4yLCAxMDAwKTsgLy8g5omp5bGVMjAl5oiW6Iez5bCRMTAwMAogICAgICAgIHN0YXJ0WCA9IGRhdGFNaW5YIC0gZXh0ZW5zaW9uOwogICAgICAgIGVuZFggPSBkYXRhTWF4WCArIGV4dGVuc2lvbjsKICAgICAgICAKICAgICAgICAvLyDmoLnmja7mlbDmja7ojIPlm7TosIPmlbTmraXplb8KICAgICAgICBzdGVwU2l6ZSA9IE1hdGgubWF4KE1hdGguZmxvb3IoZGF0YVJhbmdlIC8gMTAwKSwgMjApOyAvLyDoh7PlsJExMDDkuKrngrnvvIzmraXplb/oh7PlsJEyMAogICAgICB9IGVsc2UgewogICAgICAgIC8vIOWmguaenOayoeacieaVsOaNrueCue+8jOS9v+eUqOm7mOiupOiMg+WbtAogICAgICAgIGNvbnN0IHJhbmdlID0gNTAwMDsKICAgICAgICBzdGFydFggPSBiZXN0UG9zaXRpb24gLSByYW5nZTsKICAgICAgICBlbmRYID0gYmVzdFBvc2l0aW9uICsgcmFuZ2U7CiAgICAgICAgc3RlcFNpemUgPSA1MDsKICAgICAgfQogICAgICAKICAgICAgLy8g56Gu5L+d5puy57q/6KaG55uW5b2T5YmNWOi9tOiMg+WbtAogICAgICBzdGFydFggPSBNYXRoLm1pbihzdGFydFgsIHRoaXMueEF4aXNfbWluKTsKICAgICAgZW5kWCA9IE1hdGgubWF4KGVuZFgsIHRoaXMueEF4aXNfbWF4KTsKICAgICAgCiAgICAgIHRoaXMubG9nZ2VyLmRlYnVnKCdDaGFydC1Gb2N1cy52dWUgfCDmm7Lnur/nlJ/miJDojIPlm7Q6Jywgc3RhcnRYLCAn5YiwJywgZW5kWCwgJ+atpemVvzonLCBzdGVwU2l6ZSk7CiAgICAgIAogICAgICAvLyDnlJ/miJDmm7Lnur/mlbDmja7ngrkKICAgICAgZm9yIChsZXQgeCA9IHN0YXJ0WDsgeCA8PSBlbmRYOyB4ICs9IHN0ZXBTaXplKSB7CiAgICAgICAgLy8g5bCG57ud5a+55Z2Q5qCH6L2s5o2i5Li655u45a+55Z2Q5qCH6L+b6KGM6K6h566X77yI5LiO5ZCO56uv566X5rOV5LiA6Ie077yJCiAgICAgICAgY29uc3QgcmVsYXRpdmVYID0geCAtIG1pblBvczsKICAgICAgICBjb25zdCB5ID0gYSAqIHJlbGF0aXZlWCAqIHJlbGF0aXZlWCArIGIgKiByZWxhdGl2ZVggKyBjOwogICAgICAgIAogICAgICAgIC8vIOmqjOivgeiuoeeul+e7k+aenAogICAgICAgIGlmIChpc0Zpbml0ZSh5KSAmJiB5ID49IDApIHsKICAgICAgICAgIGN1cnZlRGF0YS5wdXNoKFt4LCB5XSk7CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIHRoaXMubG9nZ2VyLndhcm4oJ0NoYXJ0LUZvY3VzLnZ1ZSB8IOitpuWRiu+8muiuoeeul+W+l+WIsOaXoOaViOeahFnlgLw6JywgeSwgJ+WcqOS9jee9rjonLCB4LCAn55u45a+55L2N572uOicsIHJlbGF0aXZlWCk7CiAgICAgICAgfQogICAgICB9CiAgICAgIAogICAgICAvLyDmt7vliqDlhbPplK7ngrnvvJrnoa7kv53mlbDmja7ngrnkvY3nva7lnKjmm7Lnur/kuIrmnInnsr7noa7nmoTngrkKICAgICAgaWYgKHRoaXMuY2hhcnREYXRhMV9wb3MubGVuZ3RoID4gMCkgewogICAgICAgIGZvciAoY29uc3QgcG9pbnQgb2YgdGhpcy5jaGFydERhdGExX3BvcykgewogICAgICAgICAgY29uc3QgeCA9IHBvaW50WzBdOwogICAgICAgICAgY29uc3QgcmVsYXRpdmVYID0geCAtIG1pblBvczsKICAgICAgICAgIGNvbnN0IHkgPSBhICogcmVsYXRpdmVYICogcmVsYXRpdmVYICsgYiAqIHJlbGF0aXZlWCArIGM7CiAgICAgICAgICAKICAgICAgICAgIGlmIChpc0Zpbml0ZSh5KSAmJiB5ID49IDApIHsKICAgICAgICAgICAgLy8g5qOA5p+l5piv5ZCm5bey57uP5a2Y5Zyo6L+Z5Liq54K577yI6YG/5YWN6YeN5aSN77yJCiAgICAgICAgICAgIGNvbnN0IGV4aXN0cyA9IGN1cnZlRGF0YS5zb21lKGN1cnZlUG9pbnQgPT4gTWF0aC5hYnMoY3VydmVQb2ludFswXSAtIHgpIDwgc3RlcFNpemUgLyAyKTsKICAgICAgICAgICAgaWYgKCFleGlzdHMpIHsKICAgICAgICAgICAgICBjdXJ2ZURhdGEucHVzaChbeCwgeV0pOwogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIAogICAgICAgIC8vIOa3u+WKoOacgOS9s+S9jee9rueCueWPiuWFtumZhOi/keeahOmrmOeyvuW6pueCuQogICAgICAgIGNvbnN0IGJlc3RSZWxhdGl2ZVggPSBiZXN0UG9zaXRpb24gLSBtaW5Qb3M7CiAgICAgICAgY29uc3QgYmVzdFkgPSBhICogYmVzdFJlbGF0aXZlWCAqIGJlc3RSZWxhdGl2ZVggKyBiICogYmVzdFJlbGF0aXZlWCArIGM7CiAgICAgICAgaWYgKGlzRmluaXRlKGJlc3RZKSAmJiBiZXN0WSA+PSAwKSB7CiAgICAgICAgICBjb25zdCBleGlzdHMgPSBjdXJ2ZURhdGEuc29tZShjdXJ2ZVBvaW50ID0+IE1hdGguYWJzKGN1cnZlUG9pbnRbMF0gLSBiZXN0UG9zaXRpb24pIDwgc3RlcFNpemUgLyAyKTsKICAgICAgICAgIGlmICghZXhpc3RzKSB7CiAgICAgICAgICAgIGN1cnZlRGF0YS5wdXNoKFtiZXN0UG9zaXRpb24sIGJlc3RZXSk7CiAgICAgICAgICB9CiAgICAgICAgICAKICAgICAgICAgIC8vIOWcqOacgOS9s+S9jee9rumZhOi/kea3u+WKoOabtOWkmumrmOeyvuW6pueCuQogICAgICAgICAgY29uc3QgZmluZVJhbmdlID0gTWF0aC5tYXgoc3RlcFNpemUgKiAyLCAyMDApOyAvLyDlnKjmnIDkvbPkvY3nva7pmYTov5EyMDDojIPlm7TlhoXkvb/nlKjpq5jnsr7luqYKICAgICAgICAgIGNvbnN0IGZpbmVTdGVwID0gTWF0aC5tYXgoc3RlcFNpemUgLyAxMCwgNSk7CiAgICAgICAgICBmb3IgKGxldCBvZmZzZXQgPSAtZmluZVJhbmdlOyBvZmZzZXQgPD0gZmluZVJhbmdlOyBvZmZzZXQgKz0gZmluZVN0ZXApIHsKICAgICAgICAgICAgY29uc3QgeCA9IGJlc3RQb3NpdGlvbiArIG9mZnNldDsKICAgICAgICAgICAgaWYgKHggPj0gc3RhcnRYICYmIHggPD0gZW5kWCkgewogICAgICAgICAgICAgIGNvbnN0IHJlbGF0aXZlWCA9IHggLSBtaW5Qb3M7CiAgICAgICAgICAgICAgY29uc3QgeSA9IGEgKiByZWxhdGl2ZVggKiByZWxhdGl2ZVggKyBiICogcmVsYXRpdmVYICsgYzsKICAgICAgICAgICAgICBpZiAoaXNGaW5pdGUoeSkgJiYgeSA+PSAwKSB7CiAgICAgICAgICAgICAgICBjb25zdCBleGlzdHMgPSBjdXJ2ZURhdGEuc29tZShjdXJ2ZVBvaW50ID0+IE1hdGguYWJzKGN1cnZlUG9pbnRbMF0gLSB4KSA8IGZpbmVTdGVwIC8gMik7CiAgICAgICAgICAgICAgICBpZiAoIWV4aXN0cykgewogICAgICAgICAgICAgICAgICBjdXJ2ZURhdGEucHVzaChbeCwgeV0pOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgIH0KICAgICAgfQogICAgICAKICAgICAgLy8g5oyJWOWdkOagh+aOkuW6jwogICAgICBjdXJ2ZURhdGEuc29ydCgoYSwgYikgPT4gYVswXSAtIGJbMF0pOwogICAgICAKICAgICAgLy8g5Zyo5pWw5o2u54K55a+G6ZuG5Yy65Z+f5aKe5Yqg5puy57q/5a+G5bqmCiAgICAgIGlmICh0aGlzLmNoYXJ0RGF0YTFfcG9zLmxlbmd0aCA+IDApIHsKICAgICAgICBjb25zdCBlbmhhbmNlZEN1cnZlRGF0YSA9IFtdOwogICAgICAgIGNvbnN0IGZpbmVTdGVwU2l6ZSA9IE1hdGgubWF4KHN0ZXBTaXplIC8gNSwgNSk7IC8vIOWcqOWvhumbhuWMuuWfn+S9v+eUqOabtOWwj+eahOatpemVvwogICAgICAgIAogICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY3VydmVEYXRhLmxlbmd0aCAtIDE7IGkrKykgewogICAgICAgICAgY29uc3QgY3VycmVudFBvaW50ID0gY3VydmVEYXRhW2ldOwogICAgICAgICAgY29uc3QgbmV4dFBvaW50ID0gY3VydmVEYXRhW2kgKyAxXTsKICAgICAgICAgIAogICAgICAgICAgZW5oYW5jZWRDdXJ2ZURhdGEucHVzaChjdXJyZW50UG9pbnQpOwogICAgICAgICAgCiAgICAgICAgICAvLyDmo4Dmn6XlvZPliY3mrrXmmK/lkKbljIXlkKvmlbDmja7ngrkKICAgICAgICAgIGNvbnN0IGhhc0RhdGFQb2ludCA9IHRoaXMuY2hhcnREYXRhMV9wb3Muc29tZShwb2ludCA9PiAKICAgICAgICAgICAgcG9pbnRbMF0gPj0gY3VycmVudFBvaW50WzBdICYmIHBvaW50WzBdIDw9IG5leHRQb2ludFswXQogICAgICAgICAgKTsKICAgICAgICAgIAogICAgICAgICAgLy8g5aaC5p6c5YyF5ZCr5pWw5o2u54K577yM5Zyo5Lit6Ze05re75Yqg5pu05aSa54K5CiAgICAgICAgICBpZiAoaGFzRGF0YVBvaW50ICYmIChuZXh0UG9pbnRbMF0gLSBjdXJyZW50UG9pbnRbMF0pID4gZmluZVN0ZXBTaXplKSB7CiAgICAgICAgICAgIGNvbnN0IG1pZFBvaW50cyA9IE1hdGguZmxvb3IoKG5leHRQb2ludFswXSAtIGN1cnJlbnRQb2ludFswXSkgLyBmaW5lU3RlcFNpemUpOwogICAgICAgICAgICBmb3IgKGxldCBqID0gMTsgaiA8IG1pZFBvaW50czsgaisrKSB7CiAgICAgICAgICAgICAgY29uc3QgeCA9IGN1cnJlbnRQb2ludFswXSArIChqICogZmluZVN0ZXBTaXplKTsKICAgICAgICAgICAgICBjb25zdCByZWxhdGl2ZVggPSB4IC0gbWluUG9zOwogICAgICAgICAgICAgIGNvbnN0IHkgPSBhICogcmVsYXRpdmVYICogcmVsYXRpdmVYICsgYiAqIHJlbGF0aXZlWCArIGM7CiAgICAgICAgICAgICAgaWYgKGlzRmluaXRlKHkpICYmIHkgPj0gMCkgewogICAgICAgICAgICAgICAgZW5oYW5jZWRDdXJ2ZURhdGEucHVzaChbeCwgeV0pOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICAKICAgICAgICAvLyDmt7vliqDmnIDlkI7kuIDkuKrngrkKICAgICAgICBpZiAoY3VydmVEYXRhLmxlbmd0aCA+IDApIHsKICAgICAgICAgIGVuaGFuY2VkQ3VydmVEYXRhLnB1c2goY3VydmVEYXRhW2N1cnZlRGF0YS5sZW5ndGggLSAxXSk7CiAgICAgICAgfQogICAgICAgIAogICAgICAgIC8vIOabtOaWsOabsue6v+aVsOaNrgogICAgICAgIGN1cnZlRGF0YS5sZW5ndGggPSAwOwogICAgICAgIGN1cnZlRGF0YS5wdXNoKC4uLmVuaGFuY2VkQ3VydmVEYXRhKTsKICAgICAgfQogICAgICAKICAgICAgLy8g5re75Yqg5YWz6ZSu54K555qE6aqM6K+BCiAgICAgIGlmIChjdXJ2ZURhdGEubGVuZ3RoID4gMCkgewogICAgICAgIC8vIOmqjOivgeacgOS9s+S9jee9rueCueeahFnlgLwKICAgICAgICBjb25zdCBiZXN0UG9pbnRZID0gYSAqIChiZXN0UG9zaXRpb24gLSBtaW5Qb3MpICogKGJlc3RQb3NpdGlvbiAtIG1pblBvcykgKyBiICogKGJlc3RQb3NpdGlvbiAtIG1pblBvcykgKyBjOwogICAgICAgIHRoaXMubG9nZ2VyLmRlYnVnKCdDaGFydC1Gb2N1cy52dWUgfCDmnIDkvbPkvY3nva7ngrnpqozor4E6Jyk7CiAgICAgICAgdGhpcy5sb2dnZXIuZGVidWcoJ0NoYXJ0LUZvY3VzLnZ1ZSB8IC0g5pyA5L2z5L2N572uOicsIGJlc3RQb3NpdGlvbik7CiAgICAgICAgdGhpcy5sb2dnZXIuZGVidWcoJ0NoYXJ0LUZvY3VzLnZ1ZSB8IC0g5pyA5L2z5L2N572u55u45a+55Z2Q5qCHOicsIGJlc3RQb3NpdGlvbiAtIG1pblBvcyk7CiAgICAgICAgdGhpcy5sb2dnZXIuZGVidWcoJ0NoYXJ0LUZvY3VzLnZ1ZSB8IC0g5pyA5L2z5L2N572uWeWAvDonLCBiZXN0UG9pbnRZKTsKICAgICAgICAKICAgICAgICAvLyDpqozor4HmlbDmja7ngrnmmK/lkKblnKjmm7Lnur/kuIoKICAgICAgICB0aGlzLmxvZ2dlci5kZWJ1ZygnQ2hhcnQtRm9jdXMudnVlIHwg5pWw5o2u54K55LiO5puy57q/5a+55q+UOicpOwogICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgTWF0aC5taW4odGhpcy5jaGFydERhdGExX3Bvcy5sZW5ndGgsIDUpOyBpKyspIHsKICAgICAgICAgIGNvbnN0IHBvaW50ID0gdGhpcy5jaGFydERhdGExX3Bvc1tpXTsKICAgICAgICAgIGNvbnN0IHBvaW50UmVsYXRpdmVYID0gcG9pbnRbMF0gLSBtaW5Qb3M7CiAgICAgICAgICBjb25zdCBwb2ludFkgPSBhICogcG9pbnRSZWxhdGl2ZVggKiBwb2ludFJlbGF0aXZlWCArIGIgKiBwb2ludFJlbGF0aXZlWCArIGM7CiAgICAgICAgICBjb25zdCBhY3R1YWxZID0gcG9pbnRbMV07CiAgICAgICAgICBjb25zdCBkaWZmID0gTWF0aC5hYnMocG9pbnRZIC0gYWN0dWFsWSk7CiAgICAgICAgICB0aGlzLmxvZ2dlci5kZWJ1ZyhgQ2hhcnQtRm9jdXMudnVlIHwgLSDngrkke2l9OiDkvY3nva49JHtwb2ludFswXX0sIOWunumZhUhGUj0ke2FjdHVhbFl9LCDmm7Lnur9IRlI9JHtwb2ludFl9LCDlt67lvII9JHtkaWZmfWApOwogICAgICAgIH0KICAgICAgfQogICAgICAKICAgICAgdGhpcy5sb2dnZXIuZGVidWcoJ0NoYXJ0LUZvY3VzLnZ1ZSB8IOeUn+aIkOeahOabsue6v+aVsOaNrueCueaVsOmHjzonLCBjdXJ2ZURhdGEubGVuZ3RoKTsKICAgICAgdGhpcy5sb2dnZXIuZGVidWcoJ0NoYXJ0LUZvY3VzLnZ1ZSB8IFjovbTojIPlm7Q6Jywgc3RhcnRYLCAn5YiwJywgZW5kWCk7CiAgICAgIHRoaXMubG9nZ2VyLmRlYnVnKCdDaGFydC1Gb2N1cy52dWUgfCDliY015Liq5pWw5o2u54K5OicsIGN1cnZlRGF0YS5zbGljZSgwLCA1KSk7CiAgICAgIHRoaXMubG9nZ2VyLmRlYnVnKCdDaGFydC1Gb2N1cy52dWUgfCDlkI415Liq5pWw5o2u54K5OicsIGN1cnZlRGF0YS5zbGljZSgtNSkpOwogICAgICAKICAgICAgLy8g6aqM6K+B5puy57q/5b2i54q2CiAgICAgIGlmIChjdXJ2ZURhdGEubGVuZ3RoID4gMCkgewogICAgICAgIGNvbnN0IGZpcnN0WSA9IGN1cnZlRGF0YVswXVsxXTsKICAgICAgICBjb25zdCBsYXN0WSA9IGN1cnZlRGF0YVtjdXJ2ZURhdGEubGVuZ3RoIC0gMV1bMV07CiAgICAgICAgY29uc3QgbWlkZGxlSW5kZXggPSBNYXRoLmZsb29yKGN1cnZlRGF0YS5sZW5ndGggLyAyKTsKICAgICAgICBjb25zdCBtaWRkbGVZID0gY3VydmVEYXRhW21pZGRsZUluZGV4XVsxXTsKICAgICAgICAKICAgICAgICB0aGlzLmxvZ2dlci5kZWJ1ZygnQ2hhcnQtRm9jdXMudnVlIHwg5puy57q/5b2i54q26aqM6K+BIC0g6LW35aeLWTonLCBmaXJzdFksICfkuK3pl7RZOicsIG1pZGRsZVksICfnu5PmnZ9ZOicsIGxhc3RZKTsKICAgICAgICAKICAgICAgICAvLyDmo4Dmn6XmmK/lkKbkuLrmnInmlYjnmoTkuozmrKHmm7Lnur/vvIjlupTor6XmnInmnIDlsI/lgLzmiJbmnIDlpKflgLzvvIkKICAgICAgICBpZiAoTWF0aC5hYnMoYSkgPiAxZS0xMCkgewogICAgICAgICAgY29uc3QgdmVydGV4WCA9IC1iIC8gKDIgKiBhKSArIG1pblBvczsgLy8g6aG254K5WOWdkOagh++8iOi9rOaNouWbnue7neWvueWdkOagh++8iQogICAgICAgICAgY29uc3QgdmVydGV4WSA9IGMgLSAoYiAqIGIpIC8gKDQgKiBhKTsgLy8g6aG254K5WeWdkOaghwogICAgICAgICAgdGhpcy5sb2dnZXIuZGVidWcoJ0NoYXJ0LUZvY3VzLnZ1ZSB8IOS6jOasoeabsue6v+mhtueCueS9jee9rjonLCB2ZXJ0ZXhYLCAnWeWAvDonLCB2ZXJ0ZXhZKTsKICAgICAgICB9CiAgICAgIH0KICAgICAgCiAgICAgIC8vIOacgOe7iOmqjOivgeWSjOa4heeQhuabsue6v+aVsOaNrgogICAgICBjb25zdCBmaW5hbEN1cnZlRGF0YSA9IGN1cnZlRGF0YS5maWx0ZXIocG9pbnQgPT4gewogICAgICAgIGNvbnN0IFt4LCB5XSA9IHBvaW50OwogICAgICAgIHJldHVybiBpc0Zpbml0ZSh4KSAmJiBpc0Zpbml0ZSh5KSAmJiB5ID49IDAgJiYgeCA+PSBzdGFydFggJiYgeCA8PSBlbmRYOwogICAgICB9KTsKICAgICAgCiAgICAgIC8vIOehruS/neabsue6v+aVsOaNruaMiVjlnZDmoIfmjpLluo8KICAgICAgZmluYWxDdXJ2ZURhdGEuc29ydCgoYSwgYikgPT4gYVswXSAtIGJbMF0pOwogICAgICAKICAgICAgdGhpcy5sb2dnZXIuZGVidWcoJ0NoYXJ0LUZvY3VzLnZ1ZSB8IOacgOe7iOabsue6v+aVsOaNrumqjOivgTonKTsKICAgICAgdGhpcy5sb2dnZXIuZGVidWcoJ0NoYXJ0LUZvY3VzLnZ1ZSB8IC0g5Y6f5aeL5pWw5o2u54K55pWw6YePOicsIGN1cnZlRGF0YS5sZW5ndGgpOwogICAgICB0aGlzLmxvZ2dlci5kZWJ1ZygnQ2hhcnQtRm9jdXMudnVlIHwgLSDmuIXnkIblkI7mlbDmja7ngrnmlbDph486JywgZmluYWxDdXJ2ZURhdGEubGVuZ3RoKTsKICAgICAgdGhpcy5sb2dnZXIuZGVidWcoJ0NoYXJ0LUZvY3VzLnZ1ZSB8IC0gWOi9tOiMg+WbtDonLCBmaW5hbEN1cnZlRGF0YS5sZW5ndGggPiAwID8gYCR7ZmluYWxDdXJ2ZURhdGFbMF1bMF19IOWIsCAke2ZpbmFsQ3VydmVEYXRhW2ZpbmFsQ3VydmVEYXRhLmxlbmd0aCAtIDFdWzBdfWAgOiAn5peg5pWw5o2uJyk7CiAgICAgIAogICAgICB0aGlzLmNoYXJ0RGF0YTIgPSBmaW5hbEN1cnZlRGF0YTsKICAgICAgdGhpcy5sb2dnZXIuZGVidWcoJ0NoYXJ0LUZvY3VzLnZ1ZSB8IGNoYXJ0RGF0YTLlt7Lmm7TmlrDvvIzplb/luqY6JywgdGhpcy5jaGFydERhdGEyLmxlbmd0aCk7CiAgICAgIAogICAgICAvLyDosIPmlbRY6L206IyD5Zu05Lul5pi+56S65a6M5pW05puy57q/CiAgICAgIGlmIChmaW5hbEN1cnZlRGF0YS5sZW5ndGggPiAwKSB7CiAgICAgICAgdGhpcy54QXhpc19taW4gPSBNYXRoLm1pbih0aGlzLnhBeGlzX21pbiwgZmluYWxDdXJ2ZURhdGFbMF1bMF0pOwogICAgICAgIHRoaXMueEF4aXNfbWF4ID0gTWF0aC5tYXgodGhpcy54QXhpc19tYXgsIGZpbmFsQ3VydmVEYXRhW2ZpbmFsQ3VydmVEYXRhLmxlbmd0aCAtIDFdWzBdKTsKICAgICAgfQogICAgICAKICAgICAgdGhpcy5yZW5kZXJDaGFydCh0aGlzLnhBeGlzX21pbiwgdGhpcy54QXhpc19tYXgpOwogICAgICAKICAgICAgdGhpcy5sb2dnZXIuaW5mbygnQ2hhcnQtRm9jdXMudnVlIHwg5LqM5qyh5puy57q/5pWw5o2u54K55bey55Sf5oiQ5bm25riy5p+T5a6M5oiQJyk7CiAgICB9LAogICAgCiAgICAvLyDnlJ/miJDnur/mgKfmm7Lnur/mlbDmja7ngrnvvIjlvZNhPTDml7bvvIkKICAgIGdlbmVyYXRlTGluZWFyQ3VydmUoYiwgYywgYmVzdFBvc2l0aW9uKSB7CiAgICAgIHRoaXMubG9nZ2VyLmluZm8oJ0NoYXJ0LUZvY3VzLnZ1ZSB8IOW8gOWni+eUn+aIkOe6v+aAp+absue6v+aVsOaNrueCuTonLCB7IGIsIGMsIGJlc3RQb3NpdGlvbiB9KTsKICAgICAgY29uc29sZS5sb2coJ0NoYXJ0LUZvY3VzLnZ1ZSB8IOW8gOWni+eUn+aIkOe6v+aAp+absue6v+aVsOaNrueCuTonLCB7IGIsIGMsIGJlc3RQb3NpdGlvbiB9KTsKICAgICAgCiAgICAgIC8vIOWvueS6jue6v+aAp+aLn+WQiO+8jOaIkeS7rOmcgOimgeaJvuWIsOaVsOaNrueCueeahOacgOWwj+S9jee9ruS9nOS4uuWBj+enu+mHjwogICAgICBsZXQgbWluUG9zID0gMDsKICAgICAgaWYgKHRoaXMuY2hhcnREYXRhMV9wb3MubGVuZ3RoID4gMCkgewogICAgICAgIG1pblBvcyA9IE1hdGgubWluKC4uLnRoaXMuY2hhcnREYXRhMV9wb3MubWFwKHBvaW50ID0+IHBvaW50WzBdKSk7CiAgICAgIH0KICAgICAgCiAgICAgIHRoaXMubG9nZ2VyLmRlYnVnKCdDaGFydC1Gb2N1cy52dWUgfCDnur/mgKfmi5/lkIjlnZDmoIfns7vnu5/kv6Hmga86Jyk7CiAgICAgIHRoaXMubG9nZ2VyLmRlYnVnKCdDaGFydC1Gb2N1cy52dWUgfCAtIOaVsOaNrueCueacgOWwj+S9jee9riAobWluUG9zKTonLCBtaW5Qb3MpOwogICAgICB0aGlzLmxvZ2dlci5kZWJ1ZygnQ2hhcnQtRm9jdXMudnVlIHwgLSDnur/mgKfns7vmlbAgYjonLCBiLCAnYzonLCBjKTsKICAgICAgCiAgICAgIGNvbnNvbGUubG9nKCdDaGFydC1Gb2N1cy52dWUgfCDnur/mgKfmi5/lkIjlnZDmoIfns7vnu5/kv6Hmga86Jyk7CiAgICAgIGNvbnNvbGUubG9nKCdDaGFydC1Gb2N1cy52dWUgfCAtIOaVsOaNrueCueacgOWwj+S9jee9riAobWluUG9zKTonLCBtaW5Qb3MpOwogICAgICBjb25zb2xlLmxvZygnQ2hhcnQtRm9jdXMudnVlIHwgLSDnur/mgKfns7vmlbAgYjonLCBiLCAnYzonLCBjKTsKICAgICAgCiAgICAgIGNvbnN0IGN1cnZlRGF0YSA9IFtdOwogICAgICAKICAgICAgLy8g5pm66IO956Gu5a6a5puy57q/55Sf5oiQ6IyD5Zu0CiAgICAgIGxldCBzdGFydFgsIGVuZFgsIHN0ZXBTaXplOwogICAgICAKICAgICAgaWYgKHRoaXMuY2hhcnREYXRhMV9wb3MubGVuZ3RoID4gMCkgewogICAgICAgIC8vIOWfuuS6juaVsOaNrueCueiMg+WbtOeUn+aIkOabsue6vwogICAgICAgIGNvbnN0IGRhdGFNaW5YID0gTWF0aC5taW4oLi4udGhpcy5jaGFydERhdGExX3Bvcy5tYXAocG9pbnQgPT4gcG9pbnRbMF0pKTsKICAgICAgICBjb25zdCBkYXRhTWF4WCA9IE1hdGgubWF4KC4uLnRoaXMuY2hhcnREYXRhMV9wb3MubWFwKHBvaW50ID0+IHBvaW50WzBdKSk7CiAgICAgICAgY29uc3QgZGF0YVJhbmdlID0gZGF0YU1heFggLSBkYXRhTWluWDsKICAgICAgICAKICAgICAgICAvLyDmianlsZXojIPlm7Tku6Xnoa7kv53mm7Lnur/opobnm5blrozmlbQKICAgICAgICBjb25zdCBleHRlbnNpb24gPSBNYXRoLm1heChkYXRhUmFuZ2UgKiAwLjIsIDEwMDApOwogICAgICAgIHN0YXJ0WCA9IGRhdGFNaW5YIC0gZXh0ZW5zaW9uOwogICAgICAgIGVuZFggPSBkYXRhTWF4WCArIGV4dGVuc2lvbjsKICAgICAgICAKICAgICAgICAvLyDmoLnmja7mlbDmja7ojIPlm7TosIPmlbTmraXplb8KICAgICAgICBzdGVwU2l6ZSA9IE1hdGgubWF4KE1hdGguZmxvb3IoZGF0YVJhbmdlIC8gMTAwKSwgMjApOwogICAgICB9IGVsc2UgewogICAgICAgIC8vIOWmguaenOayoeacieaVsOaNrueCue+8jOS9v+eUqOm7mOiupOiMg+WbtAogICAgICAgIGNvbnN0IHJhbmdlID0gNTAwMDsKICAgICAgICBzdGFydFggPSBiZXN0UG9zaXRpb24gLSByYW5nZTsKICAgICAgICBlbmRYID0gYmVzdFBvc2l0aW9uICsgcmFuZ2U7CiAgICAgICAgc3RlcFNpemUgPSA1MDsKICAgICAgfQogICAgICAKICAgICAgLy8g56Gu5L+d5puy57q/6KaG55uW5b2T5YmNWOi9tOiMg+WbtAogICAgICBzdGFydFggPSBNYXRoLm1pbihzdGFydFgsIHRoaXMueEF4aXNfbWluKTsKICAgICAgZW5kWCA9IE1hdGgubWF4KGVuZFgsIHRoaXMueEF4aXNfbWF4KTsKICAgICAgCiAgICAgIHRoaXMubG9nZ2VyLmRlYnVnKCdDaGFydC1Gb2N1cy52dWUgfCDnur/mgKfmm7Lnur/nlJ/miJDojIPlm7Q6Jywgc3RhcnRYLCAn5YiwJywgZW5kWCwgJ+atpemVvzonLCBzdGVwU2l6ZSk7CiAgICAgIAogICAgICAvLyDnlJ/miJDnur/mgKfmm7Lnur/mlbDmja7ngrkKICAgICAgZm9yIChsZXQgeCA9IHN0YXJ0WDsgeCA8PSBlbmRYOyB4ICs9IHN0ZXBTaXplKSB7CiAgICAgICAgLy8g5bCG57ud5a+55Z2Q5qCH6L2s5o2i5Li655u45a+55Z2Q5qCH6L+b6KGM6K6h566XCiAgICAgICAgY29uc3QgcmVsYXRpdmVYID0geCAtIG1pblBvczsKICAgICAgICBjb25zdCB5ID0gYiAqIHJlbGF0aXZlWCArIGM7IC8vIOe6v+aAp+aWueeoi++8mnkgPSBieCArIGMKICAgICAgICAKICAgICAgICAvLyDpqozor4HorqHnrpfnu5PmnpwKICAgICAgICBpZiAoaXNGaW5pdGUoeSkgJiYgeSA+PSAwKSB7CiAgICAgICAgICBjdXJ2ZURhdGEucHVzaChbeCwgeV0pOwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICB0aGlzLmxvZ2dlci53YXJuKCdDaGFydC1Gb2N1cy52dWUgfCDorablkYrvvJrorqHnrpflvpfliLDml6DmlYjnmoRZ5YC8OicsIHksICflnKjkvY3nva46JywgeCwgJ+ebuOWvueS9jee9rjonLCByZWxhdGl2ZVgpOwogICAgICAgIH0KICAgICAgfQogICAgICAKICAgICAgLy8g5re75Yqg5YWz6ZSu54K577ya56Gu5L+d5pWw5o2u54K55L2N572u5Zyo5puy57q/5LiK5pyJ57K+56Gu55qE54K5CiAgICAgIGlmICh0aGlzLmNoYXJ0RGF0YTFfcG9zLmxlbmd0aCA+IDApIHsKICAgICAgICBmb3IgKGNvbnN0IHBvaW50IG9mIHRoaXMuY2hhcnREYXRhMV9wb3MpIHsKICAgICAgICAgIGNvbnN0IHggPSBwb2ludFswXTsKICAgICAgICAgIGNvbnN0IHJlbGF0aXZlWCA9IHggLSBtaW5Qb3M7CiAgICAgICAgICBjb25zdCB5ID0gYiAqIHJlbGF0aXZlWCArIGM7CiAgICAgICAgICAKICAgICAgICAgIGlmIChpc0Zpbml0ZSh5KSAmJiB5ID49IDApIHsKICAgICAgICAgICAgLy8g5qOA5p+l5piv5ZCm5bey57uP5a2Y5Zyo6L+Z5Liq54K577yI6YG/5YWN6YeN5aSN77yJCiAgICAgICAgICAgIGNvbnN0IGV4aXN0cyA9IGN1cnZlRGF0YS5zb21lKGN1cnZlUG9pbnQgPT4gTWF0aC5hYnMoY3VydmVQb2ludFswXSAtIHgpIDwgc3RlcFNpemUgLyAyKTsKICAgICAgICAgICAgaWYgKCFleGlzdHMpIHsKICAgICAgICAgICAgICBjdXJ2ZURhdGEucHVzaChbeCwgeV0pOwogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICB9CiAgICAgIAogICAgICAvLyDmjIlY5Z2Q5qCH5o6S5bqPCiAgICAgIGN1cnZlRGF0YS5zb3J0KChhLCBiKSA9PiBhWzBdIC0gYlswXSk7CiAgICAgIAogICAgICAvLyDmnIDnu4jpqozor4HlkozmuIXnkIbmm7Lnur/mlbDmja4KICAgICAgY29uc3QgZmluYWxDdXJ2ZURhdGEgPSBjdXJ2ZURhdGEuZmlsdGVyKHBvaW50ID0+IHsKICAgICAgICBjb25zdCBbeCwgeV0gPSBwb2ludDsKICAgICAgICByZXR1cm4gaXNGaW5pdGUoeCkgJiYgaXNGaW5pdGUoeSkgJiYgeSA+PSAwICYmIHggPj0gc3RhcnRYICYmIHggPD0gZW5kWDsKICAgICAgfSk7CiAgICAgIAogICAgICB0aGlzLmxvZ2dlci5kZWJ1ZygnQ2hhcnQtRm9jdXMudnVlIHwg57q/5oCn5puy57q/5pyA57uI5pWw5o2u6aqM6K+BOicpOwogICAgICB0aGlzLmxvZ2dlci5kZWJ1ZygnQ2hhcnQtRm9jdXMudnVlIHwgLSDljp/lp4vmlbDmja7ngrnmlbDph486JywgY3VydmVEYXRhLmxlbmd0aCk7CiAgICAgIHRoaXMubG9nZ2VyLmRlYnVnKCdDaGFydC1Gb2N1cy52dWUgfCAtIOa4heeQhuWQjuaVsOaNrueCueaVsOmHjzonLCBmaW5hbEN1cnZlRGF0YS5sZW5ndGgpOwogICAgICAKICAgICAgdGhpcy5jaGFydERhdGEyID0gZmluYWxDdXJ2ZURhdGE7CiAgICAgIHRoaXMubG9nZ2VyLmRlYnVnKCdDaGFydC1Gb2N1cy52dWUgfCBjaGFydERhdGEy5bey5pu05paw77yI57q/5oCn5ouf5ZCI77yJ77yM6ZW/5bqmOicsIHRoaXMuY2hhcnREYXRhMi5sZW5ndGgpOwogICAgICAKICAgICAgLy8g6LCD5pW0WOi9tOiMg+WbtOS7peaYvuekuuWujOaVtOabsue6vwogICAgICBpZiAoZmluYWxDdXJ2ZURhdGEubGVuZ3RoID4gMCkgewogICAgICAgIHRoaXMueEF4aXNfbWluID0gTWF0aC5taW4odGhpcy54QXhpc19taW4sIGZpbmFsQ3VydmVEYXRhWzBdWzBdKTsKICAgICAgICB0aGlzLnhBeGlzX21heCA9IE1hdGgubWF4KHRoaXMueEF4aXNfbWF4LCBmaW5hbEN1cnZlRGF0YVtmaW5hbEN1cnZlRGF0YS5sZW5ndGggLSAxXVswXSk7CiAgICAgIH0KICAgICAgCiAgICAgIHRoaXMucmVuZGVyQ2hhcnQodGhpcy54QXhpc19taW4sIHRoaXMueEF4aXNfbWF4KTsKICAgICAgCiAgICAgIHRoaXMubG9nZ2VyLmluZm8oJ0NoYXJ0LUZvY3VzLnZ1ZSB8IOe6v+aAp+absue6v+aVsOaNrueCueW3sueUn+aIkOW5tua4suafk+WujOaIkCcpOwogICAgfSwKICAgIAogICAgLy8g5ouf5ZCI5LqM5qyh5puy57q/5pyA5bCP54K5CiAgICBmaXRRdWFkcmF0aWNDdXJ2ZV9taW5Qb2ludChkYXRhU3RyaW5nKSB7CiAgICAgIHRoaXMubG9nZ2VyLmluZm8oJ0NoYXJ0LUZvY3VzLnZ1ZSB8IOaOpeaUtuacgOWwj+eCueaVsOaNrjonLCBkYXRhU3RyaW5nKTsKICAgICAgCiAgICAgIGNvbnN0IHBhcnRzID0gZGF0YVN0cmluZy5zcGxpdCgnOicpOwogICAgICBpZiAocGFydHMubGVuZ3RoID49IDMpIHsKICAgICAgICBjb25zdCBiZXN0UG9zaXRpb24gPSBwYXJzZUZsb2F0KHBhcnRzWzFdKTsKICAgICAgICBjb25zdCBtaW5IRlIgPSBwYXJzZUZsb2F0KHBhcnRzWzJdKTsKICAgICAgICAKICAgICAgICAvLyDmm7TmlrDmlofmnKzmoYbmmL7npLoKICAgICAgICB0aGlzLnF1YWRyYXRpY1Jlc3VsdC5iZXN0UG9zaXRpb24gPSBiZXN0UG9zaXRpb24udG9GaXhlZCgyKTsKICAgICAgICB0aGlzLnF1YWRyYXRpY1Jlc3VsdC5taW5IRlIgPSBtaW5IRlIudG9GaXhlZCgzKTsKICAgICAgICB0aGlzLnF1YWRyYXRpY1Jlc3VsdC5zaG93ID0gdHJ1ZTsKICAgICAgICAKICAgICAgICAvLyDmt7vliqDmnIDlsI/ngrnliLDlm77ooagKICAgICAgICB0aGlzLmNoYXJ0RGF0YTMgPSBbXTsKICAgICAgICB0aGlzLmNoYXJ0RGF0YTMucHVzaChbYmVzdFBvc2l0aW9uLCBtaW5IRlJdKTsKICAgICAgICB0aGlzLnJlbmRlckNoYXJ0KHRoaXMueEF4aXNfbWluLCB0aGlzLnhBeGlzX21heCk7CiAgICAgICAgCiAgICAgICAgdGhpcy5sb2dnZXIuaW5mbygnQ2hhcnQtRm9jdXMudnVlIHwg5pyA5bCP54K55L+h5oGv5bey5pu05pawOicsIHsgYmVzdFBvc2l0aW9uLCBtaW5IRlIgfSk7CiAgICAgIH0KICAgIH0sCiAgICBzZXRGb2N1c0NoYXJ0UmFuZ2UobG93ZXJCb3VuZCwgdXBwZXJCb3VuZCkgewogICAgICB0aGlzLnhfbWluID0gbG93ZXJCb3VuZDsKICAgICAgdGhpcy54X21heCA9IHVwcGVyQm91bmQ7CiAgICB9LAogICAgCiAgICAvLyA9PT09PT09PT09PT09PT09PT09PSDlvILluLjngrnmo4DmtYvmlrnms5UgPT09PT09PT09PT09PT09PT09PT0KICAgIAogICAgLyoqCiAgICAgKiDmmbrog73lvILluLjngrnmo4DmtYsKICAgICAqIOS9v+eUqOWkmuenjeaWueazleajgOa1i+W5tuWOu+mZpOW8guW4uOeCuQogICAgICovCiAgICByZW1vdmVPdXRsaWVycyhkYXRhUG9pbnRzKSB7CiAgICAgIGlmIChkYXRhUG9pbnRzLmxlbmd0aCA8IDQpIHsKICAgICAgICByZXR1cm4gZGF0YVBvaW50czsgLy8g5pWw5o2u54K55aSq5bCR77yM5LiN6L+b6KGM5byC5bi45YC85qOA5rWLCiAgICAgIH0KICAgICAgCiAgICAgIHRoaXMubG9nZ2VyLmluZm8oJ0NoYXJ0LUZvY3VzLnZ1ZSB8IOW8gOWni+aZuuiDveW8guW4uOWAvOajgOa1i++8jOWOn+Wni+aVsOaNrueCueaVsOmHjzonLCBkYXRhUG9pbnRzLmxlbmd0aCk7CiAgICAgIAogICAgICAvLyDmlrnms5Ux77ya5Z+65LqO5LqM5qyh5puy57q/5ouf5ZCI55qE5q6L5beu5YiG5p6QCiAgICAgIGNvbnN0IGNsZWFuRGF0YTEgPSB0aGlzLnJlbW92ZU91dGxpZXJzQnlSZXNpZHVhbChkYXRhUG9pbnRzKTsKICAgICAgCiAgICAgIC8vIOaWueazlTLvvJrln7rkuo5IRlLnu5/orqHliIbluIPnmoRJUVLmlrnms5UKICAgICAgY29uc3QgY2xlYW5EYXRhMiA9IHRoaXMucmVtb3ZlT3V0bGllcnNCeUlRUihkYXRhUG9pbnRzKTsKICAgICAgCiAgICAgIC8vIOaWueazlTPvvJrln7rkuo7kvY3nva7liIbluIPnmoTlvILluLjmo4DmtYsKICAgICAgY29uc3QgY2xlYW5EYXRhMyA9IHRoaXMucmVtb3ZlT3V0bGllcnNCeVBvc2l0aW9uKGRhdGFQb2ludHMpOwogICAgICAKICAgICAgLy8g6YCJ5oup5L+d55WZ5pyA5aSa5pWw5o2u54K555qE5pa55rOV77yM5L2G56Gu5L+d6Iez5bCR5pyJM+S4quaVsOaNrueCuQogICAgICBsZXQgYmVzdENsZWFuRGF0YSA9IGNsZWFuRGF0YTE7CiAgICAgIGlmIChjbGVhbkRhdGEyLmxlbmd0aCA+IGJlc3RDbGVhbkRhdGEubGVuZ3RoICYmIGNsZWFuRGF0YTIubGVuZ3RoID49IDMpIHsKICAgICAgICBiZXN0Q2xlYW5EYXRhID0gY2xlYW5EYXRhMjsKICAgICAgfQogICAgICBpZiAoY2xlYW5EYXRhMy5sZW5ndGggPiBiZXN0Q2xlYW5EYXRhLmxlbmd0aCAmJiBjbGVhbkRhdGEzLmxlbmd0aCA+PSAzKSB7CiAgICAgICAgYmVzdENsZWFuRGF0YSA9IGNsZWFuRGF0YTM7CiAgICAgIH0KICAgICAgCiAgICAgIC8vIOWmguaenOaJgOacieaWueazlemDvei/h+a7pOW+l+WkquS4peagvO+8jOS9v+eUqOacgOWuveadvueahOaWueazlQogICAgICBpZiAoYmVzdENsZWFuRGF0YS5sZW5ndGggPCAzKSB7CiAgICAgICAgdGhpcy5sb2dnZXIud2FybignQ2hhcnQtRm9jdXMudnVlIHwg5omA5pyJ5byC5bi45YC85qOA5rWL5pa55rOV6YO96L+H5LqO5Lil5qC877yM5L2/55So5pyA5a695p2+55qE5pa55rOVJyk7CiAgICAgICAgYmVzdENsZWFuRGF0YSA9IGNsZWFuRGF0YTI7IC8vIElRUuaWueazleebuOWvueWuveadvgogICAgICAgIGlmIChiZXN0Q2xlYW5EYXRhLmxlbmd0aCA8IDMpIHsKICAgICAgICAgIGJlc3RDbGVhbkRhdGEgPSBkYXRhUG9pbnRzOyAvLyDlpoLmnpzov5jmmK/kuI3lpJ/vvIzov5Tlm57ljp/lp4vmlbDmja4KICAgICAgICB9CiAgICAgIH0KICAgICAgCiAgICAgIHRoaXMubG9nZ2VyLmluZm8oJ0NoYXJ0LUZvY3VzLnZ1ZSB8IOaZuuiDveW8guW4uOWAvOajgOa1i+WujOaIkDog5Y6f5aeL5pWw5o2uJywgZGF0YVBvaW50cy5sZW5ndGgsICfkuKrngrnvvIzmuIXnkIblkI4nLCBiZXN0Q2xlYW5EYXRhLmxlbmd0aCwgJ+S4queCuScpOwogICAgICAKICAgICAgcmV0dXJuIGJlc3RDbGVhbkRhdGE7CiAgICB9LAogICAgCiAgICAvKioKICAgICAqIOWfuuS6juS6jOasoeabsue6v+aLn+WQiOaui+W3rueahOW8guW4uOWAvOajgOa1iwogICAgICog5rOo5oSP77ya546w5Zyo5Li76KaB5L6d6LWW5ZCO56uv5ouf5ZCI57uT5p6c77yM5q2k5pa55rOV5LuF5L2c5Li65aSH55SoCiAgICAgKi8KICAgIHJlbW92ZU91dGxpZXJzQnlSZXNpZHVhbChkYXRhUG9pbnRzKSB7CiAgICAgIGlmIChkYXRhUG9pbnRzLmxlbmd0aCA8IDQpIHsKICAgICAgICByZXR1cm4gZGF0YVBvaW50czsgLy8g6ZyA6KaB6Iez5bCRNOS4queCueaJjeiDvei/m+ihjOS6jOasoeaLn+WQiAogICAgICB9CiAgICAgIAogICAgICAvLyDnroDljJblvILluLjlgLzmo4DmtYvvvJrnm7TmjqXkvb/nlKhJUVLmlrnms5XvvIzkuI3lho3ov5vooYzkuozmrKHmi5/lkIgKICAgICAgY29uc3QgcHJlbGltaW5hcnlDbGVhbiA9IHRoaXMucmVtb3ZlT3V0bGllcnNCeUlRUihkYXRhUG9pbnRzKTsKICAgICAgaWYgKHByZWxpbWluYXJ5Q2xlYW4ubGVuZ3RoIDwgMykgewogICAgICAgIHJldHVybiBkYXRhUG9pbnRzOwogICAgICB9CiAgICAgIAogICAgICAvLyDkuI3lho3ov5vooYzliY3nq6/mi5/lkIjvvIznm7TmjqXov5Tlm55JUVLmuIXnkIblkI7nmoTmlbDmja4KICAgICAgdGhpcy5sb2dnZXIuaW5mbygnQ2hhcnQtRm9jdXMudnVlIHwg5byC5bi45YC85qOA5rWL77ya5L2/55SoSVFS5pa55rOV77yM5LiN5YaN6L+b6KGM5YmN56uv5ouf5ZCIJyk7CiAgICAgIHJldHVybiBwcmVsaW1pbmFyeUNsZWFuOwogICAgfSwKICAgIAogICAgLyoqCiAgICAgKiDln7rkuo5IRlLnu5/orqHliIbluIPnmoRJUVLlvILluLjlgLzmo4DmtYsKICAgICAqLwogICAgcmVtb3ZlT3V0bGllcnNCeUlRUihkYXRhUG9pbnRzKSB7CiAgICAgIC8vIOiuoeeul0hGUueahOe7n+iuoeS/oeaBrwogICAgICBjb25zdCBoZnJWYWx1ZXMgPSBkYXRhUG9pbnRzLm1hcChwb2ludCA9PiBwb2ludFsxXSk7CiAgICAgIAogICAgICAvLyDmjpLluo8KICAgICAgY29uc3Qgc29ydGVkSGZyVmFsdWVzID0gWy4uLmhmclZhbHVlc10uc29ydCgoYSwgYikgPT4gYSAtIGIpOwogICAgICAKICAgICAgLy8g6K6h566X5Zub5YiG5L2N5pWwCiAgICAgIGNvbnN0IG4gPSBzb3J0ZWRIZnJWYWx1ZXMubGVuZ3RoOwogICAgICBjb25zdCBxMSA9IHNvcnRlZEhmclZhbHVlc1tNYXRoLmZsb29yKG4gLyA0KV07CiAgICAgIGNvbnN0IHEzID0gc29ydGVkSGZyVmFsdWVzW01hdGguZmxvb3IoMyAqIG4gLyA0KV07CiAgICAgIGNvbnN0IGlxciA9IHEzIC0gcTE7CiAgICAgIAogICAgICAvLyDlrprkuYnlvILluLjlgLzovrnnlYzvvIjkvb/nlKgy5YCNSVFS77yM5q+UMS415YCN5pu05a695p2+77yJCiAgICAgIGNvbnN0IGxvd2VyQm91bmQgPSBxMSAtIDIuMCAqIGlxcjsKICAgICAgY29uc3QgdXBwZXJCb3VuZCA9IHEzICsgMi4wICogaXFyOwogICAgICAKICAgICAgLy8g6L+H5ruk5byC5bi45YC8CiAgICAgIGNvbnN0IGNsZWFuRGF0YSA9IGRhdGFQb2ludHMuZmlsdGVyKHBvaW50ID0+IAogICAgICAgIHBvaW50WzFdID49IGxvd2VyQm91bmQgJiYgcG9pbnRbMV0gPD0gdXBwZXJCb3VuZAogICAgICApOwogICAgICAKICAgICAgdGhpcy5sb2dnZXIuaW5mbygnQ2hhcnQtRm9jdXMudnVlIHwg5Z+65LqOSVFS55qE5byC5bi45YC85qOA5rWLOiDljp/lp4vmlbDmja4nLCBkYXRhUG9pbnRzLmxlbmd0aCwgJ+S4queCue+8jOa4heeQhuWQjicsIGNsZWFuRGF0YS5sZW5ndGgsICfkuKrngrknKTsKICAgICAgCiAgICAgIHJldHVybiBjbGVhbkRhdGE7CiAgICB9LAogICAgCiAgICAvKioKICAgICAqIOWfuuS6juS9jee9ruWIhuW4g+eahOW8guW4uOWAvOajgOa1iwogICAgICovCiAgICByZW1vdmVPdXRsaWVyc0J5UG9zaXRpb24oZGF0YVBvaW50cykgewogICAgICBpZiAoZGF0YVBvaW50cy5sZW5ndGggPCA0KSB7CiAgICAgICAgcmV0dXJuIGRhdGFQb2ludHM7CiAgICAgIH0KICAgICAgCiAgICAgIC8vIOaMieS9jee9ruaOkuW6jwogICAgICBjb25zdCBzb3J0ZWREYXRhID0gWy4uLmRhdGFQb2ludHNdLnNvcnQoKGEsIGIpID0+IGFbMF0gLSBiWzBdKTsKICAgICAgCiAgICAgIC8vIOiuoeeul+ebuOmCu+eCueS5i+mXtOeahOi3neemuwogICAgICBjb25zdCBkaXN0YW5jZXMgPSBbXTsKICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBzb3J0ZWREYXRhLmxlbmd0aDsgaSsrKSB7CiAgICAgICAgY29uc3QgZGlzdCA9IHNvcnRlZERhdGFbaV1bMF0gLSBzb3J0ZWREYXRhW2ktMV1bMF07CiAgICAgICAgZGlzdGFuY2VzLnB1c2goZGlzdCk7CiAgICAgIH0KICAgICAgCiAgICAgIC8vIOiuoeeul+i3neemu+eahOe7n+iuoeS/oeaBrwogICAgICBjb25zdCBzb3J0ZWREaXN0YW5jZXMgPSBbLi4uZGlzdGFuY2VzXS5zb3J0KChhLCBiKSA9PiBhIC0gYik7CiAgICAgIGNvbnN0IG4gPSBzb3J0ZWREaXN0YW5jZXMubGVuZ3RoOwogICAgICBjb25zdCBtZWRpYW5EaXN0YW5jZSA9IHNvcnRlZERpc3RhbmNlc1tNYXRoLmZsb29yKG4gLyAyKV07CiAgICAgIGNvbnN0IHEzID0gc29ydGVkRGlzdGFuY2VzW01hdGguZmxvb3IoMyAqIG4gLyA0KV07CiAgICAgIGNvbnN0IHRocmVzaG9sZCA9IHEzICsgMS41ICogKHEzIC0gbWVkaWFuRGlzdGFuY2UpOwogICAgICAKICAgICAgLy8g6K+G5Yir5L2N572u5byC5bi455qE54K5CiAgICAgIGNvbnN0IGNsZWFuRGF0YSA9IFtdOwogICAgICBjbGVhbkRhdGEucHVzaChzb3J0ZWREYXRhWzBdKTsgLy8g56ys5LiA5Liq54K55oC75piv5L+d55WZCiAgICAgIAogICAgICBmb3IgKGxldCBpID0gMTsgaSA8IHNvcnRlZERhdGEubGVuZ3RoOyBpKyspIHsKICAgICAgICBjb25zdCBkaXN0ID0gc29ydGVkRGF0YVtpXVswXSAtIHNvcnRlZERhdGFbaS0xXVswXTsKICAgICAgICBpZiAoZGlzdCA8PSB0aHJlc2hvbGQpIHsKICAgICAgICAgIGNsZWFuRGF0YS5wdXNoKHNvcnRlZERhdGFbaV0pOwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAvLyDmo4Dmn6XmmK/lkKbmmK/lraTnq4vngrnvvIjliY3lkI7ot53nprvpg73lvojlpKfvvIkKICAgICAgICAgIGxldCBpc0lzb2xhdGVkID0gdHJ1ZTsKICAgICAgICAgIGlmIChpID4gMSkgewogICAgICAgICAgICBjb25zdCBwcmV2RGlzdCA9IHNvcnRlZERhdGFbaS0xXVswXSAtIHNvcnRlZERhdGFbaS0yXVswXTsKICAgICAgICAgICAgaWYgKHByZXZEaXN0IDw9IHRocmVzaG9sZCkgaXNJc29sYXRlZCA9IGZhbHNlOwogICAgICAgICAgfQogICAgICAgICAgaWYgKGkgPCBzb3J0ZWREYXRhLmxlbmd0aCAtIDEpIHsKICAgICAgICAgICAgY29uc3QgbmV4dERpc3QgPSBzb3J0ZWREYXRhW2krMV1bMF0gLSBzb3J0ZWREYXRhW2ldWzBdOwogICAgICAgICAgICBpZiAobmV4dERpc3QgPD0gdGhyZXNob2xkKSBpc0lzb2xhdGVkID0gZmFsc2U7CiAgICAgICAgICB9CiAgICAgICAgICAKICAgICAgICAgIGlmICghaXNJc29sYXRlZCkgewogICAgICAgICAgICBjbGVhbkRhdGEucHVzaChzb3J0ZWREYXRhW2ldKTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgIH0KICAgICAgCiAgICAgIHRoaXMubG9nZ2VyLmluZm8oJ0NoYXJ0LUZvY3VzLnZ1ZSB8IOWfuuS6juS9jee9rueahOW8guW4uOWAvOajgOa1izog5Y6f5aeL5pWw5o2uJywgZGF0YVBvaW50cy5sZW5ndGgsICfkuKrngrnvvIzmuIXnkIblkI4nLCBjbGVhbkRhdGEubGVuZ3RoLCAn5Liq54K5Jyk7CiAgICAgIAogICAgICByZXR1cm4gY2xlYW5EYXRhOwogICAgfSwKICAgIAogICAgLyoqCiAgICAgKiDmiafooYzkuozmrKHmm7Lnur/mi5/lkIgKICAgICAqIOazqOaEj++8mueOsOWcqOS4u+imgeS+nei1luWQjuerr+aLn+WQiOe7k+aenO+8jOatpOaWueazleS7heeUqOS6jua1i+ivleWSjOiwg+ivlQogICAgICog6L+U5Zue5ouf5ZCI57O75pWwIHthLCBiLCBjfQogICAgICovCiAgICBwZXJmb3JtUXVhZHJhdGljRml0KGRhdGFQb2ludHMpIHsKICAgICAgaWYgKGRhdGFQb2ludHMubGVuZ3RoIDwgMykgewogICAgICAgIHJldHVybiBudWxsOwogICAgICB9CiAgICAgIAogICAgICB0aGlzLmxvZ2dlci5pbmZvKCdDaGFydC1Gb2N1cy52dWUgfCDlvIDlp4vkuozmrKHmm7Lnur/mi5/lkIjvvIzmlbDmja7ngrnmlbDph486JywgZGF0YVBvaW50cy5sZW5ndGgpOwogICAgICAKICAgICAgLy8g5qCH5YeG5YyW5Z2Q5qCH77ya5bCG5L2N572u6L2s5o2i5Li655u45a+55Z2Q5qCHCiAgICAgIGNvbnN0IG1pblBvcyA9IE1hdGgubWluKC4uLmRhdGFQb2ludHMubWFwKHBvaW50ID0+IHBvaW50WzBdKSk7CiAgICAgIHRoaXMubG9nZ2VyLmRlYnVnKCdDaGFydC1Gb2N1cy52dWUgfCDmnIDlsI/kvY3nva4gKOWBj+enu+mHjyk6JywgbWluUG9zKTsKICAgICAgCiAgICAgIC8vIOaehOW7uuacgOWwj+S6jOS5mOazleato+inhOaWueeoi+e7hAogICAgICBsZXQgc3VtX3g0ID0gMCwgc3VtX3gzID0gMCwgc3VtX3gyID0gMCwgc3VtX3ggPSAwLCBzdW1fMSA9IDA7CiAgICAgIGxldCBzdW1feDJ5ID0gMCwgc3VtX3h5ID0gMCwgc3VtX3kgPSAwOwogICAgICAKICAgICAgZm9yIChjb25zdCBwb2ludCBvZiBkYXRhUG9pbnRzKSB7CiAgICAgICAgY29uc3QgeCA9IHBvaW50WzBdIC0gbWluUG9zOyAvLyDnm7jlr7nlnZDmoIcKICAgICAgICBjb25zdCB5ID0gcG9pbnRbMV07CiAgICAgICAgCiAgICAgICAgY29uc3QgeDIgPSB4ICogeDsKICAgICAgICBjb25zdCB4MyA9IHgyICogeDsKICAgICAgICBjb25zdCB4NCA9IHgzICogeDsKICAgICAgICAKICAgICAgICBzdW1feDQgKz0geDQ7CiAgICAgICAgc3VtX3gzICs9IHgzOwogICAgICAgIHN1bV94MiArPSB4MjsKICAgICAgICBzdW1feCArPSB4OwogICAgICAgIHN1bV8xICs9IDE7CiAgICAgICAgCiAgICAgICAgc3VtX3gyeSArPSB4MiAqIHk7CiAgICAgICAgc3VtX3h5ICs9IHggKiB5OwogICAgICAgIHN1bV95ICs9IHk7CiAgICAgIH0KICAgICAgCiAgICAgIHRoaXMubG9nZ2VyLmRlYnVnKCdDaGFydC1Gb2N1cy52dWUgfCDmi5/lkIjnu5/orqHph486JywgewogICAgICAgIHN1bV94NCwgc3VtX3gzLCBzdW1feDIsIHN1bV94LCBzdW1fMSwKICAgICAgICBzdW1feDJ5LCBzdW1feHksIHN1bV95CiAgICAgIH0pOwogICAgICAKICAgICAgLy8g5p6E5bu657O75pWw55+p6Zi15ZKM5bi45pWw5ZCR6YePCiAgICAgIGNvbnN0IG1hdHJpeCA9IFsKICAgICAgICBbc3VtX3g0LCBzdW1feDMsIHN1bV94Ml0sCiAgICAgICAgW3N1bV94Mywgc3VtX3gyLCBzdW1feF0sCiAgICAgICAgW3N1bV94Miwgc3VtX3gsIHN1bV8xXQogICAgICBdOwogICAgICAKICAgICAgY29uc3QgY29uc3RhbnRzID0gW3N1bV94MnksIHN1bV94eSwgc3VtX3ldOwogICAgICAKICAgICAgdGhpcy5sb2dnZXIuZGVidWcoJ0NoYXJ0LUZvY3VzLnZ1ZSB8IOezu+aVsOefqemYtTonLCBtYXRyaXgpOwogICAgICB0aGlzLmxvZ2dlci5kZWJ1ZygnQ2hhcnQtRm9jdXMudnVlIHwg5bi45pWw5ZCR6YePOicsIGNvbnN0YW50cyk7CiAgICAgIAogICAgICAvLyDmsYLop6Pnur/mgKfmlrnnqIvnu4TvvIjkvb/nlKjpq5jmlq/mtojlhYPms5XvvIkKICAgICAgY29uc3QgY29lZmZpY2llbnRzID0gdGhpcy5zb2x2ZUxpbmVhclN5c3RlbShtYXRyaXgsIGNvbnN0YW50cyk7CiAgICAgIGlmICghY29lZmZpY2llbnRzKSB7CiAgICAgICAgdGhpcy5sb2dnZXIuZXJyb3IoJ0NoYXJ0LUZvY3VzLnZ1ZSB8IOe6v+aAp+aWueeoi+e7hOaxguino+Wksei0pScpOwogICAgICAgIHJldHVybiBudWxsOwogICAgICB9CiAgICAgIAogICAgICBjb25zdCByZXN1bHQgPSB7CiAgICAgICAgYTogY29lZmZpY2llbnRzWzBdLAogICAgICAgIGI6IGNvZWZmaWNpZW50c1sxXSwKICAgICAgICBjOiBjb2VmZmljaWVudHNbMl0KICAgICAgfTsKICAgICAgCiAgICAgIHRoaXMubG9nZ2VyLmluZm8oJ0NoYXJ0LUZvY3VzLnZ1ZSB8IOaLn+WQiOezu+aVsDonLCByZXN1bHQpOwogICAgICAKICAgICAgLy8g6aqM6K+B5ouf5ZCI57uT5p6cCiAgICAgIGlmICghaXNGaW5pdGUocmVzdWx0LmEpIHx8ICFpc0Zpbml0ZShyZXN1bHQuYikgfHwgIWlzRmluaXRlKHJlc3VsdC5jKSkgewogICAgICAgIHRoaXMubG9nZ2VyLmVycm9yKCdDaGFydC1Gb2N1cy52dWUgfCDmi5/lkIjns7vmlbDljIXlkKvml6DmlYjlgLwnKTsKICAgICAgICByZXR1cm4gbnVsbDsKICAgICAgfQogICAgICAKICAgICAgLy8g5qOA5p+l5piv5ZCm5Li65pyJ5pWI55qE5LqM5qyh5puy57q/77yIYeS4jeS4ujDvvIkKICAgICAgaWYgKE1hdGguYWJzKHJlc3VsdC5hKSA8IDFlLTEwKSB7CiAgICAgICAgdGhpcy5sb2dnZXIud2FybignQ2hhcnQtRm9jdXMudnVlIHwg6K2m5ZGK77ya5LqM5qyh6aG557O75pWw5o6l6L+RMO+8jOWPr+iDveaYr+ebtOe6v+aLn+WQiCcpOwogICAgICB9CiAgICAgIAogICAgICByZXR1cm4gcmVzdWx0OwogICAgfSwKICAgIAogICAgLyoqCiAgICAgKiDmsYLop6MzeDPnur/mgKfmlrnnqIvnu4QKICAgICAqLwogICAgc29sdmVMaW5lYXJTeXN0ZW0obWF0cml4LCBjb25zdGFudHMpIHsKICAgICAgLy8g6auY5pav5raI5YWD5rOV5rGC6Kej57q/5oCn5pa556iL57uECiAgICAgIGNvbnN0IGF1Z21lbnRlZCA9IFtdOwogICAgICAKICAgICAgLy8g5p6E5bu65aKe5bm/55+p6Zi1CiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMzsgaSsrKSB7CiAgICAgICAgYXVnbWVudGVkW2ldID0gWy4uLm1hdHJpeFtpXSwgY29uc3RhbnRzW2ldXTsKICAgICAgfQogICAgICAKICAgICAgLy8g5YmN5ZCR5raI5YWDCiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMzsgaSsrKSB7CiAgICAgICAgLy8g5a+75om+5Li75YWDCiAgICAgICAgbGV0IG1heFJvdyA9IGk7CiAgICAgICAgZm9yIChsZXQgayA9IGkgKyAxOyBrIDwgMzsgaysrKSB7CiAgICAgICAgICBpZiAoTWF0aC5hYnMoYXVnbWVudGVkW2tdW2ldKSA+IE1hdGguYWJzKGF1Z21lbnRlZFttYXhSb3ddW2ldKSkgewogICAgICAgICAgICBtYXhSb3cgPSBrOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICAKICAgICAgICAvLyDkuqTmjaLooYwKICAgICAgICBpZiAobWF4Um93ICE9PSBpKSB7CiAgICAgICAgICBbYXVnbWVudGVkW2ldLCBhdWdtZW50ZWRbbWF4Um93XV0gPSBbYXVnbWVudGVkW21heFJvd10sIGF1Z21lbnRlZFtpXV07CiAgICAgICAgfQogICAgICAgIAogICAgICAgIC8vIOajgOafpeS4u+WFg+aYr+WQpuS4uumbtgogICAgICAgIGlmIChNYXRoLmFicyhhdWdtZW50ZWRbaV1baV0pIDwgMWUtMTApIHsKICAgICAgICAgIHRoaXMubG9nZ2VyLmVycm9yKCdDaGFydC1Gb2N1cy52dWUgfCDnur/mgKfmlrnnqIvnu4TlpYflvILvvIzml6Dms5XmsYLop6MnKTsKICAgICAgICAgIHJldHVybiBudWxsOwogICAgICAgIH0KICAgICAgICAKICAgICAgICAvLyDmtojlhYMKICAgICAgICBmb3IgKGxldCBrID0gaSArIDE7IGsgPCAzOyBrKyspIHsKICAgICAgICAgIGNvbnN0IGZhY3RvciA9IGF1Z21lbnRlZFtrXVtpXSAvIGF1Z21lbnRlZFtpXVtpXTsKICAgICAgICAgIGZvciAobGV0IGogPSBpOyBqIDwgNDsgaisrKSB7CiAgICAgICAgICAgIGF1Z21lbnRlZFtrXVtqXSAtPSBmYWN0b3IgKiBhdWdtZW50ZWRbaV1bal07CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICB9CiAgICAgIAogICAgICAvLyDlm57ku6PmsYLop6MKICAgICAgY29uc3Qgc29sdXRpb24gPSBbMCwgMCwgMF07CiAgICAgIGZvciAobGV0IGkgPSAyOyBpID49IDA7IGktLSkgewogICAgICAgIHNvbHV0aW9uW2ldID0gYXVnbWVudGVkW2ldWzNdOwogICAgICAgIGZvciAobGV0IGogPSBpICsgMTsgaiA8IDM7IGorKykgewogICAgICAgICAgc29sdXRpb25baV0gLT0gYXVnbWVudGVkW2ldW2pdICogc29sdXRpb25bal07CiAgICAgICAgfQogICAgICAgIHNvbHV0aW9uW2ldIC89IGF1Z21lbnRlZFtpXVtpXTsKICAgICAgfQogICAgICAKICAgICAgcmV0dXJuIHNvbHV0aW9uOwogICAgfSwKICAgIAogICAgLy8gPT09PT09PT09PT09PT09PT09PT0g5rWL6K+V5ZKM6LCD6K+V5pa55rOVID09PT09PT09PT09PT09PT09PT09CiAgICAKICAgIC8qKgogICAgICog5rWL6K+V5ZCO56uv5pWw5o2u5o6l5pS25Yqf6IO9CiAgICAgKiDmqKHmi5/lkI7nq6/lj5HpgIHnmoTmi5/lkIjmlbDmja7mnaXmtYvor5XliY3nq6/lpITnkIYKICAgICAqLwogICAgdGVzdEJhY2tlbmREYXRhUmVjZXB0aW9uKCkgewogICAgICB0aGlzLmxvZ2dlci5pbmZvKCdDaGFydC1Gb2N1cy52dWUgfCDlvIDlp4vmtYvor5XlkI7nq6/mlbDmja7mjqXmlLblip/og70nKTsKICAgICAgY29uc29sZS5sb2coJ0NoYXJ0LUZvY3VzLnZ1ZSB8IOW8gOWni+a1i+ivleWQjuerr+aVsOaNruaOpeaUtuWKn+iDvScpOwogICAgICAKICAgICAgLy8g5qih5ouf5ZCO56uv5Y+R6YCB55qE5pWw5o2u5qC85byPCiAgICAgIGNvbnN0IHRlc3REYXRhID0gImZpdFF1YWRyYXRpY0N1cnZlOjAuMDAwMDAxOi0wLjAyOjUuMDoxNTczMS4xMzoxLjkzMCI7CiAgICAgIHRoaXMubG9nZ2VyLmluZm8oJ0NoYXJ0LUZvY3VzLnZ1ZSB8IOaooeaLn+WQjuerr+aVsOaNrjonLCB0ZXN0RGF0YSk7CiAgICAgIGNvbnNvbGUubG9nKCdDaGFydC1Gb2N1cy52dWUgfCDmqKHmi5/lkI7nq6/mlbDmja46JywgdGVzdERhdGEpOwogICAgICAKICAgICAgLy8g6LCD55So5ouf5ZCI5pa55rOVCiAgICAgIHRoaXMuZml0UXVhZHJhdGljQ3VydmUodGVzdERhdGEpOwogICAgfSwKICAgIAogICAgLyoqCiAgICAgKiDmtYvor5XkuozmrKHmm7Lnur/mi5/lkIjlip/og70KICAgICAqIOazqOaEj++8mueOsOWcqOS4u+imgeS+nei1luWQjuerr+aLn+WQiOe7k+aenO+8jOatpOaWueazleS7heeUqOS6jua1i+ivleWJjeerr+aLn+WQiOeul+azlQogICAgICog5L2/55So5qih5ouf5pWw5o2u6aqM6K+B5ouf5ZCI566X5rOV5piv5ZCm5q2j56GuCiAgICAgKi8KICAgIHRlc3RRdWFkcmF0aWNGaXR0aW5nKCkgewogICAgICB0aGlzLmxvZ2dlci5pbmZvKCdDaGFydC1Gb2N1cy52dWUgfCDlvIDlp4vmtYvor5XkuozmrKHmm7Lnur/mi5/lkIjlip/og70nKTsKICAgICAgCiAgICAgIC8vIOeUn+aIkOa1i+ivleaVsOaNru+8mnkgPSAwLjAwMDEgKiAoeCAtIDMwMDApXjIgKyAyLjAKICAgICAgY29uc3QgdGVzdERhdGEgPSBbXTsKICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxMDsgaSsrKSB7CiAgICAgICAgY29uc3QgeCA9IDIwMDAgKyBpICogMjAwOyAvLyDkvY3nva7ku44yMDAw5YiwMzgwMAogICAgICAgIGNvbnN0IHkgPSAwLjAwMDEgKiBNYXRoLnBvdyh4IC0gMzAwMCwgMikgKyAyLjAgKyAoTWF0aC5yYW5kb20oKSAtIDAuNSkgKiAwLjI7IC8vIOa3u+WKoOWZquWjsAogICAgICAgIHRlc3REYXRhLnB1c2goW3gsIHldKTsKICAgICAgfQogICAgICAKICAgICAgdGhpcy5sb2dnZXIuZGVidWcoJ0NoYXJ0LUZvY3VzLnZ1ZSB8IOa1i+ivleaVsOaNrjonLCB0ZXN0RGF0YSk7CiAgICAgIAogICAgICAvLyDmiafooYzmi5/lkIgKICAgICAgY29uc3QgZml0UmVzdWx0ID0gdGhpcy5wZXJmb3JtUXVhZHJhdGljRml0KHRlc3REYXRhKTsKICAgICAgaWYgKGZpdFJlc3VsdCkgewogICAgICAgIHRoaXMubG9nZ2VyLmluZm8oJ0NoYXJ0LUZvY3VzLnZ1ZSB8IOaLn+WQiOe7k+aenDonLCBmaXRSZXN1bHQpOwogICAgICAgIAogICAgICAgIC8vIOiuoeeul+eQhuiuuuacgOS9s+S9jee9ru+8iOW6lOivpeaYrzMwMDDvvIkKICAgICAgICBjb25zdCBtaW5Qb3MgPSBNYXRoLm1pbiguLi50ZXN0RGF0YS5tYXAocG9pbnQgPT4gcG9pbnRbMF0pKTsKICAgICAgICBjb25zdCB0aGVvcmV0aWNhbEJlc3RQb3MgPSAtZml0UmVzdWx0LmIgLyAoMiAqIGZpdFJlc3VsdC5hKSArIG1pblBvczsKICAgICAgICB0aGlzLmxvZ2dlci5pbmZvKCdDaGFydC1Gb2N1cy52dWUgfCDnkIborrrmnIDkvbPkvY3nva46JywgdGhlb3JldGljYWxCZXN0UG9zLCAn5pyf5pyb5YC8OiAzMDAwJyk7CiAgICAgICAgCiAgICAgICAgLy8g55Sf5oiQ5ouf5ZCI5puy57q/CiAgICAgICAgdGhpcy5nZW5lcmF0ZVF1YWRyYXRpY0N1cnZlKGZpdFJlc3VsdC5hLCBmaXRSZXN1bHQuYiwgZml0UmVzdWx0LmMsIHRoZW9yZXRpY2FsQmVzdFBvcyk7CiAgICAgICAgCiAgICAgICAgdGhpcy5sb2dnZXIuaW5mbygnQ2hhcnQtRm9jdXMudnVlIHwg5LqM5qyh5puy57q/5ouf5ZCI5rWL6K+V5a6M5oiQJyk7CiAgICAgIH0gZWxzZSB7CiAgICAgICAgdGhpcy5sb2dnZXIuZXJyb3IoJ0NoYXJ0LUZvY3VzLnZ1ZSB8IOS6jOasoeabsue6v+aLn+WQiOa1i+ivleWksei0pScpOwogICAgICB9CiAgICB9LAogICAgCiAgfQp9Cg=="},{"version":3,"sources":["Chart-Focus.vue"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA+CA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA","file":"Chart-Focus.vue","sourceRoot":"src/components","sourcesContent":["<template>\n  <div>\n    <div\n      ref=\"linechart\"\n      :style=\"{ width: containerMaxWidth + 'px', height: 80 + 'px' }\"\n      class=\"linechart-panel\"\n      @mousedown=\"startDrag\"\n      @mousemove=\"dragging\"\n      @mouseup=\"endDrag\"\n      @touchstart=\"startDrag\"\n      @touchmove=\"dragging\"\n      @touchend=\"endDrag\"\n    ></div>\n    \n    <!-- 对焦结果状态框 -->\n    <div class=\"focus-result-panel\" v-if=\"quadraticResult.show\">\n      <div class=\"panel-header\">\n        <div class=\"header-left\">\n          <div class=\"status-icon\" :class=\"{ 'success': !isHorizontalFit(), 'warning': isHorizontalFit() }\">\n            <i v-if=\"!isHorizontalFit()\" class=\"icon-check\">✓</i>\n            <i v-else class=\"icon-warning\">⚠</i>\n          </div>\n          <div class=\"panel-title\">对焦状态</div>\n        </div>\n        <div class=\"close-button\" @click=\"closePanel\">\n          <i class=\"icon-close\">×</i>\n        </div>\n      </div>\n      <div class=\"panel-content\">\n        <div class=\"status-row\">\n          <span class=\"label\">最佳位置</span>\n          <span class=\"value\" :class=\"{ 'error': isHorizontalFit() }\">{{ getBestPositionDisplay() }}</span>\n        </div>\n        <div class=\"status-row\">\n          <span class=\"label\">最小HFR</span>\n          <span class=\"value\">{{ quadraticResult.minHFR }}</span>\n        </div>\n        <div class=\"status-row\">\n          <span class=\"label\">数据点数</span>\n          <span class=\"value\">{{ validDataPointCount }}</span>\n        </div>\n      </div>\n    </div>\n  </div>\n</template>\n\n<script>\nimport * as echarts from 'echarts';\n\nexport default {\n  name: 'LineChart',\n  props: {\n    // 是否使用时间轴模式（也可通过总线 setFocusChartTimeMode 切换）\n    useTimeAxis: {\n      type: Boolean,\n      default: false\n    },\n    // 时间窗口长度（秒），仅在时间轴模式下生效\n    timeWindowSec: {\n      type: Number,\n      default: 60\n    }\n  },\n  data() {\n    return {\n      containerMaxWidth: 150,\n      // 非时间轴：散点数据（x 为电调位置）\n      chartData1_pos: [],\n      // 时间轴：散点数据（x 为时间戳）\n      chartData1_time: [],\n      chartData2: [],\n      chartData3: [],\n      chartData4: [], // 异常点数据\n      xAxis_min: 0,\n      xAxis_max: 6000,\n      yAxis_min: 0,\n      yAxis_max: 30,\n      range: 4,\n      currentX: 0,\n      HFRMax: 0,\n      isDragging: false,\n      startX: 0,\n      deltaX: 0,\n      x_min: -60000,\n      x_max: 60000,\n      // 时间轴模式\n      isTimeMode: false,\n      timeTicker: null,\n      // 可见性控制\n      isVisible: false,\n      ioObserver: null,\n      // 渲染调度\n      renderRafId: null,\n      renderScheduled: false,\n      pendingLowerBound: null,\n      pendingUpperBound: null,\n      // 调试日志开关\n      debugRenderLogs: false,\n      // 线条数据来源：若为 null 则使用 quadraticParams 动态采样\n      lineDataFromPoints: null,\n      quadraticParams: null, // { a,b,c,x0? }\n      // 二次拟合结果显示\n      quadraticResult: {\n        show: false,\n        a: '0.000000',\n        b: '0.000000',\n        c: '0.000000',\n        bestPosition: '0.00',\n        minHFR: '0.000'\n      },\n      // 日志记录器\n      logger: {\n        info: (msg, data) => console.log(msg, data || ''),\n        warn: (msg, data) => console.warn(msg, data || ''),\n        error: (msg, data) => console.error(msg, data || ''),\n        debug: (msg, data) => console.debug(msg, data || '')\n      }\n    };\n  },\n  computed: {\n    // 计算有效数据点数量\n    validDataPointCount() {\n      const currentData = this.isTimeMode ? this.chartData1_time : this.chartData1_pos;\n      return currentData.length;\n    },\n    // 计算异常点数据\n    outlierDataPoints() {\n      const currentData = this.isTimeMode ? this.chartData1_time : this.chartData1_pos;\n      if (currentData.length < 4) return [];\n      // 这里可以添加异常点检测逻辑，暂时返回空数组\n      return [];\n    }\n  },\n  mounted() {\n    // 根据可见性启动/停止时间推进\n    const el = this.$refs.linechart;\n    if (window && 'IntersectionObserver' in window && el) {\n      this.ioObserver = new IntersectionObserver((entries) => {\n        const e = entries[0];\n        this.isVisible = !!(e && e.isIntersecting);\n        this.updateTickerByVisibility();\n      }, { threshold: 0.01 });\n      this.ioObserver.observe(el);\n    } else {\n      // 回退：不可见性未知时视为可见\n      this.isVisible = true;\n    }\n    document.addEventListener('visibilitychange', this.updateTickerByVisibility);\n\n    // 初始化时间轴模式（由 prop 控制）\n    this.isTimeMode = !!this.useTimeAxis;\n    this.updateTickerByVisibility();\n  },\n  created() {\n    this.$bus.$on('FocusPosition', this.changeRange_x);\n    // this.$bus.$on('UpdateHFR', this.UpdateHFR);\n    this.$bus.$on('fitQuadraticCurve', this.fitQuadraticCurve);\n    this.$bus.$on('fitQuadraticCurve_minPoint', this.fitQuadraticCurve_minPoint);\n\n    this.$bus.$on('ClearfitQuadraticCurve', this.clearChartData2);\n    this.$bus.$on('ClearAllData', this.ClearAllData);\n    this.$bus.$on('ClearFineData', this.ClearFineData);\n    this.$bus.$on('updateFocusChartWidth', this.initChart);\n    this.$bus.$on('addData_Point', this.addData_Point);\n    this.$bus.$on('addMinPointData_Point', this.addMinPointData_Point);\n    this.$bus.$on('addLineData_Point', this.addLineData_Point);\n    this.$bus.$on('setFocusChartRange', this.setFocusChartRange);\n    // 新增：时间轴模式控制与点追加\n    this.$bus.$on('setFocusChartTimeMode', this.setTimeMode);\n    this.$bus.$on('addFwhmNow', this.addFwhmPointNow);\n\n  },\n  beforeDestroy() {\n    this.teardownBusAndTimers();\n  },\n  destroyed() {\n    this.teardownBusAndTimers();\n  },\n  methods: {\n    // 检查是否为水平拟合（线性拟合）\n    isHorizontalFit() {\n      return this.quadraticResult.a === \"0.000000\" || Math.abs(parseFloat(this.quadraticResult.a)) < 1e-10;\n    },\n    // 获取最佳位置显示文本\n    getBestPositionDisplay() {\n      if (this.isHorizontalFit()) {\n        return \"线性拟合\";\n      }\n      return this.quadraticResult.bestPosition;\n    },\n    // 关闭面板\n    closePanel() {\n      this.quadraticResult.show = false;\n    },\n    // 验证拟合系数的有效性\n    validateFitCoefficients(a, b, c) {\n      // 检查系数是否为有效数字\n      if (!isFinite(a) || !isFinite(b) || !isFinite(c)) {\n        return false;\n      }\n      // 检查是否为水平线拟合（a接近0）\n      if (Math.abs(a) < 1e-10) {\n        return false; // 水平线拟合\n      }\n      return true;\n    },\n    teardownBusAndTimers() {\n      this.$bus.$off('FocusPosition', this.changeRange_x);\n      this.$bus.$off('ClearfitQuadraticCurve', this.clearChartData2);\n      this.$bus.$off('ClearAllData', this.ClearAllData);\n      this.$bus.$off('updateFocusChartWidth', this.initChart);\n      this.$bus.$off('addData_Point', this.addData_Point);\n      this.$bus.$off('addMinPointData_Point', this.addMinPointData_Point);\n      this.$bus.$off('addLineData_Point', this.addLineData_Point);\n      this.$bus.$off('addQuadraticCurve', this.addLineData_Point);\n      this.$bus.$off('setFocusChartRange', this.setFocusChartRange);\n      this.$bus.$off('setFocusChartTimeMode', this.setTimeMode);\n      this.$bus.$off('addFwhmNow', this.addFwhmPointNow);\n      if (this.timeTicker) {\n        clearInterval(this.timeTicker);\n        this.timeTicker = null;\n      }\n      if (this.ioObserver) {\n        try { this.ioObserver.disconnect(); } catch (e) {}\n        this.ioObserver = null;\n      }\n      document.removeEventListener('visibilitychange', this.updateTickerByVisibility);\n    },\n    initChart(Width) {\n      this.containerMaxWidth = Width - 95;\n      const chartDom = this.$refs.linechart;\n      chartDom.style.width = this.containerMaxWidth + 'px';\n      this.myChart = echarts.init(chartDom);\n      this.renderChart(this.xAxis_min, this.xAxis_max);\n    },\n    startDrag(event) {\n      if (this.isTimeMode) return; // 时间轴模式下禁用拖拽\n      this.isDragging = true;\n      const x = this.getClientX(event);\n      if (typeof x === 'number') this.startX = x;\n    },\n    dragging(event) {\n      if (this.isDragging && !this.isTimeMode) {\n        const x = this.getClientX(event);\n        if (typeof x !== 'number') return;\n        this.deltaX = (x - this.startX) * 10;\n        this.startX = x;\n        const windowWidth = this.xAxis_max - this.xAxis_min;\n        // 计算新的范围并做边界裁剪\n        let newMin = this.xAxis_min - this.deltaX;\n        const minAllowed = this.x_min;\n        const maxAllowed = this.x_max - windowWidth;\n        if (maxAllowed < minAllowed) {\n          // 安全处理：若设置不合理，回退到不移动\n          newMin = this.x_min;\n        } else {\n          newMin = Math.max(minAllowed, Math.min(maxAllowed, newMin));\n        }\n        this.xAxis_min = newMin;\n        this.xAxis_max = newMin + windowWidth;\n        this.scheduleRender(this.xAxis_min, this.xAxis_max);\n      }\n    },\n    getClientX(e) {\n      if (e && e.touches && e.touches.length) return e.touches[0].clientX;\n      if (e && e.changedTouches && e.changedTouches.length) return e.changedTouches[0].clientX;\n      if (typeof e.clientX === 'number') return e.clientX;\n      return undefined;\n    },\n    endDrag() {\n      this.isDragging = false;\n      this.deltaX = 0;\n      // this.$bus.$emit('setTargetPosition', (this.xAxis_min + this.xAxis_max) / 2);\n    },\n    scheduleRender(lowerBound, upperBound) {\n      this.pendingLowerBound = lowerBound;\n      this.pendingUpperBound = upperBound;\n      if (this.renderScheduled) return;\n      this.renderScheduled = true;\n      const cb = () => {\n        this.renderRafId = null;\n        this.renderScheduled = false;\n        this.renderChart(this.pendingLowerBound, this.pendingUpperBound);\n      };\n      if (typeof window !== 'undefined' && window.requestAnimationFrame) {\n        this.renderRafId = window.requestAnimationFrame(cb);\n      } else {\n        // 回退：无 rAF 时，使用微任务降低阻塞\n        Promise.resolve().then(cb);\n      }\n    },\n    renderChart(lowerBound, upperBound) {\n      const data1 = this.isTimeMode ? this.chartData1_time : this.chartData1_pos;\n      const y_max = data1.length > 0 ? Math.max(...data1.map(item => item[1])) * 2 : this.yAxis_max;\n      // 线数据：若传入系数，则根据当前视图范围动态采样，避免拖动后断裂或消失\n      let decData = [];\n      if (!this.isTimeMode) {\n        if (this.lineDataFromPoints && Array.isArray(this.lineDataFromPoints)) {\n          decData = this.lineDataFromPoints;\n        } else if (this.quadraticParams) {\n          const { a, b, c, x0 } = this.quadraticParams;\n          if (isFinite(a) && isFinite(b) && isFinite(c)) {\n            decData = this.generateQuadraticData(a, b, c, lowerBound, upperBound, isFinite(x0) ? x0 : 0);\n          }\n        } else {\n          decData = this.chartData2; // 兼容旧逻辑\n        }\n      }\n      \n      // 调试日志\n      if (this.debugRenderLogs && this.isTimeMode && data1.length > 0) {\n        console.log('Chart-Focus: renderChart (time mode)', {\n          dataPoints: data1.length,\n          latestPoint: data1[data1.length - 1],\n          y_max: y_max\n        });\n      }\n      const optionXAxis = this.isTimeMode\n        ? {\n            type: 'time',\n            min: Date.now() - this.timeWindowSec * 1000,\n            max: Date.now(),\n            axisLabel: {\n              color: 'white',\n              fontSize: 5,\n              formatter: function (value) {\n                const d = new Date(value);\n                const pad = (n) => (n < 10 ? '0' + n : '' + n);\n                return pad(d.getHours()) + ':' + pad(d.getMinutes()) + ':' + pad(d.getSeconds());\n              }\n            },\n            axisLine: { lineStyle: { color: 'rgba(200, 200, 200, 0.5)' } },\n            splitLine: {\n              show: true,\n              lineStyle: { color: 'rgba(128, 128, 128, 0.5)', width: 1, type: 'solid' }\n            }\n          }\n        : {\n            type: 'value',\n            min: lowerBound,\n            max: upperBound,\n            axisLine: { lineStyle: { color: 'rgba(200, 200, 200, 0.5)' } },\n            axisLabel: { color: 'white', fontSize: 5 },\n            splitLine: { show: true, lineStyle: { color: 'rgba(128, 128, 128, 0.5)', width: 1, type: 'solid' } }\n          };\n      const option = {\n        grid: {\n          left: '0%',\n          right: '2%',\n          bottom: '0%',\n          top: '10%',\n          containLabel: true\n        },\n        xAxis: optionXAxis,\n        yAxis: {\n          min: this.yAxis_min,\n          max: y_max,\n          axisLine: {\n            lineStyle: {\n              color: 'rgba(200, 200, 200, 0.5)'  // y轴线颜色\n            }\n          },\n          axisLabel: {\n            color: 'white',\n            fontSize: 5\n          },\n          splitNumber: 3,\n          splitLine: {\n            show: true,\n            lineStyle: {\n              color: 'rgba(128, 128, 128, 0.5)',\n              width: 1,\n              type: 'solid'\n            }\n          }\n        },\n        series: [\n          {\n            name: 'HFR',\n            type: 'scatter',\n            data: data1,\n            itemStyle: {\n              color: 'red',\n              borderColor: 'white',\n              borderWidth: 1\n            },\n            symbolSize: 8\n          },\n          !this.isTimeMode ? {\n            name: 'Dec',\n            type: 'line',\n            data: decData,\n            itemStyle: {\n              color: 'yellow'\n            },\n            lineStyle: {\n              width: 3,\n              type: 'solid'\n            },\n            symbolSize: 0\n          } : null,\n          !this.isTimeMode ? {\n            name: 'minPoint',\n            type: 'scatter',\n            data: this.chartData3,\n            itemStyle: {\n              color: 'rgba(75, 155, 250, 0.7)'\n            },\n            symbolSize: 4\n          } : null,\n          !this.isTimeMode ? {\n            name: 'xMinLine',\n            type: 'line',\n            data: [\n              [this.x_min, this.yAxis_min],\n              [this.x_min, y_max]\n            ],\n            lineStyle: {\n              color: 'red',\n              width: 1\n            },\n            symbol: 'none'\n          } : null,\n          !this.isTimeMode ? {\n            name: 'xMaxLine',\n            type: 'line',\n            data: [\n              [this.x_max, this.yAxis_min],\n              [this.x_max, y_max]\n            ],\n            lineStyle: {\n              color: 'red',\n              width: 1\n            },\n            symbol: 'none'\n          } : null,\n          !this.isTimeMode ? {\n            name: 'currentPosition',\n            type: 'line',\n            data: [\n              [this.currentX, this.yAxis_min],\n              [this.currentX, y_max]\n            ],\n            lineStyle: {\n              color: 'green',\n              width: 1\n            },\n            symbol: 'none'\n          } : null\n        ]\n      };\n      // 过滤掉为 null 的 series 项\n      option.series = option.series.filter(Boolean);\n      // 使用 lazyUpdate 降低同步开销\n      this.myChart.setOption(option, false, true);\n    },\n    // 追加一个以\"当前时间\"为 x 的 FWHM 点（时间轴模式）\n    addFwhmPointNow(fwhm) {\n      // 确保 fwhm 是数字\n      const fwhmNum = typeof fwhm === 'number' ? fwhm : parseFloat(fwhm);\n      if (isNaN(fwhmNum) || fwhmNum <= 0) {\n        console.warn('Chart-Focus: Invalid FWHM value:', fwhm);\n        return;\n      }\n      \n      const now = Date.now();\n      const point = [now, fwhmNum];\n      this.chartData1_time.push(point);\n      \n      console.log('Chart-Focus: addFwhmPointNow', {\n        fwhm: fwhmNum,\n        time: new Date(now).toLocaleTimeString(),\n        isTimeMode: this.isTimeMode,\n        dataLength: this.chartData1_time.length,\n        chartInitialized: !!this.myChart\n      });\n      \n      // 仅保留窗口期内的数据\n      const minTs = now - this.timeWindowSec * 1000;\n      this.chartData1_time = this.chartData1_time.filter(p => p[0] >= minTs);\n      \n      // 强制重新渲染\n      if (this.myChart) {\n        this.scheduleRender(this.xAxis_min, this.xAxis_max);\n      } else {\n        console.warn('Chart-Focus: myChart not initialized yet');\n      }\n    },\n    // 开启/关闭时间轴模式\n    setTimeMode(flag) {\n      const enable = !!flag;\n      if (enable === this.isTimeMode) return;\n      this.isTimeMode = enable;\n      this.updateTickerByVisibility();\n      if (this.myChart) { this.myChart.clear(); }\n      this.scheduleRender(this.xAxis_min, this.xAxis_max);\n    },\n    stopTimeTicker() {\n      if (this.timeTicker) {\n        clearInterval(this.timeTicker);\n        this.timeTicker = null;\n      }\n    },\n    startTimeTicker() {\n      if (this.timeTicker) return;\n      this.timeTicker = setInterval(() => {\n        // 没有新点时也推动时间轴前进\n        if (this.myChart) {\n          this.scheduleRender(this.xAxis_min, this.xAxis_max);\n        }\n      }, 1000);\n    },\n    updateTickerByVisibility() {\n      const docVisible = typeof document !== 'undefined' ? !document.hidden : true;\n      const shouldRun = this.isTimeMode && this.isVisible && docVisible;\n      if (shouldRun) this.startTimeTicker(); else this.stopTimeTicker();\n    },\n    addData_Point(x,y) {\n      this.logger.info('Chart-Focus.vue | 添加数据点:', { x, y });\n      \n      // 过滤HFR大于等于100的数据点\n      if (y >= 100) {\n        this.logger.warn('Chart-Focus.vue | HFR值过大(>=100)，忽略此数据点:', { x, y });\n        return;\n      }\n      \n      const newDataPoint = [x, y];\n      const existingPointIndex = this.chartData1_pos.findIndex(point => point[0] === newDataPoint[0]);\n      if (existingPointIndex !== -1) {\n        // If the x value already exists, update the y value\n        if (newDataPoint[1] == 0 || newDataPoint[1] == this.chartData1_pos[existingPointIndex][1]) return;\n        this.chartData1_pos[existingPointIndex] = newDataPoint;\n      } else {\n        // If the x value does not exist, add the new data point\n        this.chartData1_pos.push(newDataPoint);\n      }\n      this.scheduleRender(this.xAxis_min, this.xAxis_max);\n    },\n    // 绘制折线/二次曲线\n    addLineData_Point(dataOrA, b, c) {\n      // 兼容：如果传入的是点数组，直接使用\n      if (Array.isArray(dataOrA)) {\n        this.lineDataFromPoints = dataOrA;\n        this.quadraticParams = null;\n        this.scheduleRender(this.xAxis_min, this.xAxis_max);\n        return;\n      }\n\n      // 若传入的是系数对象 { a, b, c }\n      if (dataOrA && typeof dataOrA === 'object' &&\n          (typeof dataOrA.a === 'number' || typeof dataOrA.a === 'string') &&\n          (typeof dataOrA.b === 'number' || typeof dataOrA.b === 'string') &&\n          (typeof dataOrA.c === 'number' || typeof dataOrA.c === 'string')) {\n        const aNum = typeof dataOrA.a === 'number' ? dataOrA.a : parseFloat(dataOrA.a);\n        const bNum = typeof dataOrA.b === 'number' ? dataOrA.b : parseFloat(dataOrA.b);\n        const cNum = typeof dataOrA.c === 'number' ? dataOrA.c : parseFloat(dataOrA.c);\n        if (!isFinite(aNum) || !isFinite(bNum) || !isFinite(cNum)) {\n          this.scheduleRender(this.xAxis_min, this.xAxis_max);\n          return;\n        }\n        const centerX = typeof dataOrA.x0 === 'number' ? dataOrA.x0 : (typeof dataOrA.x0 === 'string' ? parseFloat(dataOrA.x0) : 0);\n        this.quadraticParams = { a: aNum, b: bNum, c: cNum, x0: isFinite(centerX) ? centerX : 0 };\n        this.lineDataFromPoints = null;\n        this.scheduleRender(this.xAxis_min, this.xAxis_max);\n        return;\n      }\n\n      // 或者以三个独立参数形式传入 a, b, c\n      if ((typeof dataOrA === 'number' || typeof dataOrA === 'string') &&\n          (typeof b === 'number' || typeof b === 'string') &&\n          (typeof c === 'number' || typeof c === 'string')) {\n        const aNum = typeof dataOrA === 'number' ? dataOrA : parseFloat(dataOrA);\n        const bNum = typeof b === 'number' ? b : parseFloat(b);\n        const cNum = typeof c === 'number' ? c : parseFloat(c);\n        if (!isFinite(aNum) || !isFinite(bNum) || !isFinite(cNum)) {\n          this.scheduleRender(this.xAxis_min, this.xAxis_max);\n          return;\n        }\n        this.quadraticParams = { a: aNum, b: bNum, c: cNum };\n        this.lineDataFromPoints = null;\n        this.scheduleRender(this.xAxis_min, this.xAxis_max);\n        return;\n      }\n\n      // 其他非法输入：不处理，仅刷新现状\n      this.scheduleRender(this.xAxis_min, this.xAxis_max);\n    },\n    // 生成一元二次曲线采样点\n    generateQuadraticData(a, b, c, xMin, xMax, centerX = 0) {\n      const start = Number.isFinite(xMin) ? xMin : 0;\n      const end = Number.isFinite(xMax) ? xMax : 100;\n      const span = end - start;\n      const samples = Math.max(2, Math.min(400, Math.ceil(span / 50))); // 根据范围自适应采样密度\n      const step = span / samples || 1;\n      const data = [];\n      for (let x = start; x <= end; x += step) {\n        const t = x - centerX;\n        const y = a * t * t + b * t + c;\n        data.push([x, y]);\n      }\n      // 确保包含尾点\n      if (data.length === 0 || data[data.length - 1][0] < end) {\n        const tEnd = end - centerX;\n        const yEnd = a * tEnd * tEnd + b * tEnd + c;\n        data.push([end, yEnd]);\n      }\n      return data;\n    },\n    addMinPointData_Point(x,y) {\n      const newDataPoint = [x, y];\n      this.chartData3.push(newDataPoint);\n      this.scheduleRender(this.xAxis_min, this.xAxis_max);\n    },\n    // 更改显示的x轴范围\n    changeRange_x(current, target) {\n      this.xAxis_min = Number(current) - 3000;\n      this.xAxis_max = Number(current) + 3000;\n      this.currentX = current;\n      console.log(\"QHYCCD | changeRange_x:\", current, this.xAxis_min, this.xAxis_max);\n      this.scheduleRender(this.xAxis_min, this.xAxis_max);\n    },\n\n    // 清除数据\n    clearChartData1() {\n      this.chartData1_pos = [];\n      this.chartData1_time = [];\n      this.scheduleRender(this.xAxis_min, this.xAxis_max);\n    },\n    clearChartData2() {\n      this.chartData2 = [];\n      this.scheduleRender(this.xAxis_min, this.xAxis_max);\n    },\n    ClearAllData() {\n      this.chartData1_pos = [];\n      this.chartData1_time = [];\n      this.chartData2 = [];\n      this.chartData3 = [];\n      this.chartData4 = [];\n      this.quadraticResult.show = false;\n      this.yAxis_max = 30;\n      this.HFRMax = 15;\n      this.renderChart(this.xAxis_min, this.xAxis_max);\n    },\n    \n    // 清空精调数据（在精调开始时调用）\n    ClearFineData() {\n      this.logger.info('Chart-Focus.vue | 清空精调数据');\n      this.chartData1_pos = [];\n      this.chartData1_time = [];\n      this.chartData2 = [];\n      this.chartData3 = [];\n      this.chartData4 = [];\n      this.quadraticResult.show = false;\n      this.renderChart(this.xAxis_min, this.xAxis_max);\n    },\n    \n    // 更新异常点数据\n    updateOutlierData() {\n      const currentData = this.isTimeMode ? this.chartData1_time : this.chartData1_pos;\n      if (currentData.length >= 4) {\n        this.chartData4 = this.outlierDataPoints;\n        this.logger.debug('Chart-Focus.vue | 更新异常点数据，异常点数量:', this.chartData4.length);\n      } else {\n        this.chartData4 = [];\n      }\n    },\n    // 切换显示范围\n    RangeSwitch() {\n      if (this.range === 4) {\n        this.range = 2;\n        this.yAxis_min = -2;\n        this.yAxis_max = 2;\n      } else if (this.range === 2) {\n        this.range = 1;\n        this.yAxis_min = -1;\n        this.yAxis_max = 1;\n      } else if (this.range === 1) {\n        this.range = 4;\n        this.yAxis_min = -4;\n        this.yAxis_max = 4;\n      }\n      this.renderChart(this.xAxis_min, this.xAxis_max);\n    },\n    // 更新HFR\n    // UpdateHFR(HFR) {\n    //   const newDataPoint = [this.currentX, HFR];\n    //   this.addData_Point(newDataPoint);\n    //   // console.log(\"QHYCCD | UpdateHFR:\", newDataPoint);\n    //   // this.$bus.$emit('SendConsoleLogMsg', 'UpdateHFR:' + newDataPoint, 'info');\n    //   this.renderChart(this.xAxis_min, this.xAxis_max);\n    // },\n    // 拟合二次曲线\n    fitQuadraticCurve(dataString) {\n      this.logger.info('Chart-Focus.vue | 接收二次曲线数据:', dataString);\n      console.log('Chart-Focus.vue | 接收二次曲线数据:', dataString);\n      \n      const parts = dataString.split(':');\n      this.logger.info('Chart-Focus.vue | 解析后的数据部分:', parts);\n      console.log('Chart-Focus.vue | 解析后的数据部分:', parts);\n      \n      if (parts.length >= 6) {\n        const a = parseFloat(parts[1]);\n        const b = parseFloat(parts[2]);\n        const c = parseFloat(parts[3]);\n        const bestPosition = parseFloat(parts[4]);\n        const minHFR = parseFloat(parts[5]);\n        \n        this.logger.info('Chart-Focus.vue | 解析的数值:', { a, b, c, bestPosition, minHFR });\n        console.log('Chart-Focus.vue | 解析的数值:', { a, b, c, bestPosition, minHFR });\n        console.log('Chart-Focus.vue | 原始字符串部分:', parts);\n        \n        // 验证拟合系数的有效性\n        if (!this.validateFitCoefficients(a, b, c)) {\n          this.logger.warn('Chart-Focus.vue | 拟合系数无效，可能是水平线拟合');\n        }\n        \n        // 不再进行前端拟合计算，完全依赖后端提供的参数\n        this.logger.info('Chart-Focus.vue | 使用后端提供的拟合参数，不再进行前端拟合计算');\n        console.log('Chart-Focus.vue | 使用后端提供的拟合参数，不再进行前端拟合计算');\n        \n        // 验证参数是否合理\n        if (Math.abs(a) < 1e-10) {\n          this.logger.warn('Chart-Focus.vue | 警告：a系数接近0，这是线性拟合而不是二次拟合');\n          console.warn('Chart-Focus.vue | 警告：a系数接近0，这是线性拟合而不是二次拟合');\n          \n          // 对于线性拟合，我们需要特殊处理\n          this.generateLinearCurve(b, c, bestPosition);\n          \n          // 更新文本框显示（线性拟合）\n          this.quadraticResult.a = \"0.000000\"; // 显示为0\n          this.quadraticResult.b = b.toFixed(6);\n          this.quadraticResult.c = c.toFixed(6);\n          this.quadraticResult.bestPosition = \"线性拟合\";\n          this.quadraticResult.minHFR = minHFR.toFixed(3);\n          this.quadraticResult.show = true;\n          \n          return; // 直接返回，不执行二次曲线生成\n        }\n        \n        // 更新文本框显示\n        this.quadraticResult.a = a.toFixed(6);\n        this.quadraticResult.b = b.toFixed(6);\n        this.quadraticResult.c = c.toFixed(6);\n        this.quadraticResult.bestPosition = bestPosition.toFixed(2);\n        this.quadraticResult.minHFR = minHFR.toFixed(3);\n        this.quadraticResult.show = true;\n        \n        this.logger.info('Chart-Focus.vue | 文本框数据已更新:', this.quadraticResult);\n        \n        // 生成二次曲线数据点\n        this.generateQuadraticCurve(a, b, c, bestPosition);\n        \n        // 更新异常点数据\n        this.updateOutlierData();\n        \n        this.logger.info('Chart-Focus.vue | 二次拟合信息已更新:', this.quadraticResult);\n      } else {\n        this.logger.error('Chart-Focus.vue | 数据格式错误，部分数量不足:', parts.length);\n      }\n    },\n    \n    // 生成二次曲线数据点\n    generateQuadraticCurve(a, b, c, bestPosition) {\n      this.logger.info('Chart-Focus.vue | 开始生成二次曲线数据点:', { a, b, c, bestPosition });\n      \n      // 修正：后端发送的a、b、c系数是基于相对坐标的\n      // 需要找到数据点的最小位置作为偏移量，确保与后端算法一致\n      \n      // 从数据点中找到最小位置作为偏移量（修正：不使用bestPosition作为minPos）\n      let minPos = 0;\n      if (this.chartData1_pos.length > 0) {\n        minPos = Math.min(...this.chartData1_pos.map(point => point[0]));\n      }\n      \n      this.logger.debug('Chart-Focus.vue | 坐标系统信息:');\n      this.logger.debug('Chart-Focus.vue | - 数据点最小位置 (minPos):', minPos);\n      this.logger.debug('Chart-Focus.vue | - 后端发送的最佳位置 (bestPosition):', bestPosition);\n      this.logger.debug('Chart-Focus.vue | - 拟合系数 a:', a, 'b:', b, 'c:', c);\n      \n      console.log('Chart-Focus.vue | 坐标系统信息:');\n      console.log('Chart-Focus.vue | - 数据点最小位置 (minPos):', minPos);\n      console.log('Chart-Focus.vue | - 后端发送的最佳位置 (bestPosition):', bestPosition);\n      console.log('Chart-Focus.vue | - 拟合系数 a:', a, 'b:', b, 'c:', c);\n      console.log('Chart-Focus.vue | - 当前数据点:', this.chartData1_pos);\n      \n      // 验证最佳位置的计算是否正确\n      const expectedBestRelativePos = -b / (2 * a);\n      const expectedBestAbsolutePos = expectedBestRelativePos + minPos;\n      this.logger.debug('Chart-Focus.vue | - 计算的最佳相对位置:', expectedBestRelativePos);\n      this.logger.debug('Chart-Focus.vue | - 计算的最佳绝对位置:', expectedBestAbsolutePos);\n      this.logger.debug('Chart-Focus.vue | - 位置差异:', Math.abs(expectedBestAbsolutePos - bestPosition));\n      \n      const curveData = [];\n      \n      // 智能确定曲线生成范围\n      let startX, endX, stepSize;\n      \n      if (this.chartData1_pos.length > 0) {\n        // 基于数据点范围生成曲线\n        const dataMinX = Math.min(...this.chartData1_pos.map(point => point[0]));\n        const dataMaxX = Math.max(...this.chartData1_pos.map(point => point[0]));\n        const dataRange = dataMaxX - dataMinX;\n        \n        // 扩展范围以确保曲线覆盖完整\n        const extension = Math.max(dataRange * 0.2, 1000); // 扩展20%或至少1000\n        startX = dataMinX - extension;\n        endX = dataMaxX + extension;\n        \n        // 根据数据范围调整步长\n        stepSize = Math.max(Math.floor(dataRange / 100), 20); // 至少100个点，步长至少20\n      } else {\n        // 如果没有数据点，使用默认范围\n        const range = 5000;\n        startX = bestPosition - range;\n        endX = bestPosition + range;\n        stepSize = 50;\n      }\n      \n      // 确保曲线覆盖当前X轴范围\n      startX = Math.min(startX, this.xAxis_min);\n      endX = Math.max(endX, this.xAxis_max);\n      \n      this.logger.debug('Chart-Focus.vue | 曲线生成范围:', startX, '到', endX, '步长:', stepSize);\n      \n      // 生成曲线数据点\n      for (let x = startX; x <= endX; x += stepSize) {\n        // 将绝对坐标转换为相对坐标进行计算（与后端算法一致）\n        const relativeX = x - minPos;\n        const y = a * relativeX * relativeX + b * relativeX + c;\n        \n        // 验证计算结果\n        if (isFinite(y) && y >= 0) {\n          curveData.push([x, y]);\n        } else {\n          this.logger.warn('Chart-Focus.vue | 警告：计算得到无效的Y值:', y, '在位置:', x, '相对位置:', relativeX);\n        }\n      }\n      \n      // 添加关键点：确保数据点位置在曲线上有精确的点\n      if (this.chartData1_pos.length > 0) {\n        for (const point of this.chartData1_pos) {\n          const x = point[0];\n          const relativeX = x - minPos;\n          const y = a * relativeX * relativeX + b * relativeX + c;\n          \n          if (isFinite(y) && y >= 0) {\n            // 检查是否已经存在这个点（避免重复）\n            const exists = curveData.some(curvePoint => Math.abs(curvePoint[0] - x) < stepSize / 2);\n            if (!exists) {\n              curveData.push([x, y]);\n            }\n          }\n        }\n        \n        // 添加最佳位置点及其附近的高精度点\n        const bestRelativeX = bestPosition - minPos;\n        const bestY = a * bestRelativeX * bestRelativeX + b * bestRelativeX + c;\n        if (isFinite(bestY) && bestY >= 0) {\n          const exists = curveData.some(curvePoint => Math.abs(curvePoint[0] - bestPosition) < stepSize / 2);\n          if (!exists) {\n            curveData.push([bestPosition, bestY]);\n          }\n          \n          // 在最佳位置附近添加更多高精度点\n          const fineRange = Math.max(stepSize * 2, 200); // 在最佳位置附近200范围内使用高精度\n          const fineStep = Math.max(stepSize / 10, 5);\n          for (let offset = -fineRange; offset <= fineRange; offset += fineStep) {\n            const x = bestPosition + offset;\n            if (x >= startX && x <= endX) {\n              const relativeX = x - minPos;\n              const y = a * relativeX * relativeX + b * relativeX + c;\n              if (isFinite(y) && y >= 0) {\n                const exists = curveData.some(curvePoint => Math.abs(curvePoint[0] - x) < fineStep / 2);\n                if (!exists) {\n                  curveData.push([x, y]);\n                }\n              }\n            }\n          }\n        }\n      }\n      \n      // 按X坐标排序\n      curveData.sort((a, b) => a[0] - b[0]);\n      \n      // 在数据点密集区域增加曲线密度\n      if (this.chartData1_pos.length > 0) {\n        const enhancedCurveData = [];\n        const fineStepSize = Math.max(stepSize / 5, 5); // 在密集区域使用更小的步长\n        \n        for (let i = 0; i < curveData.length - 1; i++) {\n          const currentPoint = curveData[i];\n          const nextPoint = curveData[i + 1];\n          \n          enhancedCurveData.push(currentPoint);\n          \n          // 检查当前段是否包含数据点\n          const hasDataPoint = this.chartData1_pos.some(point => \n            point[0] >= currentPoint[0] && point[0] <= nextPoint[0]\n          );\n          \n          // 如果包含数据点，在中间添加更多点\n          if (hasDataPoint && (nextPoint[0] - currentPoint[0]) > fineStepSize) {\n            const midPoints = Math.floor((nextPoint[0] - currentPoint[0]) / fineStepSize);\n            for (let j = 1; j < midPoints; j++) {\n              const x = currentPoint[0] + (j * fineStepSize);\n              const relativeX = x - minPos;\n              const y = a * relativeX * relativeX + b * relativeX + c;\n              if (isFinite(y) && y >= 0) {\n                enhancedCurveData.push([x, y]);\n              }\n            }\n          }\n        }\n        \n        // 添加最后一个点\n        if (curveData.length > 0) {\n          enhancedCurveData.push(curveData[curveData.length - 1]);\n        }\n        \n        // 更新曲线数据\n        curveData.length = 0;\n        curveData.push(...enhancedCurveData);\n      }\n      \n      // 添加关键点的验证\n      if (curveData.length > 0) {\n        // 验证最佳位置点的Y值\n        const bestPointY = a * (bestPosition - minPos) * (bestPosition - minPos) + b * (bestPosition - minPos) + c;\n        this.logger.debug('Chart-Focus.vue | 最佳位置点验证:');\n        this.logger.debug('Chart-Focus.vue | - 最佳位置:', bestPosition);\n        this.logger.debug('Chart-Focus.vue | - 最佳位置相对坐标:', bestPosition - minPos);\n        this.logger.debug('Chart-Focus.vue | - 最佳位置Y值:', bestPointY);\n        \n        // 验证数据点是否在曲线上\n        this.logger.debug('Chart-Focus.vue | 数据点与曲线对比:');\n        for (let i = 0; i < Math.min(this.chartData1_pos.length, 5); i++) {\n          const point = this.chartData1_pos[i];\n          const pointRelativeX = point[0] - minPos;\n          const pointY = a * pointRelativeX * pointRelativeX + b * pointRelativeX + c;\n          const actualY = point[1];\n          const diff = Math.abs(pointY - actualY);\n          this.logger.debug(`Chart-Focus.vue | - 点${i}: 位置=${point[0]}, 实际HFR=${actualY}, 曲线HFR=${pointY}, 差异=${diff}`);\n        }\n      }\n      \n      this.logger.debug('Chart-Focus.vue | 生成的曲线数据点数量:', curveData.length);\n      this.logger.debug('Chart-Focus.vue | X轴范围:', startX, '到', endX);\n      this.logger.debug('Chart-Focus.vue | 前5个数据点:', curveData.slice(0, 5));\n      this.logger.debug('Chart-Focus.vue | 后5个数据点:', curveData.slice(-5));\n      \n      // 验证曲线形状\n      if (curveData.length > 0) {\n        const firstY = curveData[0][1];\n        const lastY = curveData[curveData.length - 1][1];\n        const middleIndex = Math.floor(curveData.length / 2);\n        const middleY = curveData[middleIndex][1];\n        \n        this.logger.debug('Chart-Focus.vue | 曲线形状验证 - 起始Y:', firstY, '中间Y:', middleY, '结束Y:', lastY);\n        \n        // 检查是否为有效的二次曲线（应该有最小值或最大值）\n        if (Math.abs(a) > 1e-10) {\n          const vertexX = -b / (2 * a) + minPos; // 顶点X坐标（转换回绝对坐标）\n          const vertexY = c - (b * b) / (4 * a); // 顶点Y坐标\n          this.logger.debug('Chart-Focus.vue | 二次曲线顶点位置:', vertexX, 'Y值:', vertexY);\n        }\n      }\n      \n      // 最终验证和清理曲线数据\n      const finalCurveData = curveData.filter(point => {\n        const [x, y] = point;\n        return isFinite(x) && isFinite(y) && y >= 0 && x >= startX && x <= endX;\n      });\n      \n      // 确保曲线数据按X坐标排序\n      finalCurveData.sort((a, b) => a[0] - b[0]);\n      \n      this.logger.debug('Chart-Focus.vue | 最终曲线数据验证:');\n      this.logger.debug('Chart-Focus.vue | - 原始数据点数量:', curveData.length);\n      this.logger.debug('Chart-Focus.vue | - 清理后数据点数量:', finalCurveData.length);\n      this.logger.debug('Chart-Focus.vue | - X轴范围:', finalCurveData.length > 0 ? `${finalCurveData[0][0]} 到 ${finalCurveData[finalCurveData.length - 1][0]}` : '无数据');\n      \n      this.chartData2 = finalCurveData;\n      this.logger.debug('Chart-Focus.vue | chartData2已更新，长度:', this.chartData2.length);\n      \n      // 调整X轴范围以显示完整曲线\n      if (finalCurveData.length > 0) {\n        this.xAxis_min = Math.min(this.xAxis_min, finalCurveData[0][0]);\n        this.xAxis_max = Math.max(this.xAxis_max, finalCurveData[finalCurveData.length - 1][0]);\n      }\n      \n      this.renderChart(this.xAxis_min, this.xAxis_max);\n      \n      this.logger.info('Chart-Focus.vue | 二次曲线数据点已生成并渲染完成');\n    },\n    \n    // 生成线性曲线数据点（当a=0时）\n    generateLinearCurve(b, c, bestPosition) {\n      this.logger.info('Chart-Focus.vue | 开始生成线性曲线数据点:', { b, c, bestPosition });\n      console.log('Chart-Focus.vue | 开始生成线性曲线数据点:', { b, c, bestPosition });\n      \n      // 对于线性拟合，我们需要找到数据点的最小位置作为偏移量\n      let minPos = 0;\n      if (this.chartData1_pos.length > 0) {\n        minPos = Math.min(...this.chartData1_pos.map(point => point[0]));\n      }\n      \n      this.logger.debug('Chart-Focus.vue | 线性拟合坐标系统信息:');\n      this.logger.debug('Chart-Focus.vue | - 数据点最小位置 (minPos):', minPos);\n      this.logger.debug('Chart-Focus.vue | - 线性系数 b:', b, 'c:', c);\n      \n      console.log('Chart-Focus.vue | 线性拟合坐标系统信息:');\n      console.log('Chart-Focus.vue | - 数据点最小位置 (minPos):', minPos);\n      console.log('Chart-Focus.vue | - 线性系数 b:', b, 'c:', c);\n      \n      const curveData = [];\n      \n      // 智能确定曲线生成范围\n      let startX, endX, stepSize;\n      \n      if (this.chartData1_pos.length > 0) {\n        // 基于数据点范围生成曲线\n        const dataMinX = Math.min(...this.chartData1_pos.map(point => point[0]));\n        const dataMaxX = Math.max(...this.chartData1_pos.map(point => point[0]));\n        const dataRange = dataMaxX - dataMinX;\n        \n        // 扩展范围以确保曲线覆盖完整\n        const extension = Math.max(dataRange * 0.2, 1000);\n        startX = dataMinX - extension;\n        endX = dataMaxX + extension;\n        \n        // 根据数据范围调整步长\n        stepSize = Math.max(Math.floor(dataRange / 100), 20);\n      } else {\n        // 如果没有数据点，使用默认范围\n        const range = 5000;\n        startX = bestPosition - range;\n        endX = bestPosition + range;\n        stepSize = 50;\n      }\n      \n      // 确保曲线覆盖当前X轴范围\n      startX = Math.min(startX, this.xAxis_min);\n      endX = Math.max(endX, this.xAxis_max);\n      \n      this.logger.debug('Chart-Focus.vue | 线性曲线生成范围:', startX, '到', endX, '步长:', stepSize);\n      \n      // 生成线性曲线数据点\n      for (let x = startX; x <= endX; x += stepSize) {\n        // 将绝对坐标转换为相对坐标进行计算\n        const relativeX = x - minPos;\n        const y = b * relativeX + c; // 线性方程：y = bx + c\n        \n        // 验证计算结果\n        if (isFinite(y) && y >= 0) {\n          curveData.push([x, y]);\n        } else {\n          this.logger.warn('Chart-Focus.vue | 警告：计算得到无效的Y值:', y, '在位置:', x, '相对位置:', relativeX);\n        }\n      }\n      \n      // 添加关键点：确保数据点位置在曲线上有精确的点\n      if (this.chartData1_pos.length > 0) {\n        for (const point of this.chartData1_pos) {\n          const x = point[0];\n          const relativeX = x - minPos;\n          const y = b * relativeX + c;\n          \n          if (isFinite(y) && y >= 0) {\n            // 检查是否已经存在这个点（避免重复）\n            const exists = curveData.some(curvePoint => Math.abs(curvePoint[0] - x) < stepSize / 2);\n            if (!exists) {\n              curveData.push([x, y]);\n            }\n          }\n        }\n      }\n      \n      // 按X坐标排序\n      curveData.sort((a, b) => a[0] - b[0]);\n      \n      // 最终验证和清理曲线数据\n      const finalCurveData = curveData.filter(point => {\n        const [x, y] = point;\n        return isFinite(x) && isFinite(y) && y >= 0 && x >= startX && x <= endX;\n      });\n      \n      this.logger.debug('Chart-Focus.vue | 线性曲线最终数据验证:');\n      this.logger.debug('Chart-Focus.vue | - 原始数据点数量:', curveData.length);\n      this.logger.debug('Chart-Focus.vue | - 清理后数据点数量:', finalCurveData.length);\n      \n      this.chartData2 = finalCurveData;\n      this.logger.debug('Chart-Focus.vue | chartData2已更新（线性拟合），长度:', this.chartData2.length);\n      \n      // 调整X轴范围以显示完整曲线\n      if (finalCurveData.length > 0) {\n        this.xAxis_min = Math.min(this.xAxis_min, finalCurveData[0][0]);\n        this.xAxis_max = Math.max(this.xAxis_max, finalCurveData[finalCurveData.length - 1][0]);\n      }\n      \n      this.renderChart(this.xAxis_min, this.xAxis_max);\n      \n      this.logger.info('Chart-Focus.vue | 线性曲线数据点已生成并渲染完成');\n    },\n    \n    // 拟合二次曲线最小点\n    fitQuadraticCurve_minPoint(dataString) {\n      this.logger.info('Chart-Focus.vue | 接收最小点数据:', dataString);\n      \n      const parts = dataString.split(':');\n      if (parts.length >= 3) {\n        const bestPosition = parseFloat(parts[1]);\n        const minHFR = parseFloat(parts[2]);\n        \n        // 更新文本框显示\n        this.quadraticResult.bestPosition = bestPosition.toFixed(2);\n        this.quadraticResult.minHFR = minHFR.toFixed(3);\n        this.quadraticResult.show = true;\n        \n        // 添加最小点到图表\n        this.chartData3 = [];\n        this.chartData3.push([bestPosition, minHFR]);\n        this.renderChart(this.xAxis_min, this.xAxis_max);\n        \n        this.logger.info('Chart-Focus.vue | 最小点信息已更新:', { bestPosition, minHFR });\n      }\n    },\n    setFocusChartRange(lowerBound, upperBound) {\n      this.x_min = lowerBound;\n      this.x_max = upperBound;\n    },\n    \n    // ==================== 异常点检测方法 ====================\n    \n    /**\n     * 智能异常点检测\n     * 使用多种方法检测并去除异常点\n     */\n    removeOutliers(dataPoints) {\n      if (dataPoints.length < 4) {\n        return dataPoints; // 数据点太少，不进行异常值检测\n      }\n      \n      this.logger.info('Chart-Focus.vue | 开始智能异常值检测，原始数据点数量:', dataPoints.length);\n      \n      // 方法1：基于二次曲线拟合的残差分析\n      const cleanData1 = this.removeOutliersByResidual(dataPoints);\n      \n      // 方法2：基于HFR统计分布的IQR方法\n      const cleanData2 = this.removeOutliersByIQR(dataPoints);\n      \n      // 方法3：基于位置分布的异常检测\n      const cleanData3 = this.removeOutliersByPosition(dataPoints);\n      \n      // 选择保留最多数据点的方法，但确保至少有3个数据点\n      let bestCleanData = cleanData1;\n      if (cleanData2.length > bestCleanData.length && cleanData2.length >= 3) {\n        bestCleanData = cleanData2;\n      }\n      if (cleanData3.length > bestCleanData.length && cleanData3.length >= 3) {\n        bestCleanData = cleanData3;\n      }\n      \n      // 如果所有方法都过滤得太严格，使用最宽松的方法\n      if (bestCleanData.length < 3) {\n        this.logger.warn('Chart-Focus.vue | 所有异常值检测方法都过于严格，使用最宽松的方法');\n        bestCleanData = cleanData2; // IQR方法相对宽松\n        if (bestCleanData.length < 3) {\n          bestCleanData = dataPoints; // 如果还是不够，返回原始数据\n        }\n      }\n      \n      this.logger.info('Chart-Focus.vue | 智能异常值检测完成: 原始数据', dataPoints.length, '个点，清理后', bestCleanData.length, '个点');\n      \n      return bestCleanData;\n    },\n    \n    /**\n     * 基于二次曲线拟合残差的异常值检测\n     * 注意：现在主要依赖后端拟合结果，此方法仅作为备用\n     */\n    removeOutliersByResidual(dataPoints) {\n      if (dataPoints.length < 4) {\n        return dataPoints; // 需要至少4个点才能进行二次拟合\n      }\n      \n      // 简化异常值检测：直接使用IQR方法，不再进行二次拟合\n      const preliminaryClean = this.removeOutliersByIQR(dataPoints);\n      if (preliminaryClean.length < 3) {\n        return dataPoints;\n      }\n      \n      // 不再进行前端拟合，直接返回IQR清理后的数据\n      this.logger.info('Chart-Focus.vue | 异常值检测：使用IQR方法，不再进行前端拟合');\n      return preliminaryClean;\n    },\n    \n    /**\n     * 基于HFR统计分布的IQR异常值检测\n     */\n    removeOutliersByIQR(dataPoints) {\n      // 计算HFR的统计信息\n      const hfrValues = dataPoints.map(point => point[1]);\n      \n      // 排序\n      const sortedHfrValues = [...hfrValues].sort((a, b) => a - b);\n      \n      // 计算四分位数\n      const n = sortedHfrValues.length;\n      const q1 = sortedHfrValues[Math.floor(n / 4)];\n      const q3 = sortedHfrValues[Math.floor(3 * n / 4)];\n      const iqr = q3 - q1;\n      \n      // 定义异常值边界（使用2倍IQR，比1.5倍更宽松）\n      const lowerBound = q1 - 2.0 * iqr;\n      const upperBound = q3 + 2.0 * iqr;\n      \n      // 过滤异常值\n      const cleanData = dataPoints.filter(point => \n        point[1] >= lowerBound && point[1] <= upperBound\n      );\n      \n      this.logger.info('Chart-Focus.vue | 基于IQR的异常值检测: 原始数据', dataPoints.length, '个点，清理后', cleanData.length, '个点');\n      \n      return cleanData;\n    },\n    \n    /**\n     * 基于位置分布的异常值检测\n     */\n    removeOutliersByPosition(dataPoints) {\n      if (dataPoints.length < 4) {\n        return dataPoints;\n      }\n      \n      // 按位置排序\n      const sortedData = [...dataPoints].sort((a, b) => a[0] - b[0]);\n      \n      // 计算相邻点之间的距离\n      const distances = [];\n      for (let i = 1; i < sortedData.length; i++) {\n        const dist = sortedData[i][0] - sortedData[i-1][0];\n        distances.push(dist);\n      }\n      \n      // 计算距离的统计信息\n      const sortedDistances = [...distances].sort((a, b) => a - b);\n      const n = sortedDistances.length;\n      const medianDistance = sortedDistances[Math.floor(n / 2)];\n      const q3 = sortedDistances[Math.floor(3 * n / 4)];\n      const threshold = q3 + 1.5 * (q3 - medianDistance);\n      \n      // 识别位置异常的点\n      const cleanData = [];\n      cleanData.push(sortedData[0]); // 第一个点总是保留\n      \n      for (let i = 1; i < sortedData.length; i++) {\n        const dist = sortedData[i][0] - sortedData[i-1][0];\n        if (dist <= threshold) {\n          cleanData.push(sortedData[i]);\n        } else {\n          // 检查是否是孤立点（前后距离都很大）\n          let isIsolated = true;\n          if (i > 1) {\n            const prevDist = sortedData[i-1][0] - sortedData[i-2][0];\n            if (prevDist <= threshold) isIsolated = false;\n          }\n          if (i < sortedData.length - 1) {\n            const nextDist = sortedData[i+1][0] - sortedData[i][0];\n            if (nextDist <= threshold) isIsolated = false;\n          }\n          \n          if (!isIsolated) {\n            cleanData.push(sortedData[i]);\n          }\n        }\n      }\n      \n      this.logger.info('Chart-Focus.vue | 基于位置的异常值检测: 原始数据', dataPoints.length, '个点，清理后', cleanData.length, '个点');\n      \n      return cleanData;\n    },\n    \n    /**\n     * 执行二次曲线拟合\n     * 注意：现在主要依赖后端拟合结果，此方法仅用于测试和调试\n     * 返回拟合系数 {a, b, c}\n     */\n    performQuadraticFit(dataPoints) {\n      if (dataPoints.length < 3) {\n        return null;\n      }\n      \n      this.logger.info('Chart-Focus.vue | 开始二次曲线拟合，数据点数量:', dataPoints.length);\n      \n      // 标准化坐标：将位置转换为相对坐标\n      const minPos = Math.min(...dataPoints.map(point => point[0]));\n      this.logger.debug('Chart-Focus.vue | 最小位置 (偏移量):', minPos);\n      \n      // 构建最小二乘法正规方程组\n      let sum_x4 = 0, sum_x3 = 0, sum_x2 = 0, sum_x = 0, sum_1 = 0;\n      let sum_x2y = 0, sum_xy = 0, sum_y = 0;\n      \n      for (const point of dataPoints) {\n        const x = point[0] - minPos; // 相对坐标\n        const y = point[1];\n        \n        const x2 = x * x;\n        const x3 = x2 * x;\n        const x4 = x3 * x;\n        \n        sum_x4 += x4;\n        sum_x3 += x3;\n        sum_x2 += x2;\n        sum_x += x;\n        sum_1 += 1;\n        \n        sum_x2y += x2 * y;\n        sum_xy += x * y;\n        sum_y += y;\n      }\n      \n      this.logger.debug('Chart-Focus.vue | 拟合统计量:', {\n        sum_x4, sum_x3, sum_x2, sum_x, sum_1,\n        sum_x2y, sum_xy, sum_y\n      });\n      \n      // 构建系数矩阵和常数向量\n      const matrix = [\n        [sum_x4, sum_x3, sum_x2],\n        [sum_x3, sum_x2, sum_x],\n        [sum_x2, sum_x, sum_1]\n      ];\n      \n      const constants = [sum_x2y, sum_xy, sum_y];\n      \n      this.logger.debug('Chart-Focus.vue | 系数矩阵:', matrix);\n      this.logger.debug('Chart-Focus.vue | 常数向量:', constants);\n      \n      // 求解线性方程组（使用高斯消元法）\n      const coefficients = this.solveLinearSystem(matrix, constants);\n      if (!coefficients) {\n        this.logger.error('Chart-Focus.vue | 线性方程组求解失败');\n        return null;\n      }\n      \n      const result = {\n        a: coefficients[0],\n        b: coefficients[1],\n        c: coefficients[2]\n      };\n      \n      this.logger.info('Chart-Focus.vue | 拟合系数:', result);\n      \n      // 验证拟合结果\n      if (!isFinite(result.a) || !isFinite(result.b) || !isFinite(result.c)) {\n        this.logger.error('Chart-Focus.vue | 拟合系数包含无效值');\n        return null;\n      }\n      \n      // 检查是否为有效的二次曲线（a不为0）\n      if (Math.abs(result.a) < 1e-10) {\n        this.logger.warn('Chart-Focus.vue | 警告：二次项系数接近0，可能是直线拟合');\n      }\n      \n      return result;\n    },\n    \n    /**\n     * 求解3x3线性方程组\n     */\n    solveLinearSystem(matrix, constants) {\n      // 高斯消元法求解线性方程组\n      const augmented = [];\n      \n      // 构建增广矩阵\n      for (let i = 0; i < 3; i++) {\n        augmented[i] = [...matrix[i], constants[i]];\n      }\n      \n      // 前向消元\n      for (let i = 0; i < 3; i++) {\n        // 寻找主元\n        let maxRow = i;\n        for (let k = i + 1; k < 3; k++) {\n          if (Math.abs(augmented[k][i]) > Math.abs(augmented[maxRow][i])) {\n            maxRow = k;\n          }\n        }\n        \n        // 交换行\n        if (maxRow !== i) {\n          [augmented[i], augmented[maxRow]] = [augmented[maxRow], augmented[i]];\n        }\n        \n        // 检查主元是否为零\n        if (Math.abs(augmented[i][i]) < 1e-10) {\n          this.logger.error('Chart-Focus.vue | 线性方程组奇异，无法求解');\n          return null;\n        }\n        \n        // 消元\n        for (let k = i + 1; k < 3; k++) {\n          const factor = augmented[k][i] / augmented[i][i];\n          for (let j = i; j < 4; j++) {\n            augmented[k][j] -= factor * augmented[i][j];\n          }\n        }\n      }\n      \n      // 回代求解\n      const solution = [0, 0, 0];\n      for (let i = 2; i >= 0; i--) {\n        solution[i] = augmented[i][3];\n        for (let j = i + 1; j < 3; j++) {\n          solution[i] -= augmented[i][j] * solution[j];\n        }\n        solution[i] /= augmented[i][i];\n      }\n      \n      return solution;\n    },\n    \n    // ==================== 测试和调试方法 ====================\n    \n    /**\n     * 测试后端数据接收功能\n     * 模拟后端发送的拟合数据来测试前端处理\n     */\n    testBackendDataReception() {\n      this.logger.info('Chart-Focus.vue | 开始测试后端数据接收功能');\n      console.log('Chart-Focus.vue | 开始测试后端数据接收功能');\n      \n      // 模拟后端发送的数据格式\n      const testData = \"fitQuadraticCurve:0.000001:-0.02:5.0:15731.13:1.930\";\n      this.logger.info('Chart-Focus.vue | 模拟后端数据:', testData);\n      console.log('Chart-Focus.vue | 模拟后端数据:', testData);\n      \n      // 调用拟合方法\n      this.fitQuadraticCurve(testData);\n    },\n    \n    /**\n     * 测试二次曲线拟合功能\n     * 注意：现在主要依赖后端拟合结果，此方法仅用于测试前端拟合算法\n     * 使用模拟数据验证拟合算法是否正确\n     */\n    testQuadraticFitting() {\n      this.logger.info('Chart-Focus.vue | 开始测试二次曲线拟合功能');\n      \n      // 生成测试数据：y = 0.0001 * (x - 3000)^2 + 2.0\n      const testData = [];\n      for (let i = 0; i < 10; i++) {\n        const x = 2000 + i * 200; // 位置从2000到3800\n        const y = 0.0001 * Math.pow(x - 3000, 2) + 2.0 + (Math.random() - 0.5) * 0.2; // 添加噪声\n        testData.push([x, y]);\n      }\n      \n      this.logger.debug('Chart-Focus.vue | 测试数据:', testData);\n      \n      // 执行拟合\n      const fitResult = this.performQuadraticFit(testData);\n      if (fitResult) {\n        this.logger.info('Chart-Focus.vue | 拟合结果:', fitResult);\n        \n        // 计算理论最佳位置（应该是3000）\n        const minPos = Math.min(...testData.map(point => point[0]));\n        const theoreticalBestPos = -fitResult.b / (2 * fitResult.a) + minPos;\n        this.logger.info('Chart-Focus.vue | 理论最佳位置:', theoreticalBestPos, '期望值: 3000');\n        \n        // 生成拟合曲线\n        this.generateQuadraticCurve(fitResult.a, fitResult.b, fitResult.c, theoreticalBestPos);\n        \n        this.logger.info('Chart-Focus.vue | 二次曲线拟合测试完成');\n      } else {\n        this.logger.error('Chart-Focus.vue | 二次曲线拟合测试失败');\n      }\n    },\n    \n  }\n}\n</script>\n\n<style scoped>\n.linechart-panel {\n  background-color: rgba(0, 0, 0, 0.0);\n  /* backdrop-filter: blur(5px); */\n  border-radius: 5px;\n  box-sizing: border-box;\n}\n\n.focus-result-panel {\n  position: fixed;\n  top: -200%;\n  left: 50%;\n  transform: translate(-50%, -50%);\n  width: 300px;\n  background: linear-gradient(135deg, rgba(30, 30, 30, 0.95), rgba(45, 45, 45, 0.95));\n  border: 1px solid rgba(100, 100, 100, 0.3);\n  border-radius: 8px;\n  padding: 12px;\n  font-size: 12px;\n  color: #e0e0e0;\n  z-index: 1000;\n  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);\n  backdrop-filter: blur(10px);\n  min-height: 60px;\n}\n\n.panel-header {\n  display: flex;\n  justify-content: space-between;\n  align-items: center;\n  margin-bottom: 8px;\n  padding-bottom: 6px;\n  border-bottom: 1px solid rgba(100, 100, 100, 0.2);\n}\n\n.header-left {\n  display: flex;\n  align-items: center;\n}\n\n.close-button {\n  width: 20px;\n  height: 20px;\n  border-radius: 50%;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  cursor: pointer;\n  background-color: rgba(255, 255, 255, 0.1);\n  color: #b0b0b0;\n  font-size: 14px;\n  font-weight: bold;\n  transition: all 0.2s ease;\n}\n\n.close-button:hover {\n  background-color: rgba(255, 255, 255, 0.2);\n  color: #ffffff;\n}\n\n.status-icon {\n  width: 20px;\n  height: 20px;\n  border-radius: 50%;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  margin-right: 8px;\n  font-size: 12px;\n  font-weight: bold;\n}\n\n.status-icon.success {\n  background-color: rgba(76, 175, 80, 0.2);\n  color: #4caf50;\n  border: 1px solid rgba(76, 175, 80, 0.4);\n}\n\n.status-icon.warning {\n  background-color: rgba(255, 152, 0, 0.2);\n  color: #ff9800;\n  border: 1px solid rgba(255, 152, 0, 0.4);\n}\n\n.panel-title {\n  font-weight: 600;\n  color: #ffffff;\n  font-size: 13px;\n}\n\n.panel-content {\n  display: flex;\n  flex-direction: column;\n  gap: 4px;\n}\n\n.status-row {\n  display: flex;\n  justify-content: space-between;\n  align-items: center;\n  padding: 2px 0;\n}\n\n.label {\n  color: #b0b0b0;\n  font-size: 11px;\n  font-weight: 500;\n}\n\n.value {\n  color: #ffffff;\n  font-size: 11px;\n  font-weight: 600;\n  font-family: 'Courier New', monospace;\n}\n\n.value.error {\n  color: #ff9800;\n  background: none;\n}\n\n.best-position {\n  margin-bottom: 2px;\n  color: #00ffff;\n  font-size: 9px;\n}\n\n.min-hfr {\n  color: #ff00ff;\n  font-size: 9px;\n}\n\n.fit-info {\n  color: #00ff00;\n  font-size: 8px;\n  margin-top: 2px;\n  font-style: italic;\n}\n</style>\n"]}]}