{"remainingRequest":"/app/node_modules/vue-loader/lib/index.js??vue-loader-options!/app/src/components/location-mgr.vue?vue&type=style&index=0&lang=css&","dependencies":[{"path":"/app/src/components/location-mgr.vue","mtime":1749458942073},{"path":"/app/node_modules/css-loader/dist/cjs.js","mtime":1707125446000},{"path":"/app/node_modules/vue-loader/lib/loaders/stylePostLoader.js","mtime":1707125450000},{"path":"/app/node_modules/postcss-loader/src/index.js","mtime":1707125450000},{"path":"/app/node_modules/cache-loader/dist/cjs.js","mtime":1707125360000},{"path":"/app/node_modules/vue-loader/lib/index.js","mtime":1707125450000}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:CgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKLmxlYWZsZXQtY29udHJvbC1nZW9jb2Rlci1mb3JtIGlucHV0IHsKICBjYXJldC1jb2xvcjojMDAwICFpbXBvcnRhbnQ7CiAgY29sb3I6ICMwMDAgIWltcG9ydGFudDsKfQoKLyogVG9vbHRpcOagt+W8j+WinuW8uiAqLwoubGVhZmxldC10b29sdGlwIHsKICBmb250LXNpemU6IDEycHggIWltcG9ydGFudDsKICBmb250LXdlaWdodDogNTAwICFpbXBvcnRhbnQ7Cn0KCi5sZWFmbGV0LXRvb2x0aXAgc3Ryb25nIHsKICBjb2xvcjogI2ZmOTgwMCAhaW1wb3J0YW50Owp9CgoubGVhZmxldC10b29sdGlwIHNtYWxsIHsKICBmb250LXN0eWxlOiBpdGFsaWM7Cn0KCi8qIOaLluaLveS4reeahOagh+iusOWKqOeUuyAqLwoubGVhZmxldC1tYXJrZXItZHJhZ2dpbmcgewogIHRyYW5zaXRpb246IG5vbmUgIWltcG9ydGFudDsKfQo="},{"version":3,"sources":["location-mgr.vue"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA8+CA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA","file":"location-mgr.vue","sourceRoot":"src/components","sourcesContent":["// Stellarium Web - Copyright (c) 2022 - Stellarium Labs SRL\n//\n// This program is licensed under the terms of the GNU AGPL v3, or\n// alternatively under a commercial licence.\n//\n// The terms of the AGPL v3 license can be found in the main directory of this\n// repository.\n\n/*\n位置管理器组件 - 信号槽接口说明\n\n主要方法：\n1. updateMapPosition(lat, lng, options) - 通用位置更新方法\n   参数：\n   - lat: 纬度 (number)\n   - lng: 经度 (number) \n   - options: 配置选项 (object)\n     - updateMarker: 是否更新地图钉 (boolean, 默认true)\n     - fetchAddress: 是否获取地址信息 (boolean, 默认true)\n     - zoom: 缩放级别 (number, 可选)\n     - animate: 是否使用动画 (boolean, 默认true)\n     - accuracy: 位置精度 (number, 默认0)\n\n便捷方法：\n2. flyToPosition(lat, lng, zoom) - 动画跳转到位置\n3. setPosition(lat, lng, zoom) - 直接设置位置（无动画）\n4. centerMapAt(lat, lng, zoom, animate) - 仅移动地图中心\n5. updateToKnownLocation(locationObj, animate) - 通过位置对象更新\n\n事件：\n- mapPositionUpdated: 位置更新完成时触发\n- addressInfoUpdated: 地址信息获取完成时触发  \n- addressInfoError: 地址信息获取失败时触发\n\n使用示例：\n// 在父组件中\nthis.$refs.locationManager.flyToPosition(39.9042, 116.4074, 15)\nthis.$refs.locationManager.setPosition(40.7128, -74.0060)\nthis.$refs.locationManager.centerMapAt(51.5074, -0.1278, 12, false)\n\n// 监听事件\n<location-mgr \n  @mapPositionUpdated=\"onPositionUpdated\"\n  @addressInfoUpdated=\"onAddressUpdated\"\n  @addressInfoError=\"onAddressError\"\n  ref=\"locationManager\">\n</location-mgr>\n\n\n<template>\n  <div>\n    <v-row justify=\"space-around\">\n      <v-col cols=\"4\" v-if=\"doShowMyLocation\">\n        <v-list two-line subheader>\n          <v-subheader>{{ $t('My Locations') }}</v-subheader>\n          <v-list-item href=\"javascript:;\" v-for=\"item in knownLocations\" v-bind:key=\"item.id\" @click.native.stop=\"selectKnownLocation(item)\" :style=\"(item && knownLocationMode && selectedKnownLocation && item.id === selectedKnownLocation.id) ? 'background-color: #455a64' : ''\">\n            <v-list-item-icon>\n              <v-icon>mdi-map-marker</v-icon>\n            </v-list-item-icon>\n            <v-list-item-content>\n              <v-list-item-title>{{ item.short_name }}</v-list-item-title>\n              <v-list-item-subtitle>{{ item.country }}</v-list-item-subtitle>\n            </v-list-item-content>\n          </v-list-item>\n        </v-list>\n      </v-col>\n      <v-col cols=\"doShowMyLocation ? 8 : 12\" >\n        <v-card class=\"blue-grey darken-2 white--text\">\n          <v-card-title primary-title>\n            <v-container fluid>\n              <v-row>\n                <!-- 左侧位置信息区域 -->\n                <v-col>\n                  <div>\n                    <div class=\"text-h5\" style=\"overflow: hidden; white-space: nowrap; text-overflow: ellipsis;\">\n                      {{ locationForDetail ? locationForDetail.short_name + ', ' + locationForDetail.country : $t('locationMgr.selectLocation') }}\n                      <v-progress-circular v-if=\"geoCodeLoading\" indeterminate size=\"16\" width=\"2\" color=\"orange\" style=\"margin-left: 8px;\"></v-progress-circular>\n                    </div>\n                    <div class=\"grey--text text-subtitle-2\" v-if=\"locationForDetail && locationForDetail.street_address\">{{ locationForDetail.street_address }}</div>\n                    <div class=\"grey--text text-subtitle-2\">\n                      {{ hasValidSelection ? locationForDetail.lat.toFixed(5) + ' ' + locationForDetail.lng.toFixed(5) : $t('locationMgr.dragToSelect') }}\n                      <span v-if=\"geoCodeLoading\" style=\"color: #ff9800; margin-left: 8px;\">{{ $t('locationMgr.fetchingAddress') }}</span>\n                    </div>\n                  </div>\n                </v-col>\n                \n                <!-- 右侧控制区域 -->\n                <v-col cols=\"auto\" style=\"min-width: 200px;\">\n                  <div class=\"d-flex flex-column\" style=\"gap: 8px;\">\n                    <!-- 地图模式切换（上部）- 状态图标与开关在同一水平线 -->\n                    <div class=\"d-flex align-center justify-space-between\" style=\"width: 100%; min-height: 32px;\">\n                      <div class=\"d-flex align-center\" style=\"gap: 6px; line-height: 1;\">\n                        <v-icon :color=\"getMapStatusColor()\" size=\"16\">{{ getMapStatusIcon() }}</v-icon>\n                        <span class=\"text-caption\" :style=\"`color: ${getMapStatusColor()}; line-height: 1;`\">{{ getMapStatusText() }}</span>\n                      </div>\n                      <div class=\"d-flex align-center\">\n                        <v-switch\n                          v-model=\"useOnlineMap\"\n                          @change=\"onMapTypeToggle\"\n                          dense\n                          hide-details\n                          color=\"primary\"\n                          class=\"mt-0 pt-0\"\n                          style=\"margin-left: 12px;\"\n                        >\n                          <template v-slot:label>\n                            <span class=\"text-caption\" style=\"line-height: 1;\">{{ $t('locationMgr.onlineMap') }}</span>\n                          </template>\n                        </v-switch>\n                      </div>\n                    </div>\n                    <!-- 使用此位置按钮（下部） -->\n                    <div>\n                      <v-btn \n                        @click.native.stop=\"useLocation()\" \n                        :disabled=\"!hasValidSelection\"\n                        color=\"primary\"\n                        small\n                        style=\"width: 100%;\"\n                      >\n                        <v-icon small>mdi-chevron-right</v-icon>\n                        {{ $t('Use this location') }}\n                      </v-btn>\n                    </div>\n                  </div>\n                </v-col>\n              </v-row>\n            </v-container>\n          </v-card-title>\n          <div style=\"height: 375px\">\n            <l-map class=\"black--text\" ref=\"myMap\" :center=\"mapCenter\" :zoom=\"defaultZoom\" style=\"width: 100%; height: 375px;\" :options=\"{zoomControl: false, minZoom: effectiveMinZoom, maxZoom: effectiveMaxZoom}\">\n              <l-control-zoom position=\"topright\"></l-control-zoom>\n              <l-tile-layer :url=\"url\" attribution='&copy; <a target=\"_blank\" rel=\"noopener\" href=\"http://osm.org/copyright\">OpenStreetMap</a> contributors'></l-tile-layer>\n              <l-marker :key=\"loc.id || 'marker-' + index\"\n                  v-for=\"(loc, index) in validKnownLocations\"\n                  :lat-lng=\"[ loc.lat, loc.lng ]\"\n                  :clickable=\"true\"\n                  :opacity=\"(!pickLocationMode && selectedKnownLocation && selectedKnownLocation === loc ? 1.0 : 0.25)\"\n                  @click=\"selectKnownLocation(loc)\"\n                  :draggable=\"!pickLocationMode && selectedKnownLocation && selectedKnownLocation === loc\" \n                  @dragend=\"dragEnd\"\n                >\n                  <l-tooltip>\n                    <div class=\"black--text\">\n                      <strong>{{ loc.short_name }}</strong><br>\n                      <span v-if=\"loc.city && loc.city !== $t('locationMgr.unknownCity')\">{{ loc.city }}<span v-if=\"loc.state\">, {{ loc.state }}</span><br></span>\n                      {{ loc.country }}<br>\n                      {{ $t('locationMgr.coordinates') }}: {{ loc.lat.toFixed(4) }}, {{ loc.lng.toFixed(4) }}<br>\n                      <small style=\"color: #666;\">\n                        <span v-if=\"!pickLocationMode && selectedKnownLocation && selectedKnownLocation === loc\">{{ $t('locationMgr.dragToMove') }}</span>\n                        <span v-else>{{ $t('locationMgr.clickToSelect') }}</span>\n                      </small>\n                    </div>\n                  </l-tooltip>\n                </l-marker>\n              <l-circle v-if=\"startLocation && isValidLocation(startLocation)\"\n                :lat-lng=\"[ startLocation.lat, startLocation.lng ]\"\n                :radius=\"startLocation.accuracy || 100\"\n                :options=\"{\n                  strokeColor: '#0000FF',\n                  strokeOpacity: 0.5,\n                  strokeWeight: 1,\n                  fillColor: '#0000FF',\n                  fillOpacity: 0.08}\"></l-circle>\n              <l-marker v-if=\"shouldShowPickLocation\" \n                :lat-lng=\"[ pickLocation.lat, pickLocation.lng ]\"\n                :draggable=\"true\" \n                @dragend=\"dragEnd\">\n                <l-tooltip>\n                  <div class=\"black--text\">\n                    <strong>{{ pickLocation.short_name }}</strong><br>\n                    <span v-if=\"pickLocation.city && pickLocation.city !== $t('locationMgr.unknownCity')\">{{ pickLocation.city }}<span v-if=\"pickLocation.state\">, {{ pickLocation.state }}</span><br></span>\n                    <span v-if=\"pickLocation.country && pickLocation.country !== $t('locationMgr.unknown')\">{{ pickLocation.country }}<br></span>\n                    {{ $t('locationMgr.coordinates') }}: {{ pickLocation.lat.toFixed(4) }}, {{ pickLocation.lng.toFixed(4) }}<br>\n                    <small style=\"color: #666;\">{{ $t('locationMgr.dragToAdjust') }}</small>\n                  </div>\n                </l-tooltip>\n              </l-marker>\n            </l-map>\n          </div>\n        </v-card>\n      </v-col>\n    </v-row>\n  </div>\n</template>\n\n<script>\nimport swh from '@/assets/sw_helpers.js'\nimport { LMap, LTileLayer, LMarker, LCircle, LTooltip, LControlZoom } from 'vue2-leaflet'\nimport L from 'leaflet'\nimport MapConfig from '@/config/map-config.js'\n\nexport default {\n  data: function () {\n    return {\n      mode: 'pick',\n      pickLocation: undefined,\n      selectedKnownLocation: undefined,\n      mapCenter: [39.9042, 116.4074],\n      url: process.env.NODE_ENV === 'production' ? '/tiles/{z}/{x}/{y}.png' : 'http://localhost:8080/tiles/{z}/{x}/{y}.png',\n      fallbackUrl: '/tiles/{z}/{x}/{y}.png',\n      serverUrl: 'http://localhost:8080/tiles/{z}/{x}/{y}.png',\n      onlineUrl: 'https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',\n      // 使用配置文件中的缩放级别设置\n      minZoom: MapConfig.zoom.offline.min,\n      maxZoom: MapConfig.zoom.offline.max,\n      defaultZoom: MapConfig.zoom.offline.default,\n      // 地理编码加载状态\n      geoCodeLoading: false,\n      // 地图类型和网络状态\n      useOnlineMap: true,              // 使用在线地图（用户选择）\n      isOnlineMapAvailable: false,     // 在线地图是否可用\n      isNetworkConnected: false,       // 网络是否连通\n      currentMapType: 'checking',      // 当前地图类型: 'online', 'offline', 'checking'\n      networkCheckInterval: null,      // 网络检测定时器\n      // 请求控制\n      currentRequestId: 0,\n      abortController: null\n    }\n  },\n  props: ['showMyLocation', 'knownLocations', 'startLocation', 'realLocation'],\n  computed: {\n    doShowMyLocation: function () {\n      return this.showMyLocation === undefined ? false : this.showMyLocation\n    },\n    pickLocationMode: function () {\n      return this.mode === 'pick'\n    },\n    knownLocationMode: function () {\n      return this.mode === 'known'\n    },\n    locationForDetail: function () {\n      let location = null\n      \n      if (this.pickLocationMode && this.pickLocation === undefined) {\n        location = this.startLocation\n      } else {\n        location = this.pickLocationMode ? this.pickLocation : this.selectedKnownLocation\n      }\n      \n      // 如果有有效位置就清理并返回\n      if (location && this.isValidLocation(location)) {\n        const sanitized = this.sanitizeLocation(location)\n        if (sanitized) {\n          return sanitized\n        }\n      }\n      \n      // 返回默认信息用于显示，但不会影响地图钉\n      return {\n        lat: 39.9042,\n        lng: 116.4074,\n        accuracy: 1000,\n        short_name: this.$t('locationMgr.beijing'),\n        country: this.$t('locationMgr.china'),\n        street_address: this.$t('locationMgr.beijingCity'),\n        city: this.$t('locationMgr.beijingCity'),\n        state: this.$t('locationMgr.beijingCity'),\n        postcode: ''\n      }\n    },\n    // 动态缩放级别配置\n    effectiveMinZoom: function () {\n      // 在线地图使用更宽松的限制，离线地图使用严格限制\n      if (this.currentMapType === 'online') {\n        return MapConfig.zoom.online.min  // 在线地图：通常是0或1\n      } else {\n        return MapConfig.zoom.offline.min  // 离线地图：基于可用瓦片\n      }\n    },\n    effectiveMaxZoom: function () {\n      // 在线地图使用更宽松的限制，离线地图使用严格限制\n      if (this.currentMapType === 'online') {\n        return MapConfig.zoom.online.max  // 在线地图：通常是18或19\n      } else {\n        return MapConfig.zoom.offline.max  // 离线地图：基于可用瓦片\n      }\n    },\n    validKnownLocations: function () {\n      if (!this.knownLocations || !Array.isArray(this.knownLocations) || this.knownLocations.length === 0) {\n        // 如果没有传入任何已知位置，不显示默认地图钉\n        return []\n      }\n      \n      const validLocations = this.knownLocations.filter(this.isValidLocation)\n      return validLocations\n    },\n    // 控制pickLocation地图钉是否显示\n    shouldShowPickLocation: function () {\n      // 在pickLocationMode且有有效pickLocation时显示（包括默认位置）\n      return this.pickLocationMode && \n             this.pickLocation && \n             this.isValidLocation(this.pickLocation)\n    },\n    hasValidSelection: function () {\n      // 检查是否有真正的位置选择\n      if (this.selectedKnownLocation) {\n        return true // 选择了已知位置\n      }\n      \n      if (this.pickLocation && this.isValidLocation(this.pickLocation)) {\n        // 如果地址信息显示\"拖拽选择位置\"或\"默认位置\"，说明用户还没有操作\n        if (this.pickLocation.short_name === this.$t('locationMgr.dragToSelectPin') || \n            this.pickLocation.country === this.$t('locationMgr.defaultLocation')) {\n          return false\n        }\n        return true\n      }\n      \n      return false\n    }\n  },\n  watch: {\n    startLocation: function (newLocation) {\n      if (this.isValidLocation(newLocation)) {\n        this.setPickLocation(newLocation)\n      } else {\n        console.warn('Invalid startLocation received:', newLocation)\n      }\n    }\n  },\n  created() {\n    this.$bus.$on('updateMapPosition', this.updateMapPosition);\n  },\n  mounted: function () {\n    const that = this\n    \n    // 修复Leaflet图标问题\n    this.fixLeafletIcons()\n    \n    // 只有在传入有效startLocation时才设置pickLocation\n    if (this.startLocation && this.isValidLocation(this.startLocation)) {\n      this.setPickLocation(this.startLocation)\n    } else {\n      // 如果没有startLocation，创建一个默认的pickLocation在地图中心\n      this.pickLocation = {\n        lat: 39.9042,\n        lng: 116.4074,\n        accuracy: 0,\n        short_name: this.$t('locationMgr.dragToSelectPin'),\n        country: this.$t('locationMgr.defaultLocation'),\n        street_address: this.$t('locationMgr.dragPinToTarget')\n      }\n      this.setPickLocationMode()\n    }\n    \n    // 启动网络监控\n    this.startNetworkMonitoring()\n    \n    // 检测并设置地图类型\n    this.detectAndSetMapType()\n    \n    this.$nextTick(() => {\n      const map = this.$refs.myMap.mapObject\n      map._onResize()\n\n      // 设置缩放限制\n      this.updateZoomLimits(map)\n    })\n  },\n  beforeDestroy: function () {\n    // 清理定时器\n    if (this.networkCheckInterval) {\n      clearInterval(this.networkCheckInterval)\n    }\n    \n    // 清理请求控制器\n    if (this.abortController) {\n      this.abortController.abort()\n      console.log('组件销毁，取消地理编码请求')\n    }\n    \n    // 移除网络状态监听器\n    window.removeEventListener('online', this.detectAndSetMapType)\n    window.removeEventListener('offline', this.detectAndSetMapType)\n  },\n  methods: {\n    selectKnownLocation: function (loc) {\n      this.selectedKnownLocation = loc\n      this.setKnownLocationMode()\n      this.mapCenter = [loc.lat, loc.lng]\n    },\n    useLocation: function () {\n      console.log('触发位置更新useLocation:', this.locationForDetail.lat, this.locationForDetail.lng)\n      this.$bus.$emit('locationSelected', this.locationForDetail)\n      const lat = parseFloat(this.locationForDetail.lat.toFixed(3))\n      const lng = parseFloat(this.locationForDetail.lng.toFixed(3))\n      this.$bus.$emit('resetLocation', lat, lng,false)\n    },\n    setPickLocationMode: function () {\n      this.mode = 'pick'\n    },\n    setKnownLocationMode: function () {\n      this.mode = 'known'\n    },\n    setPickLocation: function (loc) {\n      // 验证输入数据\n      if (!this.isValidLocation(loc)) {\n        console.warn('Invalid location data received:', loc)\n        // 不创建默认位置，直接返回\n        return\n      }\n      \n      // 清理数据\n      const sanitizedLoc = this.sanitizeLocation(loc)\n      \n      if (sanitizedLoc.accuracy < 100) {\n        for (const l of this.knownLocations) {\n          if (this.isValidLocation(l)) {\n            const d = swh.getDistanceFromLatLonInM(l.lat, l.lng, sanitizedLoc.lat, sanitizedLoc.lng)\n            if (d < 100) {\n              this.selectKnownLocation(l)\n              return\n            }\n          }\n        }\n      }\n      \n      // 设置有效的位置\n      this.mapCenter = [sanitizedLoc.lat, sanitizedLoc.lng]\n      this.pickLocation = sanitizedLoc\n      this.setPickLocationMode()\n    },\n    // Called when the user clicks on the small cross button\n    centerOnRealPosition: function () {\n      this.setPickLocation(this.realLocation)\n    },\n    \n    // 通过信号槽更新地图显示位置\n    updateMapPosition: function (lat, lng, options = {}) {\n      console.log('收到位置更新信号:', lat, lng, options)\n      \n      // 验证输入参数\n      if (typeof lat !== 'number' || typeof lng !== 'number' || \n          isNaN(lat) || isNaN(lng) || \n          lat < -90 || lat > 90 || lng < -180 || lng > 180) {\n        console.error('无效的位置坐标:', { lat, lng })\n        return false\n      }\n      \n      // 默认选项\n      const defaultOptions = {\n        updateMarker: true,        // 是否更新地图钉位置\n        fetchAddress: true,        // 是否获取地址信息\n        zoom: null,               // 可选的缩放级别\n        animate: true,            // 是否使用动画\n        accuracy: 0               // 位置精度\n      }\n      \n      const config = Object.assign({}, defaultOptions, options)\n      \n      try {\n        // 更新地图中心\n        if (config.animate && this.$refs.myMap && this.$refs.myMap.mapObject) {\n          // 使用动画平滑移动\n          const map = this.$refs.myMap.mapObject\n          const targetZoom = config.zoom || map.getZoom()\n          map.flyTo([lat, lng], targetZoom, {\n            duration: 1.5,  // 动画时长（秒）\n            easeLinearity: 0.1\n          })\n        } else {\n          // 直接设置地图中心\n          this.mapCenter = [lat, lng]\n          \n          // 如果指定了缩放级别，设置缩放\n          if (config.zoom && this.$refs.myMap && this.$refs.myMap.mapObject) {\n            this.$nextTick(() => {\n              this.$refs.myMap.mapObject.setZoom(config.zoom)\n            })\n          }\n        }\n        \n        // 更新地图钉位置\n        if (config.updateMarker) {\n          const newLocation = {\n            lat: lat,\n            lng: lng,\n            accuracy: config.accuracy,\n            short_name: config.fetchAddress ? this.$t('locationMgr.fetchingLocationInfo') : this.$t('locationMgr.newLocation'),\n            country: config.fetchAddress ? this.$t('locationMgr.pleaseWait') : this.$t('locationMgr.unknown'),\n            street_address: `${this.$t('locationMgr.coordinates')}: ${lat.toFixed(6)}, ${lng.toFixed(6)}`\n          }\n          \n          // 根据当前模式更新位置\n          if (this.pickLocationMode) {\n            this.pickLocation = newLocation\n            this.setPickLocationMode()\n          } else {\n            // 创建新的拾取位置\n            this.pickLocation = newLocation\n            this.setPickLocationMode()\n          }\n          \n          // 获取地址信息\n          if (config.fetchAddress) {\n            this.requestLocationInfo(lat, lng)\n          }\n        }\n        \n        // 触发位置更新事件\n        this.$emit('mapPositionUpdated', { lat, lng, options: config })\n        \n        console.log('地图位置更新成功:', { lat, lng, config })\n        return true\n        \n      } catch (error) {\n        console.error('地图位置更新失败:', error)\n        return false\n      }\n    },\n    \n    // 辅助方法：请求位置信息\n    requestLocationInfo: function (lat, lng) {\n      // 生成新的请求ID\n      const requestId = ++this.currentRequestId\n      \n      // 延迟获取地理信息，避免频繁请求\n      setTimeout(() => {\n        // 检查是否是最新的请求\n        if (requestId !== this.currentRequestId) {\n          console.log('位置信息请求已过期，跳过地理编码')\n          return\n        }\n        \n        // 获取地理信息（在线或离线）\n        this.getCityInfo({ lat, lng }, requestId).then(cityInfo => {\n          // 再次检查请求是否仍然有效\n          if (requestId !== this.currentRequestId) {\n            console.log('地理编码完成，但请求已过期')\n            return\n          }\n          \n          const updatedPos = {\n            lat: lat,\n            lng: lng,\n            accuracy: this.pickLocation?.accuracy || 0,\n            ...cityInfo\n          }\n          \n          // 更新位置信息\n          if (this.pickLocationMode && this.pickLocation) {\n            Object.assign(this.pickLocation, updatedPos)\n            this.$forceUpdate()\n          }\n          \n          console.log('位置信息已更新:', updatedPos)\n          \n          // 触发地址信息更新事件\n          this.$emit('addressInfoUpdated', updatedPos)\n          \n        }).catch(error => {\n          // 检查是否是请求取消错误\n          if (error.name === 'AbortError') {\n            console.log('地理编码请求被取消')\n            return\n          }\n          \n          // 再次检查请求是否仍然有效\n          if (requestId !== this.currentRequestId) {\n            console.log('地理编码失败，但请求已过期')\n            return\n          }\n          \n          console.error('获取位置信息失败:', error)\n          \n          // 错误处理\n          const errorLocationInfo = {\n            lat: lat,\n            lng: lng,\n            accuracy: this.pickLocation?.accuracy || 0,\n            short_name: this.$t('locationMgr.fetchLocationFailed'),\n            country: this.$t('locationMgr.unknownRegion'),\n            street_address: `${this.$t('locationMgr.coordinates')}: ${lat.toFixed(6)}, ${lng.toFixed(6)}`\n          }\n          \n          if (this.pickLocationMode && this.pickLocation) {\n            Object.assign(this.pickLocation, errorLocationInfo)\n            this.$forceUpdate()\n          }\n          \n          // 触发错误事件\n          this.$emit('addressInfoError', { lat, lng, error: error.message })\n        })\n      }, 100) // 100ms延迟\n    },\n    checkTileAvailability: function () {\n      const that = this\n      \n      // 在生产环境下优先使用静态瓦片\n      if (process.env.NODE_ENV === 'production') {\n        that.testStaticTiles().then(isAvailable => {\n          if (isAvailable) {\n            console.log('使用静态瓦片文件')\n            that.url = that.fallbackUrl\n          } else {\n            console.log('静态瓦片不可用，尝试tile服务器')\n            that.testTileServer()\n          }\n        })\n      } else {\n        // 开发环境下优先尝试tile服务器\n        that.testTileServer()\n      }\n    },\n    \n    testStaticTiles: function () {\n      const that = this\n      return new Promise((resolve) => {\n        // 测试多个缩放级别的瓦片是否存在\n        const testUrls = [\n          '/tiles/0/0/0.png',\n          '/tiles/1/0/0.png',\n          '/tiles/2/1/1.png'\n        ]\n        \n        let testCount = 0\n        let successCount = 0\n        \n        testUrls.forEach(url => {\n          fetch(url, { method: 'HEAD' })\n            .then(response => {\n              testCount++\n              if (response.ok) {\n                successCount++\n              }\n              \n              if (testCount === testUrls.length) {\n                // 如果至少一半的测试瓦片可用，认为静态瓦片可用\n                resolve(successCount >= testUrls.length / 2)\n              }\n            })\n            .catch(() => {\n              testCount++\n              if (testCount === testUrls.length) {\n                resolve(successCount >= testUrls.length / 2)\n              }\n            })\n        })\n        \n        // 超时处理\n        setTimeout(() => {\n          if (testCount < testUrls.length) {\n            resolve(false)\n          }\n        }, 2000)\n      })\n    },\n    \n    testTileServer: function () {\n      const that = this\n      \n      // 测试tile服务器是否可用\n      const testUrl = this.serverUrl.replace('{z}', '0').replace('{x}', '0').replace('{y}', '0')\n      \n      fetch(testUrl, { method: 'HEAD', timeout: 3000 })\n        .then(response => {\n          if (response.ok) {\n            console.log('tile服务器可用')\n            that.url = that.serverUrl\n          } else {\n            throw new Error('tile服务器响应错误')\n          }\n        })\n        .catch(error => {\n          console.log('tile服务器不可用，使用静态瓦片:', error)\n          that.url = that.fallbackUrl\n          \n          // 如果静态瓦片也不可用，最后尝试在线瓦片\n          that.testStaticTiles().then(isAvailable => {\n            if (!isAvailable && process.env.NODE_ENV === 'development') {\n              console.log('切换到在线瓦片服务')\n              that.url = that.onlineUrl\n            }\n          })\n        })\n    },\n    updateZoomLimits: function (map) {\n      const that = this\n      \n      // 动态设置缩放限制\n      map.setMinZoom(this.effectiveMinZoom)\n      map.setMaxZoom(this.effectiveMaxZoom)\n      \n      console.log(`地图缩放限制更新: ${this.effectiveMinZoom} - ${this.effectiveMaxZoom} (${this.currentMapType}模式)`)\n      \n      // 只在离线模式下检测可用瓦片级别\n      if (this.currentMapType === 'offline' && process.env.NODE_ENV === 'production') {\n        this.detectAvailableTileLevels().then(levels => {\n          if (levels.min !== null && levels.max !== null) {\n            map.setMinZoom(levels.min)\n            map.setMaxZoom(levels.max)\n            console.log(`离线瓦片级别检测: ${levels.min} - ${levels.max}`)\n          }\n        })\n      }\n    },\n    \n    detectAvailableTileLevels: function () {\n      const that = this\n      return new Promise((resolve) => {\n        const testLevels = MapConfig.detection.testLevels\n        let availableLevels = []\n        let testCount = 0\n        \n        testLevels.forEach(level => {\n          const testUrl = `/tiles/${level}/0/0.png`\n          \n          fetch(testUrl, { method: 'HEAD' })\n            .then(response => {\n              testCount++\n              if (response.ok) {\n                availableLevels.push(level)\n              }\n              \n              if (testCount === testLevels.length) {\n                availableLevels.sort((a, b) => a - b)\n                resolve({\n                  min: availableLevels.length > 0 ? availableLevels[0] : null,\n                  max: availableLevels.length > 0 ? availableLevels[availableLevels.length - 1] : null,\n                  available: availableLevels\n                })\n              }\n            })\n            .catch(() => {\n              testCount++\n              if (testCount === testLevels.length) {\n                availableLevels.sort((a, b) => a - b)\n                resolve({\n                  min: availableLevels.length > 0 ? availableLevels[0] : null,\n                  max: availableLevels.length > 0 ? availableLevels[availableLevels.length - 1] : null,\n                  available: availableLevels\n                })\n              }\n            })\n        })\n        \n        // 使用配置的超时时间\n        setTimeout(() => {\n          if (testCount < testLevels.length) {\n            resolve({ \n              min: MapConfig.zoom.offline.min, \n              max: MapConfig.zoom.offline.max, \n              available: [] \n            })\n          }\n        }, MapConfig.detection.timeout)\n      })\n    },\n    isValidLocation: function (location) {\n      if (!location) {\n        console.debug('位置验证: 位置对象为空')\n        return false\n      }\n      \n      // 检查必需的属性是否存在\n      if (typeof location.lat === 'undefined' || typeof location.lng === 'undefined') {\n        console.debug('位置验证: 缺少lat或lng属性', location)\n        return false\n      }\n      \n      // 检查经纬度是否为有效数字\n      const lat = parseFloat(location.lat)\n      const lng = parseFloat(location.lng)\n      \n      if (isNaN(lat) || isNaN(lng)) {\n        console.debug('位置验证: 坐标不是有效数字', { lat: location.lat, lng: location.lng, parsedLat: lat, parsedLng: lng })\n        return false\n      }\n      \n      // 检查经纬度范围\n      if (lat < -90 || lat > 90 || lng < -180 || lng > 180) {\n        console.debug('位置验证: 坐标超出有效范围', { lat, lng })\n        return false\n      }\n      \n      // 检查是否是极值（可能表示错误数据）\n      if (lat === 0 && lng === 0) {\n        console.debug('位置验证: 坐标为(0,0)，可能是错误数据')\n        return false\n      }\n      \n      return true\n    },\n    sanitizeLocation: function (location) {\n      if (!location) {\n        console.debug('位置清理: 输入位置为空')\n        return null\n      }\n      \n      // 确保有基本的坐标\n      const lat = parseFloat(location.lat)\n      const lng = parseFloat(location.lng)\n      \n      if (isNaN(lat) || isNaN(lng)) {\n        console.debug('位置清理: 无效的坐标数据', location)\n        return null\n      }\n      \n      const sanitized = {\n        lat: Math.max(-90, Math.min(90, lat)),     // 确保纬度在有效范围内\n        lng: Math.max(-180, Math.min(180, lng)),   // 确保经度在有效范围内\n        accuracy: parseFloat(location.accuracy) || 100,\n        short_name: location.short_name || this.$t('locationMgr.unknownLocation'),\n        country: location.country || this.$t('locationMgr.unknownCountry'),\n        street_address: location.street_address || '',\n        city: location.city || this.$t('locationMgr.unknownCity'),\n        state: location.state || '',\n        postcode: location.postcode || ''\n      }\n      \n      // 再次验证清理后的位置\n      if (!this.isValidLocation(sanitized)) {\n        console.debug('位置清理: 清理后仍然无效', sanitized)\n        return null\n      }\n      \n      return sanitized\n    },\n    fixLeafletIcons: function () {\n      // 修复Leaflet图标问题\n      L.Icon.Default.imagePath = 'https://unpkg.com/leaflet@1.7.1/dist/images/'\n      \n      // 确保触屏拖拽支持\n      this.$nextTick(() => {\n        if (this.$refs.myMap && this.$refs.myMap.mapObject) {\n          const map = this.$refs.myMap.mapObject\n          // 启用触屏拖拽\n          map.options.touchZoom = true\n          map.options.touchPan = true\n        }\n      })\n    },\n    getCityInfo: function (position, requestId) {\n      // 设置加载状态\n      this.geoCodeLoading = true\n      \n      // 创建AbortController\n      const abortController = new AbortController()\n      this.abortController = abortController\n      \n      // 直接基于已确定的地图类型选择地理编码方式（不重复判断网络状态）\n      if (this.currentMapType === 'online') {\n        return this.getOnlineGeocodingInfo(position, abortController)\n      } else {\n        return this.getOfflineGeocodingInfo(position)\n      }\n    },\n    \n    // 在线地理编码\n    getOnlineGeocodingInfo: function (position, abortController) {\n      console.log('使用在线地理编码服务')\n      \n      // 尝试多种地理编码服务和策略\n      const tryGeocoding = async () => {\n        // 策略1: 尝试使用JSONP方式绕过CORS（如果服务支持）\n        // 策略2: 使用公开的代理服务\n        // 策略3: 降级到离线模式\n        \n        const services = [\n          {\n            name: 'BigDataCloud-API',\n            url: `https://api.bigdatacloud.net/data/reverse-geocode-client?latitude=${position.lat}&longitude=${position.lng}&localityLanguage=zh-CN`,\n            method: 'fetch-cors'\n          },\n          {\n            name: 'OpenCage-Demo',\n            url: `https://api.opencagedata.com/geocode/v1/json?q=${position.lat}+${position.lng}&key=demo&language=zh-CN&pretty=1&no_annotations=1`,\n            method: 'fetch-cors'\n          }\n        ]\n        \n        for (const service of services) {\n          try {\n            console.log(`尝试使用${service.name}获取地址信息...`)\n            \n            let data\n            if (service.method === 'jsonp') {\n              // JSONP方法\n              data = await this.fetchWithJSONP(service.url, 8000)\n            } else if (service.method === 'fetch-cors') {\n              // 支持CORS的API\n              const response = await fetch(service.url, {\n                signal: abortController.signal,\n                mode: 'cors',\n                credentials: 'omit'\n              })\n              \n              if (!response.ok) {\n                throw new Error(`${service.name} HTTP ${response.status}`)\n              }\n              \n              data = await response.json()\n            } else {\n              // 常规fetch方法\n              const response = await fetch(service.url, {\n                headers: service.headers || {},\n                signal: abortController.signal,\n                mode: 'cors',\n                credentials: 'omit'\n              })\n              \n              if (!response.ok) {\n                throw new Error(`${service.name} HTTP ${response.status}`)\n              }\n              \n              data = await response.json()\n            }\n            \n            console.log(`${service.name}响应:`, data)\n            \n            // 处理不同服务的响应格式\n            let cityInfo\n            if (service.name.includes('BigDataCloud')) {\n              // BigDataCloud API格式\n              if (data && data.city) {\n                cityInfo = {\n                  short_name: this.formatBigDataCloudLocationName(data),\n                  country: data.countryName || this.$t('locationMgr.unknownCountry'),\n                  street_address: data.locality || data.city || this.$t('locationMgr.unknownAddress'),\n                  city: data.city || data.locality || this.$t('locationMgr.unknownCity'),\n                  state: data.principalSubdivision || '',\n                  postcode: data.postcode || ''\n                }\n              }\n            } else if (service.name.includes('OpenCage')) {\n              // OpenCage API格式\n              if (data && data.results && data.results.length > 0) {\n                const result = data.results[0]\n                const components = result.components || {}\n                cityInfo = {\n                  short_name: this.formatOpenCageLocationName(components),\n                  country: components.country || this.$t('locationMgr.unknownCountry'),\n                  street_address: result.formatted || this.$t('locationMgr.unknownAddress'),\n                  city: components.city || components.town || components.village || components.county || this.$t('locationMgr.unknownCity'),\n                  state: components.state || components.province || '',\n                  postcode: components.postcode || ''\n                }\n              }\n            } else {\n              // Nominatim格式\n              if (data && (data.display_name || data.name)) {\n                const address = data.address || {}\n                cityInfo = {\n                  short_name: this.formatLocationName(address),\n                  country: address.country || this.$t('locationMgr.unknownCountry'),\n                  street_address: data.display_name || data.name || this.$t('locationMgr.unknownAddress'),\n                  city: address.city || address.town || address.village || address.county || this.$t('locationMgr.unknownCity'),\n                  state: address.state || address.province || '',\n                  postcode: address.postcode || ''\n                }\n              }\n            }\n            \n            if (cityInfo) {\n              console.log(`${service.name}成功获取地址信息`)\n              return cityInfo\n            } else {\n              throw new Error(`${service.name}未返回有效地址信息`)\n            }\n          } catch (error) {\n            console.warn(`${service.name}失败:`, error.message)\n            \n            // 如果是取消请求，直接抛出\n            if (error.name === 'AbortError') {\n              throw error\n            }\n            \n            // 继续尝试下一个服务\n            continue\n          }\n        }\n        \n        // 所有在线服务都失败了，降级到离线模式\n        console.log('所有在线地理编码服务都失败，降级到离线模式')\n        throw new Error('所有在线地理编码服务都不可用')\n      }\n      \n      // 创建带超时的Promise\n      const timeoutPromise = new Promise((_, reject) => {\n        setTimeout(() => reject(new Error('在线地理编码超时')), 6000) // 6秒超时\n      })\n      \n      return Promise.race([tryGeocoding(), timeoutPromise])\n      .catch(error => {\n        console.warn('在线地理编码失败，降级到离线模式:', error.message)\n        \n        // 如果是取消请求，直接抛出\n        if (error.name === 'AbortError') {\n          throw error\n        }\n        \n        // 降级到离线模式\n        return this.generateOfflineLocationInfo(position)\n      })\n      .finally(() => {\n        // 清除加载状态\n        this.geoCodeLoading = false\n        if (this.abortController === abortController) {\n          this.abortController = null\n        }\n      })\n    },\n    \n    // JSONP辅助方法\n    fetchWithJSONP: function (url, timeout = 8000) {\n      return new Promise((resolve, reject) => {\n        const callbackName = 'jsonp_callback_' + Math.round(100000 * Math.random())\n        const script = document.createElement('script')\n        \n        // 设置超时\n        const timeoutId = setTimeout(() => {\n          cleanup()\n          reject(new Error('JSONP请求超时'))\n        }, timeout)\n        \n        // 清理函数\n        const cleanup = () => {\n          if (script.parentNode) {\n            script.parentNode.removeChild(script)\n          }\n          if (window[callbackName]) {\n            delete window[callbackName]\n          }\n          clearTimeout(timeoutId)\n        }\n        \n        // 设置回调\n        window[callbackName] = (data) => {\n          cleanup()\n          resolve(data)\n        }\n        \n        // 处理错误\n        script.onerror = () => {\n          cleanup()\n          reject(new Error('JSONP脚本加载失败'))\n        }\n        \n        // 执行请求 - 修复回调函数名称替换\n        const finalUrl = url.replace('CALLBACK_PLACEHOLDER', callbackName)\n        script.src = finalUrl\n        console.log('JSONP请求URL:', finalUrl)\n        document.head.appendChild(script)\n      })\n    },\n    \n    // 离线地理编码\n    getOfflineGeocodingInfo: function (position) {\n      console.log('使用离线地理编码')\n      \n      return new Promise((resolve) => {\n        // 模拟短暂的加载时间\n        setTimeout(() => {\n          // 基于坐标生成基本地理信息\n          const cityInfo = this.generateOfflineLocationInfo(position)\n          \n          console.log('离线位置信息生成:', cityInfo.short_name)\n          resolve(cityInfo)\n        }, 200) // 200ms延迟，提供良好的用户体验\n      })\n      .finally(() => {\n        // 清除加载状态\n        this.geoCodeLoading = false\n        this.abortController = null\n      })\n    },\n    generateOfflineLocationInfo: function (position) {\n      const lat = position.lat\n      const lng = position.lng\n      \n      // 确定大致的地理区域\n      let regionInfo = this.determineRegion(lat, lng)\n      \n      // 生成位置名称\n      const locationName = `${regionInfo.region}地区`\n      \n      return {\n        short_name: locationName,\n        country: regionInfo.country,\n        street_address: `坐标: ${lat.toFixed(6)}, ${lng.toFixed(6)}`,\n        city: regionInfo.city,\n        state: regionInfo.state,\n        postcode: ''\n      }\n    },\n    \n    determineRegion: function (lat, lng) {\n      // 基于坐标范围确定大致地理区域（离线逻辑）\n      \n      // 中国区域判断\n      if (lat >= 18 && lat <= 54 && lng >= 73 && lng <= 135) {\n        if (lat >= 39.4 && lat <= 41.1 && lng >= 115.4 && lng <= 117.5) {\n          return { region: this.$t('locationMgr.beijing'), country: this.$t('locationMgr.china'), city: this.$t('locationMgr.beijingCity'), state: this.$t('locationMgr.beijingCity') }\n        } else if (lat >= 30.8 && lat <= 31.9 && lng >= 120.9 && lng <= 122.0) {\n          return { region: this.$t('locationMgr.shanghai'), country: this.$t('locationMgr.china'), city: this.$t('locationMgr.shanghaiCity'), state: this.$t('locationMgr.shanghaiCity') }\n        } else if (lat >= 22.4 && lat <= 23.6 && lng >= 113.8 && lng <= 114.6) {\n          return { region: this.$t('locationMgr.shenzhen'), country: this.$t('locationMgr.china'), city: this.$t('locationMgr.shenzhenCity'), state: this.$t('locationMgr.guangdongProvince') }\n        } else if (lat >= 30.1 && lat <= 30.9 && lng >= 103.9 && lng <= 104.9) {\n          return { region: this.$t('locationMgr.chengdu'), country: this.$t('locationMgr.china'), city: this.$t('locationMgr.chengduCity'), state: this.$t('locationMgr.sichuanProvince') }\n        } else if (lat >= 22.0 && lat <= 23.6 && lng >= 112.9 && lng <= 114.0) {\n          return { region: this.$t('locationMgr.guangzhou'), country: this.$t('locationMgr.china'), city: this.$t('locationMgr.guangzhouCity'), state: this.$t('locationMgr.guangdongProvince') }\n        } else {\n          return { region: this.$t('locationMgr.china'), country: this.$t('locationMgr.china'), city: this.$t('locationMgr.unknownCity'), state: this.$t('locationMgr.unknownProvince') }\n        }\n      }\n      \n      // 其他主要国家/地区\n      if (lat >= 24.5 && lat <= 49.4 && lng >= -125 && lng <= -66) {\n        return { region: this.$t('locationMgr.usa'), country: this.$t('locationMgr.usa'), city: this.$t('locationMgr.unknownCity'), state: this.$t('locationMgr.unknownState') }\n      } else if (lat >= 45.8 && lat <= 71.0 && lng >= -141 && lng <= -52) {\n        return { region: this.$t('locationMgr.canada'), country: this.$t('locationMgr.canada'), city: this.$t('locationMgr.unknownCity'), state: this.$t('locationMgr.unknownProvince') }\n      } else if (lat >= 35.8 && lat <= 45.6 && lng >= 138.7 && lng <= 146.0) {\n        return { region: this.$t('locationMgr.japan'), country: this.$t('locationMgr.japan'), city: this.$t('locationMgr.unknownCity'), state: this.$t('locationMgr.unknownPrefecture') }\n      } else if (lat >= 33.0 && lat <= 38.6 && lng >= 124.6 && lng <= 130.9) {\n        return { region: this.$t('locationMgr.korea'), country: this.$t('locationMgr.korea'), city: this.$t('locationMgr.unknownCity'), state: this.$t('locationMgr.unknownProvince') }\n      } else if (lat >= 36.0 && lat <= 71.2 && lng >= -11.0 && lng <= 32.0) {\n        return { region: this.$t('locationMgr.europe'), country: this.$t('locationMgr.europe'), city: this.$t('locationMgr.unknownCity'), state: this.$t('locationMgr.unknownRegion') }\n      }\n      \n      // 根据经纬度确定大洲\n      if (lat >= -55 && lat <= 71) {\n        if (lng >= -168 && lng <= -30) {\n          return { region: this.$t('locationMgr.americas'), country: this.$t('locationMgr.americas'), city: this.$t('locationMgr.unknownCity'), state: this.$t('locationMgr.unknownRegion') }\n        } else if (lng >= -11 && lng <= 180) {\n          if (lat >= -47 && lng >= 110) {\n            return { region: this.$t('locationMgr.oceania'), country: this.$t('locationMgr.oceania'), city: this.$t('locationMgr.unknownCity'), state: this.$t('locationMgr.unknownRegion') }\n          } else {\n            return { region: this.$t('locationMgr.asia'), country: this.$t('locationMgr.asia'), city: this.$t('locationMgr.unknownCity'), state: this.$t('locationMgr.unknownRegion') }\n          }\n        }\n      } else if (lat >= -55 && lat <= 37 && lng >= -20 && lng <= 55) {\n        return { region: this.$t('locationMgr.africa'), country: this.$t('locationMgr.africa'), city: this.$t('locationMgr.unknownCity'), state: this.$t('locationMgr.unknownRegion') }\n      }\n      \n      // 默认位置\n      return { \n        region: this.$t('locationMgr.unknown'), \n        country: this.$t('locationMgr.unknownRegion'), \n        city: this.$t('locationMgr.unknownCity'), \n        state: this.$t('locationMgr.unknownRegion') \n      }\n    },\n    formatLocationName: function (address) {\n      // 格式化位置名称，优先显示城市信息\n      const city = address.city || address.town || address.village || address.county\n      const state = address.state || address.province\n      const country = address.country\n      \n      if (city && state) {\n        return `${city}, ${state}`\n      } else if (city) {\n        return city\n      } else if (state) {\n        return state\n      } else if (country) {\n        return country\n      } else {\n        return this.$t('locationMgr.unknownLocation')\n      }\n    },\n    formatBigDataCloudLocationName: function (data) {\n      // 格式化BigDataCloud API的位置名称\n      const city = data.city || data.locality\n      const state = data.principalSubdivision\n      const country = data.countryName\n      \n      if (city && state) {\n        return `${city}, ${state}`\n      } else if (city) {\n        return city\n      } else if (state) {\n        return state\n      } else if (country) {\n        return country\n      } else {\n        return this.$t('locationMgr.unknownLocation')\n      }\n    },\n    formatOpenCageLocationName: function (components) {\n      // 格式化OpenCage API的位置名称\n      const city = components.city || components.town || components.village || components.county\n      const state = components.state || components.province\n      const country = components.country\n      \n      if (city && state) {\n        return `${city}, ${state}`\n      } else if (city) {\n        return city\n      } else if (state) {\n        return state\n      } else if (country) {\n        return country\n      } else {\n        return this.$t('locationMgr.unknownLocation')\n      }\n    },\n    getMapStatusColor: function () {\n      switch (this.currentMapType) {\n        case 'online':\n          return 'green'\n        case 'offline':\n          return this.useOnlineMap ? 'orange' : 'blue'\n        case 'checking':\n          return 'grey'\n        default:\n          return 'red'\n      }\n    },\n    getMapStatusIcon: function () {\n      switch (this.currentMapType) {\n        case 'online':\n          return 'mdi-cloud-check'\n        case 'offline':\n          return 'mdi-cloud-off'\n        case 'checking':\n          return 'mdi-loading mdi-spin'\n        default:\n          return 'mdi-alert-circle'\n      }\n    },\n    getMapStatusText: function () {\n      switch (this.currentMapType) {\n        case 'online':\n          return this.$t('locationMgr.onlineMap')\n        case 'offline':\n          return this.useOnlineMap ? this.$t('locationMgr.offlineMapFallback') : this.$t('locationMgr.offlineMap')\n        case 'checking':\n          return this.$t('locationMgr.checking')\n        default:\n          return this.$t('locationMgr.connectionFailed')\n      }\n    },\n    onMapTypeToggle: function () {\n      // 用户切换地图模式\n      console.log('用户切换地图模式为:', this.useOnlineMap ? '在线地图' : '离线地图')\n      \n      if (this.useOnlineMap) {\n        // 用户选择在线模式，检测网络并尝试使用在线地图\n        this.detectAndSetMapType()\n      } else {\n        // 用户选择离线模式，直接切换到离线地图\n        this.currentMapType = 'offline'\n        this.url = this.fallbackUrl\n        console.log('🔧 用户手动选择离线地图')\n        \n        // 更新缩放限制\n        this.$nextTick(() => {\n          if (this.$refs.myMap && this.$refs.myMap.mapObject) {\n            const map = this.$refs.myMap.mapObject\n            map.invalidateSize()\n            this.updateZoomLimits(map)\n          }\n        })\n      }\n    },\n    \n    // 网络连接检测\n    checkNetworkConnection: function () {\n      return new Promise((resolve) => {\n        // 方法1: 检测navigator.onLine\n        if (!navigator.onLine) {\n          console.log('网络检测: navigator.onLine为false')\n          resolve(false)\n          return\n        }\n        \n        // 方法2: 尝试访问地理编码服务来测试网络\n        const testUrls = [\n          // 直接测试地理编码服务\n          'https://nominatim.openstreetmap.org/reverse?format=json&lat=40&lon=116&accept-language=en',\n          // 备用测试\n          'https://www.openstreetmap.org/favicon.ico'\n        ]\n        \n        let completed = 0\n        let hasSuccess = false\n        const timeout = 3000 // 减少到3秒超时\n        \n        testUrls.forEach((url, index) => {\n          // 使用fetch测试，更准确\n          const controller = new AbortController()\n          const timeoutId = setTimeout(() => controller.abort(), timeout)\n          \n          fetch(url, {\n            method: 'HEAD',\n            mode: 'no-cors', // 避免CORS问题\n            signal: controller.signal,\n            cache: 'no-cache'\n          })\n          .then(() => {\n            clearTimeout(timeoutId)\n            if (!hasSuccess) {\n              hasSuccess = true\n              console.log(`网络检测: ${url} 连接成功`)\n              resolve(true)\n            }\n          })\n          .catch(error => {\n            clearTimeout(timeoutId)\n            completed++\n            console.log(`网络检测: ${url} 连接失败:`, error.name)\n            if (completed === testUrls.length && !hasSuccess) {\n              console.log('网络检测: 所有测试都失败，判定网络不可用')\n              resolve(false)\n            }\n          })\n        })\n        \n        // 总体超时\n        setTimeout(() => {\n          if (!hasSuccess) {\n            console.log('网络检测: 超时，判定网络不可用')\n            resolve(false)\n          }\n        }, timeout + 500)\n      })\n    },\n    \n    // 检测在线地图可用性\n    checkOnlineMapAvailability: function () {\n      return new Promise((resolve) => {\n        const testUrls = [\n          'https://a.tile.openstreetmap.org/0/0/0.png',\n          'https://b.tile.openstreetmap.org/0/0/0.png',\n          'https://c.tile.openstreetmap.org/0/0/0.png'\n        ]\n        \n        let completed = 0\n        let hasSuccess = false\n        \n        testUrls.forEach(url => {\n          fetch(url, { \n            method: 'HEAD', \n            mode: 'no-cors',\n            cache: 'no-cache'\n          })\n          .then(() => {\n            if (!hasSuccess) {\n              hasSuccess = true\n              resolve(true)\n            }\n          })\n          .catch(() => {\n            completed++\n            if (completed === testUrls.length && !hasSuccess) {\n              resolve(false)\n            }\n          })\n        })\n        \n        // 3秒超时\n        setTimeout(() => {\n          if (!hasSuccess) {\n            resolve(false)\n          }\n        }, 3000)\n      })\n    },\n    \n    // 检测并设置地图类型（仅在用户选择在线模式时调用）\n    detectAndSetMapType: async function () {\n      this.currentMapType = 'checking'\n      console.log('检测在线地图可用性...')\n      \n      try {\n        // 检测网络连接\n        this.isNetworkConnected = await this.checkNetworkConnection()\n        console.log('网络连接状态:', this.isNetworkConnected)\n        \n        if (this.isNetworkConnected) {\n          // 检测在线地图可用性\n          this.isOnlineMapAvailable = await this.checkOnlineMapAvailability()\n          console.log('在线地图可用性:', this.isOnlineMapAvailable)\n          \n          if (this.isOnlineMapAvailable) {\n            this.currentMapType = 'online'\n            this.url = this.onlineUrl\n            console.log('✅ 使用在线地图')\n          } else {\n            this.currentMapType = 'offline'\n            this.url = this.fallbackUrl\n            console.log('⚠️ 在线地图不可用，自动降级到离线地图')\n          }\n        } else {\n          // 网络不可用，降级到离线地图\n          this.currentMapType = 'offline'\n          this.url = this.fallbackUrl\n          console.log('📡 网络不可用，自动降级到离线地图')\n        }\n        \n        // 更新地图\n        this.$nextTick(() => {\n          if (this.$refs.myMap && this.$refs.myMap.mapObject) {\n            const map = this.$refs.myMap.mapObject\n            map.invalidateSize()\n            // 根据新的地图类型更新缩放限制\n            this.updateZoomLimits(map)\n          }\n        })\n        \n      } catch (error) {\n        console.error('地图检测失败:', error)\n        this.currentMapType = 'offline'\n        this.url = this.fallbackUrl\n        this.isNetworkConnected = false\n        this.isOnlineMapAvailable = false\n        console.log('❌ 检测失败，降级到离线地图')\n      }\n    },\n    \n    // 启动网络状态监控\n    startNetworkMonitoring: function () {\n      // 监听网络状态变化事件（这些是真正的网络状态变化）\n      window.addEventListener('online', () => {\n        console.log('系统网络连接恢复')\n        // 只有在用户偏好在线地图时才重新检测\n        if (this.useOnlineMap) {\n          this.detectAndSetMapType()\n        }\n      })\n      \n      window.addEventListener('offline', () => {\n        console.log('系统网络连接断开')\n        this.isNetworkConnected = false\n        this.isOnlineMapAvailable = false\n        this.currentMapType = 'offline'\n        this.url = this.fallbackUrl\n      })\n      \n      // 定期检测频率大幅降低，避免频繁网络请求\n      this.networkCheckInterval = setInterval(() => {\n        // 只有在以下条件全部满足时才重新检测：\n        // 1. 用户选择在线地图\n        // 2. 当前使用离线地图\n        // 3. 系统显示网络在线\n        if (this.useOnlineMap && \n            this.currentMapType === 'offline' && \n            navigator.onLine) {\n          console.log('尝试从离线模式恢复到在线模式')\n          this.detectAndSetMapType()\n        }\n      }, 60000) // 降低到每60秒检测一次\n    },\n    \n    // 拖拽结束事件\n    dragEnd: function (event) {\n      const newPos = {\n        lat: event.target._latlng.lat,\n        lng: event.target._latlng.lng,\n        accuracy: 0\n      }\n      \n      console.log('拖拽结束，新位置:', newPos.lat.toFixed(6), newPos.lng.toFixed(6))\n      \n      // 使用新的updateMapPosition方法处理拖拽\n      this.updateMapPosition(newPos.lat, newPos.lng, {\n        updateMarker: true,\n        fetchAddress: true,\n        animate: false,  // 拖拽时不使用动画\n        accuracy: 0\n      })\n      \n      // 发送位置重置事件（保持向后兼容）\n      // this.$emit('resetLocation', newPos.lat, newPos.lng)\n    },\n    \n    // 便捷方法：快速跳转到指定位置（带动画）\n    flyToPosition: function (lat, lng, zoom = null) {\n      return this.updateMapPosition(lat, lng, {\n        animate: true,\n        zoom: zoom,\n        updateMarker: true,\n        fetchAddress: true\n      })\n    },\n    \n    // 便捷方法：直接设置位置（无动画）\n    setPosition: function (lat, lng, zoom = null) {\n      return this.updateMapPosition(lat, lng, {\n        animate: false,\n        zoom: zoom,\n        updateMarker: true,\n        fetchAddress: true\n      })\n    },\n    \n    // 便捷方法：仅更新地图中心（不移动地图钉）\n    centerMapAt: function (lat, lng, zoom = null, animate = true) {\n      return this.updateMapPosition(lat, lng, {\n        animate: animate,\n        zoom: zoom,\n        updateMarker: false,\n        fetchAddress: false\n      })\n    },\n    \n    \n    // 便捷方法：通过已知位置对象更新\n    updateToKnownLocation: function (locationObj, animate = true) {\n      if (!locationObj || !this.isValidLocation(locationObj)) {\n        console.error('无效的位置对象:', locationObj)\n        return false\n      }\n      \n      return this.updateMapPosition(locationObj.lat, locationObj.lng, {\n        animate: animate,\n        updateMarker: true,\n        fetchAddress: false,  // 已知位置通常不需要重新获取地址\n        accuracy: locationObj.accuracy || 0\n      })\n    }\n  },\n  components: { LMap, LTileLayer, LMarker, LCircle, LTooltip, LControlZoom }\n}\n</script>\n\n<style>\n.leaflet-control-geocoder-form input {\n  caret-color:#000 !important;\n  color: #000 !important;\n}\n\n/* Tooltip样式增强 */\n.leaflet-tooltip {\n  font-size: 12px !important;\n  font-weight: 500 !important;\n}\n\n.leaflet-tooltip strong {\n  color: #ff9800 !important;\n}\n\n.leaflet-tooltip small {\n  font-style: italic;\n}\n\n/* 拖拽中的标记动画 */\n.leaflet-marker-dragging {\n  transition: none !important;\n}\n</style>\n"]}]}